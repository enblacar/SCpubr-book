# Bar plots

Bar plots are another well known data representation. They are a very handy resource to plot summary statistics for the QC part of any single-cell analysis. Consequently, they are part of `SCpubr`, available on `SCpubr::do_BarPlot()`. Let's say we are interested into plotting the different number of cells in each cluster. 

```{r echo = F}
sample <- readRDS("/b06x-isilon/b06x-g/G703/eblanco/projects/test_SC_datasets/sc_dataset.rds")
```


## Basic usage
```{r, fig.cap = "SCpubr Bar plots, plotting single variables", fig.width=12, fig.height=5}
p1 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters", 
                         legend = F, 
                         plot.title = "Number of cells per cluster")
p2 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters", 
                         legend = F, 
                         plot.title = "Number of cells per cluster", 
                         horizontal = T)
p1 | p2
```
Using `SCpubr::do_BarPlot()` with only `features` yields a simple bar plot which is ordered by descending value. We can also set up the direction of the bars with `horizontal = TRUE/FALSE`, which by default is set to be vertical There are some underlying assumptions that are being taken to generate these plots:

- The values in `features` need to be metadata variables, stored in `object@meta.data`. This a design choice, as data need to be grouped using `dplyr` and `tidyr`. This will also later apply to values provided to `group.by`.
- The feature provided need to have a clear and rather small number of groups. A good estimate on how to assess this is by querying the feature with `table`, as in `table(sample@meta.data[, feature])`.

Focusing on the last point, this would happen if we were to choose a feature with a high number of unique values:

```{r, fig.cap = "SCpubr Bar plots, choosing the wrong variable", fig.width=12, fig.height=5}

p <- SCpubr::do_BarPlot(sample = sample, 
                        features = "nCount_RNA", 
                        legend = F, 
                        plot.title = "Number of UMIs?",
                        horizontal = F)
p
```

This happens, precisely, because of the high amount of unique values for `nCount_RNA`. These type of continuous values is best suited for other data visualizations like a `histogram`.

## Grouping by a second variable
Let's expand on the previous example on the number of cells per cluster. What if we were interested not only on that, but we would like to profile **how many cells from each cluster are present in each of the unique samples present in the Seurat object**? For this, we need to provide `SCpubr::do_BarPlot()` with a second parameter, `group.by`, that tackles how we want the feature to be grouped:

```{r, fig.cap = "SCpubr Bar plots, introducing a variable to group values by", fig.width=12, fig.height=5}
# We only have one value in orig.ident. Let's modify it so that it resembles a multi-sample Seurat object.
sample$modified_orig.ident <- sample(x = c("Sample_A", "Sample_B", "Sample_C"), 
                                     size = ncol(sample), 
                                     replace = T, 
                                     prob = c(0.2, 0.7, 0.1))

p1 <- SCpubr::do_BarPlot(sample, 
                         features = "modified_orig.ident",
                         plot.title = "Number of cells per sample",
                         position = "stack",
                         legend = T,
                         horizontal = F)

p2 <- SCpubr::do_BarPlot(sample, 
                         features = "modified_orig.ident", 
                         group.by = "seurat_clusters",
                         plot.title = "Number of cells per cluster and sample",
                         position = "stack",
                         legend = T,
                         horizontal = F)
p1 | p2
```

As we can see, this nicely yields as many number of bars as unique values in the `feature`, and this bars are segmented by as many times as unique values in `group.by`. At first, this is hard to grasp, but it helps thinking of these two parameters, when used together, as:

- `feature`: What I want to show as different bars.
- `group.by`: Secondary variable on which the bars generated by `feature` can be further subdivided.

Another interesting parameter introduced in the last example is `position`. Position can be either `stack` or `fill`. The difference between them is that `position = "stack"` will yield the total number of cells for each of the unique values in `feature`, while `position = "fill"` will bring all bars to the same height and will split each bar into the proportions within each bar of the different groups (only one if `group.by = NULL` and as many groups if `group.by` is used). Therefore, it becomes highly recommended to use `position = "stack"` when `group.by` is not used and `position = "fill"` otherwise. This is also warned by the package. If you want to silence the warnings, use `verbose = FALSE`. 

```{r, fig.cap = "SCpubr Bar plots, difference between position", fig.width=12, fig.height=10}
# We are going to use the previously generated sample assignment.

p1 <- SCpubr::do_BarPlot(sample, 
                         features = "modified_orig.ident",
                         plot.title = "Without group.by - position = stack",
                         position = "stack",
                         legend = T,
                         horizontal = F)

p2 <- SCpubr::do_BarPlot(sample, 
                         features = "modified_orig.ident",
                         plot.title = "Without group.by - position = fill",
                         position = "fill",
                         legend = T,
                         horizontal = F)

p3 <- SCpubr::do_BarPlot(sample, 
                         features = "modified_orig.ident",
                         group.by = "seurat_clusters",
                         plot.title = "With group.by - position = stack",
                         position = "stack",
                         legend = T,
                         horizontal = F)

p4 <- SCpubr::do_BarPlot(sample, 
                         features = "modified_orig.ident",
                         group.by = "seurat_clusters",
                         plot.title = "With group.by - position = fill",
                         position = "fill",
                         legend = T,
                         horizontal = F)
p <- (p1 | p2) / (p3 | p4)
p
```


## Reordering columns based on a single entity

One advanced use of bar plots, but a very useful one is to reorder the columns based on a single entity in a descending order. This works only when `group.by` is set up and best when `position = "fill"`. For instance, imagine the scenario in which we are heavily interested in cluster 1, and want to reorder the columns based on it. This is achieved by providing `order.by` parameter to `SCpubr::do_BarPlot()`. The value in `order.by` has to be necessary one of the unique values in `group.by`. Therefore, as a best practice, one would want to generate the bar plots without using `order.by` and then decide. Let's also, for the sake of this example, modify the proportions of cluster 1 so that it becomes really evident. This is how it looks:


```{r, fig.cap = "SCpubr Bar plots, reordering the colums using order.by", fig.width=12, fig.height=5}
# Modify proportions. 
sample$modified_seurat_clusters <- as.character(sample$seurat_clusters)
sample$modified_seurat_clusters[sample$modified_orig.ident == "Sample_A" & sample$modified_seurat_clusters %in% c("0", "2", "3", "4", "5", "6", "7")] <- "1"

p1 <- SCpubr::do_BarPlot(sample, 
                         features = "modified_orig.ident",
                         group.by = "modified_seurat_clusters",
                         plot.title = "Number of cells per sample",
                         order.by = "1",
                         position = "stack",
                         legend = T,
                         horizontal = F)

p2 <- SCpubr::do_BarPlot(sample, 
                         features = "modified_orig.ident", 
                         group.by = "modified_seurat_clusters",
                         plot.title = "Number of cells per cluster and sample",
                         order.by = "1",
                         position = "fill",
                         legend = T,
                         horizontal = F)
p1 | p2
```

## Adding the exact values to the bars
Sometimes, we are interested not only in displaying the bars but also reporting the exact number for each bar. This can be achieved by using `add.summary_labels = TRUE`:

```{r, fig.cap = "SCpubr, Adding labels to bars", fig.width=14, fig.height=5}

p1 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters", 
                         legend = FALSE,
                         add.summary_labels = TRUE)
p2 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters", 
                         legend = FALSE,
                         horizontal = TRUE,
                         add.summary_labels = TRUE)
p1 | p2
```

The size of the labels can be adjusted by using `size.labels`. The default value is 3. This value changes the size quite drastically. Modification by low ammounts is reccomended. 
```{r, fig.cap = "SCpubr, Modifying the size of the labels in the bars", fig.width=14, fig.height=5}

p1 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters", 
                         legend = FALSE,
                         add.summary_labels = TRUE,
                         size.labels = 2.5)
p2 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters", 
                         legend = FALSE,
                         horizontal = TRUE,
                         add.summary_labels = TRUE,
                         size.labels = 2.5)
p1 | p2
```

When using in combination with `group.by`, it also adds the value on top of each bar:
```{r, fig.cap = "SCpubr, Adding labels to bars when grouped by another variable", fig.width=14, fig.height=5}
p1 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters",
                         group.by = "modified_orig.ident",
                         legend = TRUE,
                         add.summary_labels = TRUE)
p2 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters",
                         group.by = "modified_orig.ident", 
                         legend = TRUE,
                         horizontal = TRUE,
                         add.summary_labels = TRUE)
p1 | p2
```

If we are also interested in adding labels to each of the bar sugroups, we can do so by using `add.subgroup_labels = TRUE`:

```{r, fig.cap = "SCpubr, Adding labels to bars and subgroups when grouped by another variable", fig.width=14, fig.height=5}
p1 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters",
                         group.by = "modified_orig.ident",
                         legend = TRUE,
                         add.summary_labels = TRUE,
                         add.subgroup_labels = TRUE)
p2 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters",
                         group.by = "modified_orig.ident", 
                         legend = TRUE,
                         horizontal = TRUE,
                         add.summary_labels = TRUE,
                         add.subgroup_labels = TRUE)
p1 | p2
```

As can be observed, this type of labelling is very situational and highly depends on the overall structure of the bars and whether it is feasible to plot that many labels. In order to ease this cluttering, one can pass `repel.subroup_labels = TRUE` to avoid overlapping of the group labels (the colored ones inside the bars). 

```{r, fig.cap = "SCpubr, Relocating group labels", fig.width=14, fig.height=5}
p1 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters",
                         group.by = "modified_orig.ident",
                         legend = TRUE,
                         add.summary_labels = TRUE,
                         add.subgroup_labels = TRUE,
                         repel.subgroup_labels = TRUE)
p2 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters",
                         group.by = "modified_orig.ident", 
                         legend = TRUE,
                         horizontal = TRUE,
                         add.summary_labels = TRUE,
                         add.subgroup_labels = TRUE,
                         repel.subgroup_labels = TRUE)
p1 | p2
```

If we also want the summary labels (the ones in black at the top of each bar) to relocate, we can use `repel.summary_labels = TRUE`. This combination of parameters were designed to grant the user freedom to keep either of the two groups of labels centered and to make either group appear or disappear (as each bar plot will have a different scenario and sometimes it might be a viable option).

```{r, fig.cap = "SCpubr, Adding relocating all bars", fig.width=14, fig.height=5}
p1 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters",
                         group.by = "modified_orig.ident",
                         legend = TRUE,
                         add.summary_labels = TRUE,
                         add.subgroup_labels = TRUE,
                         repel.summary_labels = TRUE,
                         repel.subgroup_labels = TRUE)
p2 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters",
                         group.by = "modified_orig.ident",
                         legend = TRUE,
                         horizontal = TRUE,
                         add.summary_labels = TRUE,
                         add.subgroup_labels = TRUE,
                         repel.summary_labels = TRUE,
                         repel.subgroup_labels = TRUE)
p1 | p2
```

From the time being, the labelling feature is only available on `position = "stack"`.


## Adding custom color scales

If necessary, the colors of the plots can be easily changed using the `colors.use` parameter, which requires a **named vector** containing the HEX codes of the colors to show and the names of the unique values that are being used as color groups. Here is one example:

```{r, fig.cap = "SCpubr, modifying colors", fig.width=12, fig.height=5}
# Create a color scale for the unique values in seurat clusters.
colors <- c("0" = "#001219",
            "1" = "#005f73",
            "2" = "#0a9396",
            "3" = "#94d2bd",
            "4" = "#e9d8a6",
            "5" = "#ee9b00",
            "6" = "#ca6702",
            "7" = "#bb3e03",
            "8" = "#ae2012",
            "9" = "#9b2226")

p1 <- SCpubr::do_BarPlot(sample = sample, 
                         features = "seurat_clusters", 
                         legend = FALSE, 
                         plot.title = "Number of cells per cluster", 
                         horizontal = TRUE, 
                         colors.use = colors)
p2 <- SCpubr::do_BarPlot(sample, 
                         features = "modified_orig.ident",
                         group.by = "seurat_clusters",
                         plot.title = "With group.by - position = fill",
                         position = "fill",
                         legend = TRUE,
                         horizontal = FALSE,
                         colors.use = colors)
p1 | p2
```


## Retrieving the data matrix

Many times, not only we are interested in actually displaying the data, but we do also want to store the data matrix. This is a common case for supplementary material in publications. To assess this, one can set `return_data_matrix = TRUE`, which will output a list containing both the plot and the data matrix (long and wide format). This does also work when several features are queried at the same time. Both for `position = "fill"` and `position = "stack"` the output will be the same, the total counts.

```{r, fig.cap = "SCpubr, outputting data matrices, long format", fig.width=12, fig.height=5}
output <- SCpubr::do_BarPlot(sample, 
                             features = "modified_orig.ident",
                             group.by = "seurat_clusters",
                             legend = TRUE,
                             horizontal = FALSE,
                             return_data_matrix = TRUE)
# Retrieve plot.
plot <- output$plot

# Retrieve data in long format.
data.long <- output$data[["modified_orig.ident"]]$long

# Show data in long format.
knitr::kable(head(data.long, 5), booktabs = TRUE) %>%
  kableExtra::kable_styling(font_size = 12)
```

```{r, fig.cap = "SCpubr, outputting data matrices, long format", fig.width=12, fig.height=5}
output <- SCpubr::do_BarPlot(sample, 
                             features = "modified_orig.ident",
                             group.by = "seurat_clusters",
                             legend = TRUE,
                             horizontal = FALSE,
                             return_data_matrix = TRUE)
# Retrieve plot.
plot <- output$plot

# Retrieve data in long format.
data.long <- output$data[["modified_orig.ident"]]$long

# Retrieve data in wide format.
data.wide <- output$data[["modified_orig.ident"]]$wide

# Show data in wide format.
knitr::kable(head(data.wide, 5), booktabs = TRUE) %>%
  kableExtra::kable_styling(font_size = 12)
```
Each type of data matrix is beneficial for different purposes. Long data is the desired format if you want to store the data matrix for future use in plotting. Wide data, in turn, is easier to understand right away.




