[{"path":"index.html","id":"about-this-package","chapter":"About this package","heading":"About this package","text":"package aims provide streamlined way generating publication ready plots known Single-Cell visualizations “publication ready” format (SCpubr). , aim automatically generate plots highest quality possible, can used right away minimal modifications research article.subjective term “aesthetically pleasant” can , set theme modifications implemented across different plot types. package also serves personal project, future prospects growth.","code":""},{"path":"installation-guide.html","id":"installation-guide","chapter":"Installation guide","heading":"Installation guide","text":"package can installed using following commands:packages needed order run different functions:circlizecolorspaceComplexHeatmapdplyrenrichRforcatsggbeeswarmggExtraggplot2ggplotifyggrastrggrepelggridgesggsankeyggigniflianamaggritrmonocle3NebulosapatchworkpbapplyplyrrlangscalesscattermoreSeuratstringrsvglitetibbletidyrviridisAll packages can installed using following commands:One can check dependencies running SCpubr::state_dependencies().","code":"\n# From CRAN:\n# Future sumission to CRAN.\n\n# From GitHub.\nif(!requireNamespace(\"devtools\", quietly = T)){\n  install.packages(\"devtools\") # If not installed.\n}\ndevtools::install_github(\"enblacar/SCpubr\")\n# Install CRAN packages.\ncran_packages <- c(\"circlize\",\n                   \"colorspace\",\n                   \"dplyr\",\n                   \"enrichR\",\n                   \"forcats\",\n                   \"ggbeeswarm\",\n                   \"ggdist\",\n                   \"ggExtra\",\n                   \"ggplot2\",\n                   \"ggplotify\",\n                   \"ggrastr\",\n                   \"ggrepel\",\n                   \"ggridges\",\n                   \"ggsignif\",\n                   \"grDevices\",\n                   \"grid\",\n                   \"magrittr\",\n                   \"patchwork\",\n                   \"pbapply\",\n                   \"plyr\",\n                   \"rlang\",\n                   \"scales\",\n                   \"scattermore\",\n                   \"Seurat\",\n                   \"stats\",\n                   \"stringr\",\n                   \"svglite\",\n                   \"tibble\",\n                   \"tidyr\",\n                   \"viridis\")\n\ninstall.packages(cran_packages)\n\n# Install bioconductor packages.\nbioconductor_packages <- c(\"ComplexHeatmap\",\n                           \"infercnv\",\n                           \"Nebulosa\")\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(bioconductor_packages)\n\n# Install github packages.\ngithub_packages <- c(\"ggsankey\",\n                     \"liana\",\n                     \"monocle3\")\n\nif (!requireNamespace(\"remotes\", quietly = TRUE))\n    install.packages(\"remotes\")\n\nremotes::install_github(github_packages)"},{"path":"dataset-used.html","id":"dataset-used","chapter":"Dataset used","heading":"Dataset used","text":"manual going use publicly available dataset containing 10K raw cells. following code used generate Seurat object ready plotting.","code":"\ncounts_path <- \"path_to_count_matrix\"\n\n# Path count matrix.\ncounts <- Seurat::Read10X(counts_path)\n# Create Seurat object.\nsample <- Seurat::CreateSeuratObject(counts = counts, project = \"10K_pbmc\")\n# Compute percentage of mithochondrial RNA.\nsample <- Seurat::PercentageFeatureSet(sample, pattern = \"^MT-\", col.name = \"percent.mt\")\n# Compute QC.\nmask1 <- sample$nCount_RNA >= 1000\nmask2 <- sample$nFeature_RNA >= 500\nmask3 <- sample$percent.mt <= 20\nmask <- mask1 & mask2 & mask3\nsample <- sample[, mask]\n# Normalize.\nsample <- Seurat::SCTransform(sample)\n\n# Dimensional reduction.\nsample <- Seurat::RunPCA(sample)\nsample <- Seurat::RunUMAP(sample, dims = 1:30)\n# Find clusters.\nsample <- Seurat::FindNeighbors(sample, dims = 1:30)\nsample <- Seurat::FindClusters(sample, resolution = 0.2)"},{"path":"dim-plots.html","id":"dim-plots","chapter":"1 Dim plots","heading":"1 Dim plots","text":"Dimensional reduction Plots (DimPlots) , probably, one iconic visualizations Seurat. allows user visualize cells dimensional reduction embedding PCA UMAP. cells can , , colored desired groups. short, visualization allows user plot kind categorical data onto cells dimensional reduction embedding.","code":""},{"path":"dim-plots.html","id":"basic-usage","chapter":"1 Dim plots","heading":"1.1 Basic usage","text":"SCpubr’s take Seurat::DimPlot().\nFigure 1.1: SCpubr DimPlot vs Seurat DimPlot.\nEven though axes removed UMAP reductions, title axes kept reduction used. applied UMAP default dimension order altered.\nFigure 1.2: SCpubr DimPlot PCA embedding showing axes titles UMAP changing default dimension component order.\ncan change legend’s number columns rows legend.ncol legend.nrow.\nFigure 1.3: SCpubr DimPlot legend left.\n","code":"\n# Seurat's DimPlot.\np1 <- Seurat::DimPlot(sample)\n\n# SCpubr's DimPlot.\np2 <- SCpubr::do_DimPlot(sample = sample)\n\np <- p1 | p2\np\n# Example using PCA reduction.\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         reduction = \"pca\")\n\n# Example using a non-canonical set of dimensions.\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         dims = c(2, 1))\n\np <- p1 | p2\np\n# Modify the number of columns in the legend.\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.ncol = 2)\n\n# Modify the number of rows in the legend.\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.nrow = 3)\n\np <- p1 | p2 \np"},{"path":"dim-plots.html","id":"using-labels-instead-of-a-legend","chapter":"1 Dim plots","heading":"1.2 Using labels instead of a legend","text":"cases, especially early analysis numbers cluster names, might want remove legend entirely, instead plot labels top cluster. achieved using label = TRUE. looks Seurat:\nFigure 1.4: Seurat DimPlot labels top clusters.\nHowever, can play parameters function label.color provide different color text inside labels:\nFigure 1.5: Seurat DimPlot labels top clusters different color.\nFinally, one can always get rid legend legend.position = \"none:\nFigure 1.6: Seurat DimPlot without legend.\n","code":"\n# Put labels on top of the clusters.\np <- Seurat::DimPlot(sample, \n                     label = T)\np\n# Change the color of the text in the labels.\np <- SCpubr::do_DimPlot(sample = sample, \n                        label = TRUE, \n                        label.color = \"black\")\np\n# Remove the legend from the plot.\np <- SCpubr::do_DimPlot(sample = sample, \n                        label = TRUE, \n                        legend.position = \"none\")\np"},{"path":"dim-plots.html","id":"changing-the-order-of-plotting","chapter":"1 Dim plots","heading":"1.3 Changing the order of plotting","text":"default, cells SCpubr::do_DimPlot() randomly plotted using shuffle = TRUE. done default behavior Seurat::DimPlot() plot cells based factor levels identities. Sometimes, way plotting results clusters visible another one top . However, behavior might intended, even , like specific identity stand rest. can achieved providing order parameter either vector identities ordered however want, just identities, plotted top rest. However, still clear whether using order alongside shuffle = TRUE unexpected side effects. , please use alongside shuffle = FALSE. following example, going test:going bring cluster 5 front.order one value values.order shuffle = TRUE/FALSE.increase dot size better see cells cluster 7, data set lack overlapping clusters..\nFigure 1.7: SCpubr, modifying order plotted identities DimPlot\ncan see cluster 5 always plots top cluster 0 order set. still clear order shuffle interact, apparent using order cancels original behavior shuffle. Therefore, order shuffle set, SCpubr::do_DimPlot() throw warning.","code":"\n# Regular SCpubr DimPlot.\np1 <- SCpubr::do_DimPlot(sample = sample,\n                         reduction = \"pca\",\n                         plot.title = \"Normal DimPlot\")\n\n# Using order with one value and shuffle = TRUE.\np2 <- SCpubr::do_DimPlot(sample = sample,\n                         shuffle = TRUE,\n                         order = \"5\",\n                         reduction = \"pca\",\n                         plot.title = \"shuffle = TRUE\")\n\n# Using order with one value and shuffle = FALSE.\np3 <- SCpubr::do_DimPlot(sample = sample,\n                         shuffle = FALSE,\n                         order = \"5\",\n                         reduction = \"pca\",\n                         plot.title = \"shuffle = FALSE\")\n\n# Using order with all values.\np4 <- SCpubr::do_DimPlot(sample = sample,\n                         shuffle = FALSE,\n                         order = c(\"5\", \"8\", \"4\",\n                                   \"9\", \"3\", \"1\",\n                                   \"6\", \"0\", \"7\", \"2\"),\n                         reduction = \"pca\",\n                         plot.title = \"shuffle = FALSE all identities\")\n\np <- (p1 | p2) / (p3 | p4)\np"},{"path":"dim-plots.html","id":"highlighting-cells","chapter":"1 Dim plots","heading":"1.4 Highlighting cells","text":"One nice features Seurat::DimPlot() possibility highlighting certain group cells plot. achieved using cells.highligh parameter. default plot looks like SCpubr::do_DimPlot()’s take :\nFigure 1.8: Highlighting cells, comparison Seurat SCpubr.\nOne can also change color highligted cells providing single color colors.use color selected cells na.value:\nFigure 1.9: SCpubr DimPlot highlighting cells changing default colors.\ndefault, size cells SCpubr::do_DimPlot() . However, size highlighted dots can modified parameter sizes.highlight.\nFigure 1.10: SCpubr DimPlot highlighting cells bigger dot size.\ncan also highlight whole identities idents.highlight parameter. , just provide desired identities selected. can also work combination cells.highlight.\nFigure 1.11: SCpubr DimPlot highlighting cells testing combinations cells.highlight idents.highlight.\n","code":"\ncells.use <- sample(x = colnames(sample), \n                    size = 1500)\n\n# Compare Seurat and SCpubr way of highlighting cells.\np1 <- Seurat::DimPlot(sample, \n                      cells.highlight = cells.use)\n\np2 <- SCpubr::do_DimPlot(sample = sample,\n                         cells.highlight = cells.use)\n\np <- p1 | p2\np\n# Change color of highlighted and non-highlighted cells.\np <- SCpubr::do_DimPlot(sample = sample, \n                        cells.highlight = cells.use,\n                        colors.use = \"black\",\n                        na.value = \"grey90\")\np\n# Increase the size of the highlighted cells.\np <- SCpubr::do_DimPlot(sample = sample, \n                        cells.highlight = cells.use, \n                        sizes.highlight = 1)\np\n# Using cells.highlight.\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         cells.highlight = cells.use)\n\n# Using idents.highlight.\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         idents.highlight = c(\"6\"))\n\n# Using both.\np3 <- SCpubr::do_DimPlot(sample = sample, \n                         cells.highlight = cells.use, \n                         idents.highlight = c(\"6\"))\n\np <- p1 | p2 | p3\np"},{"path":"dim-plots.html","id":"restrict-the-identitites-shown-and-grey-out-the-rest","chapter":"1 Dim plots","heading":"1.5 Restrict the identitites shown and grey out the rest","text":"Sometimes, interested showing identities groups sample, instead previous approach, still want keep original colors legend. , might inclined just subset sample, follows:\nFigure 1.12: Seurat DimPlot selecting identities subsetting sample.\nHowever, end losing UMAP silhouette. , SCpubr::do_DimPlot() introduces idents.keep parameter, can provide vector identities want keep. assign rest cells value NA colored according na.value parameter:\nFigure 1.13: Seurat DimPlot selecting identities using idents.keep.\n","code":"\n# Subset desired identities in a DimPlot.\np <- SCpubr::do_DimPlot(sample = sample[, sample$seurat_clusters %in% c(\"0\", \"5\")])\n\np\n# Select identities with idents.keep.\np1 <- SCpubr::do_DimPlot(sample = sample,\n                         idents.keep = c(\"0\", \"5\"))\n\n# Also, non-selected cells's color can be modified.\np2 <- SCpubr::do_DimPlot(sample = sample,\n                         idents.keep = c(\"0\", \"5\"),\n                         na.value = \"grey50\")\np <- p1 | p2\np"},{"path":"dim-plots.html","id":"splitting-by-a-category","chapter":"1 Dim plots","heading":"1.6 Splitting by a category","text":"Another useful parameter Seurat::DimPlot split., allows split DimPlot multiple panels, one containing different unique value metadata variable provided argument. One can understand using group.parameter splitting resulting DimPlot different panels. example, going use different clusters example. looks default:\nFigure 1.14: Seurat DimPlot using split..\ncan observed, plot accomplish task separating cells panel, approach followed actually makes interpretation difficult. Clusters Cluster 9, fewer cells, tell pretty much nothing. Besides, losing UMAP silhouette major downside approach. SCpubr focus . generates many plots unique values metadata split plot , uses cells.highlight instead, keeps rest cells greyed according na.value color. looks:\nFigure 1.15: SCpubr DimPlot using split..\nway, can see clusters Cluster 7 way disperse rest, accounting standalone groups cells also blending bigger clusters.interested subset possible values, can use idents.keep alongside vector containing values keep unique values split.:\nFigure 1.16: SCpubr DimPlot using split.idents.keep.\nActually, user might want change color highlighted cells split DimPlot. achieved using colors.use parameter providing either vector valid color representations equal length unique values split.just single color use panels.\nFigure 1.17: SCpubr DimPlot using split.changed color\n","code":"\n# Seurat's DimPlot using split.by\np <- Seurat::DimPlot(sample, \n                     split.by = \"seurat_clusters\", \n                     ncol = 5)\n\np\n# SCpubr's DimPlot using split.by\np <- SCpubr::do_DimPlot(sample, \n                        split.by = \"seurat_clusters\", \n                        ncol = 5, \n                        legend.position = \"none\",\n                        font.size = 24)\n\np\n# Using split.by and restricting the number of output plots with idents.keep.\np <- SCpubr::do_DimPlot(sample, \n                        split.by = \"seurat_clusters\", \n                        ncol = 3, \n                        idents.keep = c(\"0\", \"1\", \"7\"),\n                        legend.position = \"none\",\n                        font.size = 24)\n\np\n# Create a color scale for the unique values in seurat clusters.\ncolors <- c(\"0\" = \"#001219\",\n            \"1\" = \"#005f73\",\n            \"2\" = \"#0a9396\",\n            \"3\" = \"#94d2bd\",\n            \"4\" = \"#e9d8a6\",\n            \"5\" = \"#ee9b00\",\n            \"6\" = \"#ca6702\",\n            \"7\" = \"#bb3e03\",\n            \"8\" = \"#ae2012\",\n            \"9\" = \"#9b2226\")\n\n# Use a custom set of colors, one for each identity.\np1 <- SCpubr::do_DimPlot(sample, \n                         split.by = \"seurat_clusters\", \n                         ncol = 5, \n                         legend.position = \"none\", \n                         colors.use = colors,\n                         font.size = 24)\n\n# Use the same color for all identities.\np2 <- SCpubr::do_DimPlot(sample, \n                         split.by = \"seurat_clusters\", \n                         ncol = 5, \n                         legend.position = \"none\",\n                         colors.use = \"#008080\",\n                         font.size = 24)\n                         \np <- p1 / p2\np"},{"path":"feature-plots.html","id":"feature-plots","chapter":"2 Feature plots","heading":"2 Feature plots","text":"Another flagship function Seurat Seurat::FeaturePlot(). basically counterpart Seurat::DimPlot() , instead coloring cells based categorical color scale, uses continuous scale instead, according variable provided user. can range gene expression, metadata variables number genes, even values principal component.","code":""},{"path":"feature-plots.html","id":"basic-usage-1","chapter":"2 Feature plots","heading":"2.1 Basic usage","text":"SCpubr’s take Seurat::FeaturePlot():\nFigure 1.1: SCpubr do_FeaturePlot vs Seurat FeaturePlot\ndefault, SCpubr::do_FeaturePlot() enlarges dots bit modifies legend, better stand . Even though axes removed UMAP reductions, title axes kept reduction used. applied UMAP default dimension order altered.\nFigure 1.2: SCpubr Feature showing axes titles.\n","code":"\n# Seurat's Feature Plot.\np1 <- Seurat::FeaturePlot(sample, \n                          features = \"PC_1\")\n\n# SCpubr's Feature Plot.\np2 <- SCpubr::do_FeaturePlot(sample = sample,\n                             features = \"PC_1\")\n\np <- p1 | p2\np\n# Use case with PCA embedding.\np1 <- SCpubr::do_FeaturePlot(sample = sample, \n                             features = \"CD14\",\n                             plot.title = \"Plotting PCA coordinates\",\n                             reduction = \"pca\")\n\n# Use case with non-canonical dimensions.                             \np2 <- SCpubr::do_FeaturePlot(sample = sample, \n                             features = \"CD14\",\n                             plot.title = \"Plotting UMAP coordinates in a different order\",\n                             dims = c(2, 1))\n\np <- p1 | p2\np"},{"path":"feature-plots.html","id":"multiple-features","chapter":"2 Feature plots","heading":"2.2 Multiple features","text":"SCpubr::do_FeaturePlot() can tackle multiple queries time. Plots can rearranged desired ncol parameter:\nFigure 1.3: SCpubr FeaturePlot, 4 features 2 columns\nmultiple queries, using plot.title parameter actually adds general title plots. one wants modify title plot independently, vector length number features needs provided individual.titles parameter. case title need changed, use NA instead.\nFigure 1.4: SCpubr FeaturePlot, individual modified titles\nconcept can applied individual subtitles captions. , need use individual.subtitles individual.captions parameters.\nFigure 1.5: SCpubr FeaturePlot, individual modified titles, subtitles captions.\n","code":"\n# Query multiple features at the same time.\np <- SCpubr::do_FeaturePlot(sample, features = c(\"nCount_RNA\", \n                                                 \"nFeature_RNA\", \n                                                 \"percent.mt\", \n                                                 \"CD14\"), \n                            plot.title = \"A collection of features\", \n                            ncol = 2)\n\np\n# Add individual titles to the plots.\np <- SCpubr::do_FeaturePlot(sample = sample,\n                            features = c(\"nCount_RNA\",\n                                         \"nFeature_RNA\",\n                                         \"percent.mt\",\n                                         \"CD14\"),\n                            plot.title = \"A collection of features\",\n                            individual.titles = c(\"Plot A\",\n                                                  \"Plot_B\",\n                                                  NA,\n                                                  \"Plot_D\"),\n                            ncol = 2)\n\np\n# Add individual titles, subtitles and captions.\np <- SCpubr::do_FeaturePlot(sample = sample,\n                            features = c(\"nCount_RNA\",\n                                         \"nFeature_RNA\",\n                                         \"percent.mt\",\n                                         \"CD14\"),\n                            plot.title = \"A collection of features\",\n                            plot.subtitle = \"Everything is commented!\",\n                            plot.caption = \"Dataset from: ...\",\n                            individual.titles = c(\"Plot A\",\n                                                  \"Plot_B\",\n                                                  NA,\n                                                  \"Plot_D\"),\n                            individual.subtitles = c(\"Subtitle A\",\n                                                  NA,\n                                                  \"Subtitle C\",\n                                                  \"Subtitle D\"),\n                            individual.captions = c(\"Caption A\",\n                                                  \"Caption B\",\n                                                  \"Caption C\",\n                                                  \"Caption D\"),\n                            ncol = 2)\n\np"},{"path":"feature-plots.html","id":"working-with-subsets-of-cells","chapter":"2 Feature plots","heading":"2.3 Working with subsets of cells","text":"One things can misleading case specific subset cells driving ends color scales. Let’s say identified clusters 2, 5, 8 responsible behavior. like plot values without taking cells consideration. first thing comes mind , indeed, removing cells completely, resulting following:\nFigure 1.6: SCpubr FeaturePlot, removing cells clusters 2, 5 8\nHowever, falls back problem Seurat::DimPlot split.parameter. lose overall context cells , lost original UMAP silhouette. can fixed using cells.highlight parameter:\nFigure 1.7: SCpubr FeaturePlot, masking cells clusters 2, 5 8\nway, adding cells back modifying legend, accomplish desired effect. Furthermore, SCpubr::do_FeaturePlot() also accepts vector identities plot, long part levels(seurat_object). can achieved using idents.highlight instead.\nFigure 1.8: SCpubr FeaturePlot, masking cells clusters 2, 5 8 using idents.highlight\n","code":"\n# Subset the cells in the Seurat object to remove unwanted cells.\ncells.plot <- colnames(sample[, !(sample$seurat_clusters %in% c(\"2\", \"5\", \"8\"))])\n\np <- SCpubr::do_FeaturePlot(sample[, cells.plot], \n                            features = c(\"CD14\"))\n\np\n# Using cells.highlight parameter to select the cells we want to include in the plot.\np <- SCpubr::do_FeaturePlot(sample = sample, \n                            cells.highlight = cells.plot, \n                            features = c(\"CD14\"))\n\np\n# Selecting given identitites to include in the plot.\np <- SCpubr::do_FeaturePlot(sample = sample, \n                            idents.highlight = levels(sample)[!(levels(sample) %in% c(\"0\", \"2\", \"5\", \"8\"))], \n                            features = c(\"CD14\"))\n\np"},{"path":"feature-plots.html","id":"splitting-the-featureplot-by-a-variable","chapter":"2 Feature plots","heading":"2.4 Splitting the FeaturePlot by a variable","text":"cases, want visualize given feature, let’s say, expression LYN across another variable, instance seurat_clusters. can achieved easily Seurat using split.parameter. sake representation, let’s reduce number clusters.\nFigure 1.9: Seurat FeaturePlot split clusters.\nApart general aesthetic discrepancies mentioned , two main aspects missing. First, loss UMAP silhouette. Secondly, knowing , default, color scale shared across plots, like know range values color scale displaying. two aspects SCpubr::do_FeaturePlot() delves :\nFigure 1.10: SCpubr FeaturePlot split clusters.\nway, able achieve better understandable plot. Furthermore, can query multiple features. following example, provide three possible examples features:LYN gene located rownames count matrix (`rownames(sample)``).nCount_RNA metadata variable located colnames(sample@meta.data).PC_1 column dimensional reduction embedding, located colnames(sample@reductions[[\"pca\"]][[]])\nFigure 1.11: SCpubr FeaturePlot split clusters using multiple features.\ncan even subset previous plot set ofidentities split.particularly interested . color scale also limits contain values selected identities. can achieved provided vector identities split..idents parameter.\nFigure 1.12: SCpubr FeaturePlot split clusters using multiple features selected identities.\n","code":"\n# Group clusters into three values for visualization purposes.\nsample$new_clusters <- as.character(sample$seurat_clusters)\nsample$new_clusters[sample$new_clusters %in% c(\"0\", \"1\", \"2\", \"3\")] <- \"Cluster 1\"\nsample$new_clusters[sample$new_clusters %in% c(\"4\", \"5\", \"6\")] <- \"Cluster 2\"\nsample$new_clusters[sample$new_clusters %in% c(\"7\", \"8\", \"9\")] <- \"Cluster 3\"\n\n# Seurat Feature Plot using split.by.\np <- Seurat::FeaturePlot(sample, \n                         features = \"LYN\", \n                         split.by = \"new_clusters\")\np\n# SCpubr Feature Plot using split.by\np <- SCpubr::do_FeaturePlot(sample = sample, \n                            features = \"LYN\", \n                            split.by = \"new_clusters\")\n\np\n# Use split.by with multiple features.\np <- SCpubr::do_FeaturePlot(sample, \n                            features = c(\"LYN\", \"nCount_RNA\", \"PC_1\"), \n                            split.by = \"new_clusters\")\n                            \np\n# Using split.by.idents parameter alongside split.by.\np <- SCpubr::do_FeaturePlot(sample, \n                            features = c(\"LYN\", \"nCount_RNA\", \"PC_1\"), \n                            split.by = \"seurat_clusters\", \n                            split.by.idents = c(\"2\", \"5\"))\n\np"},{"path":"feature-plots.html","id":"apply-symmetrical-color-scales","chapter":"2 Feature plots","heading":"2.5 Apply symmetrical color scales","text":"times want color Feature plot using two-end continuous color scale. can achieve using enforce_symmetry = TRUE:\nFigure 1.13: SCpubr FeaturePlot using two-end continuous scale.\none can observe, parameters sets scale centered around 0, two ends value. allows direct comparison colors.","code":"\n# Enforce two-end symmetrical color scale.\np1 <- SCpubr::do_FeaturePlot(sample, \n                             features = \"PC_1\",\n                             enforce_symmetry = FALSE)\n\np2 <- SCpubr::do_FeaturePlot(sample, \n                             features = \"PC_1\",\n                             enforce_symmetry = TRUE)\n\np <- p1 | p2\np"},{"path":"nebulosa-plots.html","id":"nebulosa-plots","chapter":"3 Nebulosa plots","heading":"3 Nebulosa plots","text":"plot comes straight Nebulosa package. information, vignette. short, computes “density” whether surrounding cells (UMAP embedding) also express variable provide function, variables one feed Seurat::FeaturePlot(). default plot looks like:","code":""},{"path":"nebulosa-plots.html","id":"basic-usage-2","chapter":"3 Nebulosa plots","heading":"3.1 Basic usage","text":"\nFigure 1.1: Nebulosa plot\nway, know clusters enriched CD14, also know regions highest density cells expressing . Minor modifications, line rest plots, applied SCpubr:\nFigure 1.2: SCpubr Nebulosa plot.\n, type visualization becomes natural partner `Seurat::FeaturePlot()’ able visualize expression variable, also query density surrounding cells. example:\nFigure 1.3: SCpubr FeaturePlot NebulosaPlot.\nNebulosa package also offers option query multiple features time:\nFigure 1.4: SCpubr Nebulosa plot multiple features.\n","code":"\np <- Nebulosa::plot_density(sample,\n                            features = \"CD14\")\np\np <- SCpubr::do_NebulosaPlot(sample = sample, \n                             features = \"CD14\")\np\np1 <- SCpubr::do_FeaturePlot(sample = sample, \n                             features = \"CD14\") \np2 <- SCpubr::do_NebulosaPlot(sample = sample, \n                              features = \"CD14\")\np1 | p2\np <- SCpubr::do_NebulosaPlot(sample, \n                             features = c(\"CD14\", \"CD8A\"))\np"},{"path":"nebulosa-plots.html","id":"compute-joint-densities","chapter":"3 Nebulosa plots","heading":"3.2 Compute joint densities","text":", intriguingly, can also compute joint density features. achieved parsing joint = TRUE.\nFigure 1.5: SCpubr Nebulosa plot joint density\ninterested retrieving joint density plot, can accomplish return_only_joint parameter. Please note , since return one plot, wanted modify plot title, use plot.title instead:\nFigure 1.6: SCpubr Nebulosa plot joint density, selecting last plot\n","code":"\np <- SCpubr::do_NebulosaPlot(sample = sample, \n                             features = c(\"CD14\", \"CD8A\"), \n                             joint = TRUE)\np \nfeatures.use <- c(\"CD14\", \"CD8A\")\n\np <- SCpubr::do_NebulosaPlot(sample = sample, \n                             features = c(\"CD14\", \"CD8A\"), \n                             joint = TRUE, \n                             return_only_joint = TRUE,\n                             plot.title = \"Joint density CD14+-CD8A+\")\n\np"},{"path":"nebulosa-plots.html","id":"modify-titles-individually","chapter":"3 Nebulosa plots","heading":"3.3 Modify titles individually","text":"query multiple features use joint = TRUE, using plot.title add general title different panels generated. modify plot title individual panel, vector length number features needs provided individual.titles parameter. case title need changed, use NA instead. Please take note joint = TRUE generate extra panel needs another plot title.\nFigure 1.7: SCpubr Nebulosa plot joint density, modifying individual plot’s name\n","code":"\np <- SCpubr::do_NebulosaPlot(sample = sample, \n                             features = c(\"CD14\", \"CD8A\"), \n                             joint = TRUE, \n                             individual.titles = c(\"Plot A\",\n                                                   NA,\n                                                   \"Combined density\"),\n                             plot.title = \"Density analysis\")\np"},{"path":"bee-swarm-plots.html","id":"bee-swarm-plots","chapter":"4 Bee Swarm plots","heading":"4 Bee Swarm plots","text":"interesting plot. stems idea can order (rank) cells given variable. variable continuous variable, better representation. order goes lowest maximum value. , cells grouped variable interest displayed scatter plot fashion.Put example, let’s say cells queried enrichment given list genes. can done using Seurat::AddModuleScore(), returns one score cell. continuous variable. , can rank (.e: provide order lowest highest), giving cell lowest enrichment score first rank one maximum value last rank. plot rank right away, see behaves linear distribution:\nFigure 1.1: Distribution enrichment scores ranks.\ncan observe, ranks behave linear fashion expected. However, interesting part comes subset distribution another variable:\nFigure 1.2: Splitting ranks groups.\n, can see clusters show distribution ranks. clusters distribution shifted higher ranks others lower ones. Plotting differential distributions nice way aim SCpubr::do_BeeSwarmPlot(). achieved using ggbeeswarm package. idea using ggbeeswarm::geom_quasirandom() geometry provided package implement single-cell analyses came tutorial Broad Institute.","code":"\n# Compute enrichment.\ngene_list <- c(\"OLIG1\", \"MBP\")\nsample <- Seurat::AddModuleScore(sample, features = list(gene_list), name = \"testing_list\")\n\n# Rank the enrichment scores.\nsample$rank <- rank(sample$testing_list1)\n\n# Visualize the two distribution.\np1 <- SCpubr::do_ViolinPlot(sample = sample,\n                         feature = \"testing_list1\",\n                         group.by = \"orig.ident\")\np2 <- sample@meta.data %>% # Extract metadata\n      dplyr::mutate(cell_name = rownames(sample@meta.data)) %>% # Get the cell names.\n      dplyr::select(.data$cell_name, .data$rank) %>% # Select the columns to plot.\n      dplyr::arrange(.data$rank) %>% # Reorder the rows.\n      dplyr::mutate(cell_name = factor(.data$cell_name, levels = .data$cell_name)) %>% # Conver to factor for plotting.\n      ggplot2::ggplot(mapping = ggplot2::aes(x = .data$cell_name, y = .data$rank)) +\n      ggplot2::geom_point() +\n      ggplot2::theme(axis.text = ggplot2::element_blank(),\n                     axis.ticks = ggplot2::element_blank()) + \n      ggplot2::xlab(\"Cell name\") + \n      ggplot2::ylab(\"Rank\")\np <- p1 | p2\np\n\np <- sample@meta.data %>% # Extract metadata\n      dplyr::mutate(cell_name = rownames(sample@meta.data)) %>% # Get the cell names.\n      dplyr::select(.data$cell_name, .data$rank, .data$seurat_clusters) %>% # Select the columns to plot.\n      dplyr::arrange(.data$rank) %>% # Reorder the rows.\n      dplyr::mutate(cell_name = factor(.data$cell_name, levels = .data$cell_name)) %>% # Conver to factor for plotting.\n      ggplot2::ggplot(mapping = ggplot2::aes(x = .data$cell_name, y = .data$rank)) +\n      ggplot2::geom_point() +\n      ggplot2::theme(axis.text = ggplot2::element_blank(),\n                     axis.ticks = ggplot2::element_blank()) + \n      ggplot2::xlab(\"Cell name\") + \n      ggplot2::ylab(\"Rank\") + \n      ggplot2::facet_wrap(\"seurat_clusters\", ncol = 5)\np"},{"path":"bee-swarm-plots.html","id":"using-categorical-variables","chapter":"4 Bee Swarm plots","heading":"4.1 Using categorical variables","text":"Let’s say want focus much cluster driven PC_1 PC_2. first thought just use SCpubr::do_Dimplot() plot PCA embedding instead UMAP. also query PC_3 PC_4 --clear example.\nFigure 1.3: Plotting PCA embeddings SCpubr::do_DimPlot()\n, get right away decent overview. Clusters 0, 5, 7 8 separate PC_1 rest. However, many cases clear, image right. Bee Swarm plots come handy. implemented SCpubr::do_BeeSwarmPlot(). function needs user provide:\n- variable rank feature_to_rank.\n- groups divide plot group..\n- Whether output colored categorical continuous scale, continuous_feature.\nFigure 1.4: SCpubr Bee Swarm plots categorical variables.\n, selected PC_1 PC_4. can observe X axis Bee Swarm plot displays ordering (rank) cells across selected feature. Focusing PC_1, can see cluster 0 completely shifted right PC_1, nicely displayed Bee Swarm plot cells also ranked high (higher rank, bigger “value” feature rank, case, PC_1 value). case PC_4, Bee Swarm plot nicely shows clusters lay upper, lower middle part PC_4.important thing note kind plots cells rank. , imagine scenario like PC_4, artificially remove clusters 0, 3, 5, 7, 8, 9, leaving forming “straight line” PC_4. nature plot also separate remaining clusters:\nFigure 1.5: SCpubr Bee Swarm plots similar values.\nSee, still clearly see two groups, formed clusters 1 2, clusters 4 6. even remove clusters 1 2 still see similar effect.\nFigure 1.6: SCpubr Bee Swarm plots almost identical values.\ncan seen , clusters now span X axis. cells still ranked, therefore showing cloud dots. , just want , data visualization technique, plot comes set benefits caveats. visualization suffers trying plot highly similar values. Therefore, key understand nature variable want rank beforehand.","code":"\np1 <- SCpubr::do_DimPlot(sample, \n                         reduction = \"pca\", \n                         label = T, \n                         legend.position = \"none\", \n                         dims = c(1, 2)) \np2 <- SCpubr::do_DimPlot(sample, \n                         reduction = \"pca\", \n                         label = T, \n                         legend.position = \"none\",\n                         dims = c(3, 4)) \n\np1 | p2\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         reduction = \"pca\", \n                         label = T, \n                         legend.position = \"none\",\n                         dims = c(1, 2))\n\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         reduction = \"pca\", \n                         label = T, \n                         legend.position = \"none\",\n                         dims = c(3, 4)) \n\np3 <- SCpubr::do_BeeSwarmPlot(sample = sample, \n                              feature_to_rank = \"PC_1\", \n                              group.by = \"seurat_clusters\", \n                              continuous_feature = F)\n\np4 <- SCpubr::do_BeeSwarmPlot(sample = sample, \n                              feature_to_rank = \"PC_4\", \n                              group.by = \"seurat_clusters\", \n                              continuous_feature = F)\n\n(p1 | p3) / (p2 | p4)\n# Clusters to exclude.\nclusters_exclude <- c(\"0\", \"3\", \"5\", \"7\", \"8\", \"9\")\n\n# Keep the original coloring.\ncols.use <- colorspace::qualitative_hcl(length(levels(sample)), \n                                        palette = \"Dark 3\")\nnames(cols.use) <- levels(sample)\n\n# Only provide the needed colors. If more are provided, an error is thrown.\ncols.use <- cols.use[!(names(cols.use) %in% clusters_exclude)]\n\np1 <- SCpubr::do_DimPlot(sample = sample[, !(sample$seurat_clusters %in% clusters_exclude)], \n                         reduction = \"pca\", \n                         label = T, \n                         legend.position = \"none\",\n                         dims = c(3, 4), \n                         colors.use = cols.use) \np2 <- SCpubr::do_BeeSwarmPlot(sample = sample[, !(sample$seurat_clusters %in% clusters_exclude)], \n                              feature_to_rank = \"PC_4\", \n                              group.by = \"seurat_clusters\", \n                              continuous_feature = F, \n                              colors.use = cols.use)\n\np1 | p2\n# Clusters to exclude.\nclusters_exclude <- c(\"0\", \"1\", \"2\", \"3\", \"5\", \"7\", \"8\", \"9\")\n\n# Keep the original coloring.\ncols.use <- colorspace::qualitative_hcl(length(levels(sample)), \n                                        palette = \"Dark 3\")\nnames(cols.use) <- levels(sample)\n\n# Only provide the needed colors. If more are provided, an error is thrown.\ncols.use <- cols.use[!(names(cols.use) %in% clusters_exclude)]\n\n\np1 <- SCpubr::do_DimPlot(sample = sample[, !(sample$seurat_clusters %in% clusters_exclude)], \n                         reduction = \"pca\", \n                         label = T, \n                         legend.position = \"none\", \n                         dims = c(3, 4), \n                         colors.use = cols.use) \np2 <- SCpubr::do_BeeSwarmPlot(sample = sample[, !(sample$seurat_clusters %in% clusters_exclude)], \n                              feature_to_rank = \"PC_4\", \n                              group.by = \"seurat_clusters\", \n                              continuous_feature = F, \n                              colors.use = cols.use)\n\np1 | p2"},{"path":"bee-swarm-plots.html","id":"using-continuous-variables","chapter":"4 Bee Swarm plots","heading":"4.2 Using continuous variables","text":"also scenarios want rank cells continuous variable, instead showing colors group (anyway depicted Y axis), want introduce continuous color scale. specially interesting assess enrichment clusters towards given set features.\nFigure 1.7: Using continuous color scale SCpubr::do_BeeSwarmPlot().\nusing combination figures, can also assess monocyte signature seems predominantly enriched clusters 0 7.","code":"\n# Set up list of a genes to compute enrichment. Let's use a monocyte signature.\ngenes.use <- c(\"CD14\", \"LYZ\")\n\n# Compute enrichment and rename the output.\nsample <- Seurat::AddModuleScore(sample, \n                                 features = genes.use, \n                                 name = \"Monocyte_signature\")\nsample$Monocyte_signature <- sample$Monocyte_signature1\nsample$Monocyte_signature1 <- NULL\n\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         label = T, \n                         legend.position = \"none\")\np2 <- SCpubr::do_FeaturePlot(sample = sample, \n                             features = \"Monocyte_signature\",\n                             legend.title = \"Monocyte signature\") \np3 <- SCpubr::do_BeeSwarmPlot(sample = sample, \n                              feature_to_rank = \"Monocyte_signature\", \n                              group.by = \"seurat_clusters\", \n                              continuous_feature = T,\n                              legend.title = \"Monocyte signature\")\np1 | p2 | p3"},{"path":"violin-plots.html","id":"violin-plots","chapter":"5 Violin plots","heading":"5 Violin plots","text":"Violin plots require little description. depiction distribution variable. makes ideal order show differential enrichment patterns alongside different groups. , also included Seurat Seurat::VlnPlot() function. first time new user encounters function likely going querying different QC paramters, number UMIs, number genes percentage mitochondrial RNA. looks number UMIs:","code":""},{"path":"violin-plots.html","id":"basic-usage-3","chapter":"5 Violin plots","heading":"5.1 Basic usage","text":"\nFigure 1.1: Seurat’s violin plot.\none thing really stands , indeed, extra dots plotted alongside violin plot. Since dot represent cell, quickly becomes dominant feature figure. One can play alpha dots reduce presence:\nFigure 1.2: Seurat’s violin plot transparent dots.\nstill, making dots almost invisible, still observe dominance bigger clusters. Therefore, ’s better remove . , together modifications basis SCpubr::do_ViolinPlot(). default plot looks like:\nFigure 1.3: SCpubr’s violin plot.\naddition removing dots, boxplot added violin shape, get better sense quantiles distribution. effect can removed using plot_boxplot = FALSE. Also, legend default removed, groups displayed already X axis.\nFigure 1.4: SCpubr’s violin plot without box plots.\nwant rotate X axis labels, can also providing rotate_x_axis_labels = TRUE/FALSE:\nFigure 1.5: SCpubr’s violin plot rotating x axis.\n","code":"\np <- Seurat::VlnPlot(sample, \n                     feature = \"nCount_RNA\")\np\np <- Seurat::VlnPlot(sample, \n                     feature = \"nCount_RNA\")\n# \"Surgically\" add the alpha parameter in the ggplot2 object.\np$layers[[2]]$aes_params$alpha <- 0.05\np\n# Basic violin plot.\np <- SCpubr::do_ViolinPlot(sample = sample, \n                           feature = \"nCount_RNA\")\np\n# Remove the box plots.\np <- SCpubr::do_ViolinPlot(sample = sample, \n                           feature = \"nCount_RNA\",\n                           plot_boxplot = FALSE)\np\n# Rotate x axis labels.\np <- SCpubr::do_ViolinPlot(sample = sample, \n                        feature = c(\"nCount_RNA\"),\n                        rotate_x_axis_labels = FALSE)\np"},{"path":"violin-plots.html","id":"violin-plots-as-a-means-of-qc","chapter":"5 Violin plots","heading":"5.2 Violin plots as a means of QC","text":"QC analyses, users might want also add features line indicating put cutoff. can achieved using y_cut parameter. Currently, one value per plot y_cut can used.\nFigure 1.6: SCpubr’s violin plot horizontal line.\n","code":"\n# Add horizontal lines.\np <- SCpubr::do_ViolinPlot(sample = sample, \n                           feature = \"nCount_RNA\", \n                           y_cut = 25000)\np"},{"path":"violin-plots.html","id":"modifying-aesthetics","chapter":"5 Violin plots","heading":"5.3 Modifying aesthetics","text":"Sometimes might want modify overall look violin plots. instance, line width violin shape box plot can modified line_width parameter, defaults 1.\nFigure 1.7: SCpubr’s violin plot increased line width\nAlso, width box plots can modified boxplot_width parameter, defaults 0.2. aware parameter scales width boxplot. , value 1 provided, box plot take much space violin shape. recommended deviate 0.2 small amount.\nFigure 1.8: SCpubr’s violin plot decreased box plot width\n","code":"\n# Increase line width.\np1 <- SCpubr::do_ViolinPlot(sample = sample,\n                         feature = \"nCount_RNA\")\n\np2 <- SCpubr::do_ViolinPlot(sample = sample,\n                         feature = \"nCount_RNA\",\n                         line_width = 2)\n\np <- p1 / p2\np\n# Decrease boxplot width.\np1 <- SCpubr::do_ViolinPlot(sample = sample,\n                            feature = \"nCount_RNA\")\n\np2 <- SCpubr::do_ViolinPlot(sample = sample,\n                            feature = \"nCount_RNA\",\n                            boxplot_width = 0.1)\n\np <- p1 / p2\np"},{"path":"ridge-plots.html","id":"ridge-plots","chapter":"6 Ridge plots","heading":"6 Ridge plots","text":"Ridge plots interesting way display multiple violin plots together. main idea type visualization observe shifts distribution given variable across several groups. can accomplished using package.","code":""},{"path":"ridge-plots.html","id":"basic-usage-4","chapter":"6 Ridge plots","heading":"6.1 Basic usage","text":"basic ridge plot can computed :\nFigure 1.1: Basic ridge plot\n","code":"\n# Compute the most basic ridge plot.\np <- SCpubr::do_RidgePlot(sample = sample,\n                          feature = \"nFeature_RNA\")\np"},{"path":"ridge-plots.html","id":"use-continuous-color-scales","chapter":"6 Ridge plots","heading":"6.2 Use continuous color scales","text":"default, groups plotted current identities sample, can changed using group.. One can also color ridges based continuous values represented, using continuous_scale = TRUE. direction color scale can controlled using viridis_direction :\nFigure 1.2: Basic ridge plot colored using continuous scale.\n","code":"\n# Use continuous color scale.\np1 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           viridis_direction = 1)\n\np2 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           viridis_direction = -1)\n\np <- p1 / p2\np"},{"path":"ridge-plots.html","id":"plot-quantiles-of-the-distribution","chapter":"6 Ridge plots","heading":"6.3 Plot quantiles of the distribution","text":"One can also draw quantiles distribution groups. , need set scale continuous. Also, can modify quantiles using quantiles parameter:\nFigure 1.3: RidgePlots quantiles.\n","code":"\n# Draw quantiles of the distribution.\np1 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           compute_quantiles = TRUE,\n                           compute_custom_quantiles = TRUE)\n\np2 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           compute_quantiles = TRUE,\n                           compute_custom_quantiles = TRUE,\n                           quantiles = c(0.1, 0.5, 0.75))\n\np <- p1 / p2\np"},{"path":"ridge-plots.html","id":"compute-probability-tails","chapter":"6 Ridge plots","heading":"6.4 Compute probability tails","text":"One can draw probability tails distribution using compute_distribution_tails prob_tails.\nFigure 1.4: RidgePlots probability tails.\n","code":"\n# Draw probability tails.\np1 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           compute_quantiles = TRUE,\n                           compute_distribution_tails = TRUE)\n\np2 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           compute_quantiles = TRUE,\n                           compute_distribution_tails = TRUE,\n                           prob_tails = 0.3)\n\np <- p1 / p2\np"},{"path":"ridge-plots.html","id":"compute-probability-densities","chapter":"6 Ridge plots","heading":"6.5 Compute probability densities","text":"One can also display probability densities distributions using :\nFigure 1.5: RidgePlots probability densities.\n","code":"\n# Draw probability tails.\np <- SCpubr::do_RidgePlot(sample = sample,\n                          feature = \"nFeature_RNA\",\n                          continuous_scale = TRUE,\n                          compute_quantiles = TRUE,\n                          color_by_probabilities = TRUE)\np"},{"path":"dot-plots.html","id":"dot-plots","chapter":"7 Dot plots","heading":"7 Dot plots","text":"Dot plots nice data representation technique. involves use two scales. One scale color-based second one size-based. context Seurat::DotPlot(), scales pre-defined contain average expression values color scale percentage cells within group expressing feature size, increasing percentage grows bigger. heavily implied features need genes, otherwise color scale lost. output Seurat:","code":""},{"path":"dot-plots.html","id":"basic-usage-5","chapter":"7 Dot plots","heading":"7.1 Basic usage","text":"\nFigure 1.1: Seurat DotPlot\ncan seen, try plot type variables, resulting plot contain color scale. SCpubr::do_DimPlot() focuses enhancing overall appearance plots. Implementation using types features currently supported. looks using SCpubr::do_DimPlot():\nFigure 1.2: SCpubr DotPlot\n","code":"\np1 <- Seurat::DotPlot(sample, \n                      features = \"CD14\")\np2 <- Seurat::DotPlot(sample, \n                      features = \"nCount_RNA\")\np <- p1 | p2\np\np1 <- SCpubr::do_DotPlot(sample = sample, \n                         features = \"CD14\")\np2 <- SCpubr::do_DotPlot(sample = sample, \n                         features = \"nFeature_RNA\")\np <- p1 | p2\np"},{"path":"dot-plots.html","id":"querying-multiple-features-at-once","chapter":"7 Dot plots","heading":"7.2 Querying multiple features at once","text":"true power data visualization relies querying multiple genes . Let’s query ones described Seurat vignette:\nFigure 1.3: SCpubr DotPlot using multiple genes\n, can clearly distinguish clusters highly enriched given genes. proves interesting way query cluster identities. highly dependent, though, accuracy selected genes queried dataset. actually provide list genes named list, can facet plot different list genes provided:\nFigure 1.4: SCpubr DotPlot using multiple genes\n","code":"\ngenes <- c(\"IL7R\", \"CCR7\", \"CD14\", \"LYZ\", \n           \"S100A4\", \"MS4A1\", \"CD8A\", \"FCGR3A\", \n           \"MS4A7\", \"GNLY\", \"NKG7\", \"FCER1A\", \n           \"CST3\", \"PPBP\")\np <- SCpubr::do_DotPlot(sample = sample, \n                        features = genes)\np\ngenes <- list(\"Naive CD4+ T\" = c(\"IL7R\", \"CCR7\"),\n              \"CD14+ Mono\" = c(\"CD14\", \"LYZ\"),\n              \"Memory CD4+\" = c(\"S100A4\"),\n              \"B\" = c(\"MS4A1\"),\n              \"CD8+ T\" = c(\"CD8A\"),\n              \"FCGR3A+ Mono\" = c(\"FCGR3A\", \"MS4A7\"),\n              \"NK\" = c(\"GNLY\", \"NKG7\"),\n              \"DC\" = c(\"FCER1A\", \"CST3\"),\n              \"Platelet\" = c(\"PPBP\"))\np <- SCpubr::do_DotPlot(sample = sample, \n                        features = genes)\np"},{"path":"dot-plots.html","id":"clustering-the-identities","chapter":"7 Dot plots","heading":"7.3 Clustering the identities","text":"One really cool feature Seurat::DotPlot() lets cluster identities Y axis depending similar across values X axis. achieved using cluster.idents = TRUE, parameter also implemented SCpubr::do_DotPlot():\nFigure 1.5: SCpubr DotPlot using multiple genes clustering identities\n","code":"\ngenes <- list(\"Naive CD4+ T\" = c(\"IL7R\", \"CCR7\"),\n              \"CD14+ Mono\" = c(\"CD14\", \"LYZ\"),\n              \"Memory CD4+\" = c(\"S100A4\"),\n              \"B\" = c(\"MS4A1\"),\n              \"CD8+ T\" = c(\"CD8A\"),\n              \"FCGR3A+ Mono\" = c(\"FCGR3A\", \"MS4A7\"),\n              \"NK\" = c(\"GNLY\", \"NKG7\"),\n              \"DC\" = c(\"FCER1A\", \"CST3\"),\n              \"Platelet\" = c(\"PPBP\"))\np1 <- SCpubr::do_DotPlot(sample = sample, \n                         features = genes,\n                         plot.title = \"Not clustered\")\np2 <- SCpubr::do_DotPlot(sample = sample, \n                         features = genes, \n                         cluster.idents = TRUE, \n                         plot.title = \"Clustered\")\np <- p1 / p2\np"},{"path":"dot-plots.html","id":"inverting-the-axes","chapter":"7 Dot plots","heading":"7.4 Inverting the axes","text":"SCpubr::do_DotPlot(), can also invert axes, groups X axis genes Y axis. achieved using flip = TRUE. Note, however, work using named list genes input, completely distort way facets computed. Given , combination parameters currently blocked SCpubr.\nFigure 1.6: SCpubr DotPlot using multiple genes clustering identities flipping axes\n","code":"\ngenes <- c(\"IL7R\", \"CCR7\", \"CD14\", \"LYZ\", \n           \"S100A4\", \"MS4A1\", \"CD8A\", \"FCGR3A\", \n           \"MS4A7\", \"GNLY\", \"NKG7\", \"FCER1A\", \n           \"CST3\", \"PPBP\")\np1 <- SCpubr::do_DotPlot(sample = sample, \n                         features = genes, \n                         plot.title = \"Not clustered\", \n                         flip = T)\np2 <- SCpubr::do_DotPlot(sample = sample, \n                         features = genes, \n                         cluster.idents = TRUE, \n                         plot.title = \"Clustered\", \n                         flip = T,\n                         rotate_x_axis_labels = FALSE)\np <- p1 | p2\np"},{"path":"bar-plots.html","id":"bar-plots","chapter":"8 Bar plots","heading":"8 Bar plots","text":"Bar plots another well known data representation. handy resource plot summary statistics QC part single-cell analysis. Consequently, part SCpubr, available SCpubr::do_BarPlot(). Let’s say interested plotting different number cells cluster.","code":""},{"path":"bar-plots.html","id":"basic-usage-6","chapter":"8 Bar plots","heading":"8.1 Basic usage","text":"\nFigure 1.1: SCpubr Bar plots, plotting single variables\nUsing SCpubr::do_BarPlot() group.yields simple bar plot ordered descending value. can also set direction bars flip = TRUE/FALSE, default set vertical. underlying assumption taken generate plots:values group.need metadata variables, stored object@meta.data. either character factor columns.","code":"\n# Basic bar plot, horizontal.\np1 <- SCpubr::do_BarPlot(sample = sample, \n                         group.by = \"seurat_clusters\", \n                         legend.position = \"none\", \n                         plot.title = \"Number of cells per cluster\")\n\n# Basic bar plot, vertical.\np2 <- SCpubr::do_BarPlot(sample = sample, \n                         group.by = \"seurat_clusters\", \n                         legend.position = \"none\",\n                         plot.title = \"Number of cells per cluster\", \n                         flip = TRUE)\np <- p1 | p2\np"},{"path":"bar-plots.html","id":"grouping-by-a-second-variable","chapter":"8 Bar plots","heading":"8.2 Grouping by a second variable","text":"Let’s expand previous example number cells per cluster. interested , like profile many cells cluster present unique samples present Seurat object? , need provide SCpubr::do_BarPlot() second parameter, split., tackles want feature grouped:\nFigure 1.2: SCpubr Bar plots, introducing variable group values \ncan see, nicely yields many number bars unique values group., bars segmented many times unique values split.. first, hard grasp, helps thinking two parameters, used together, :group.: want show different bars, total number counts.split.: Secondary variable bars generated group.can subdivided.Another interesting parameter introduced last example position. Position can either stack fill. difference position = \"stack\" yield total number cells unique values feature, position = \"fill\" bring bars height split bar proportions within bar different groups (one group.= NULL many groups group.used). Therefore, becomes highly recommended use position = \"stack\" group.used position = \"fill\" otherwise. also warned package. want silence warnings, use verbose = FALSE.\nFigure 1.3: SCpubr Bar plots, difference position\n","code":"\nsample$modified_orig.ident <- sample(x = c(\"Sample_A\", \"Sample_B\", \"Sample_C\"), \n                                     size = ncol(sample), \n                                     replace = T, \n                                     prob = c(0.2, 0.7, 0.1))\n\n# Split by a second variable.\np1 <- SCpubr::do_BarPlot(sample,\n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         plot.title = \"Number of cells per cluster in each sample\",\n                         position = \"stack\")\n\np2 <- SCpubr::do_BarPlot(sample, \n                         group.by = \"modified_orig.ident\", \n                         split.by = \"seurat_clusters\",\n                         plot.title = \"Number of cells per sample in each cluster\",\n                         position = \"stack\")\np <- p1 | p2\np\n# Position stack and fill with and without split.by.\np1 <- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         plot.title = \"Without split.by - position = stack\",\n                         position = \"stack\",\n                         flip = FALSE)\n\np2 <- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         plot.title = \"Without split.by - position = fill\",\n                         position = \"fill\",\n                         flip = FALSE)\n\np3 <- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         plot.title = \"With split.by - position = stack\",\n                         position = \"stack\",\n                         flip = FALSE)\n\np4 <- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         plot.title = \"With split.by - position = fill\",\n                         position = \"fill\",\n                         flip = FALSE)\np <- (p1 | p2) / (p3 | p4)\np"},{"path":"box-plots.html","id":"box-plots","chapter":"9 Box plots","heading":"9 Box plots","text":"Deep intro goes .","code":""},{"path":"box-plots.html","id":"basic-usage.","chapter":"9 Box plots","heading":"9.1 Basic usage.","text":"generate basic box plot need provide seurat object feature plot:\nFigure 1.1: Basic box plot.\ndefault, groups identities seurat object, can controlled using group.parameter.\nFigure 1.2: Custom groups.\ncan flip plot needed flip = TRUE:\nFigure 1.3: Flip box plot.\ncan also apply another aesthetic style, just colors lines boxplots leave rest white use_silhouette = TRUE:\nFigure 1.4: Apply silhouette style.\ncan reorder values average mean, highest lowest order = TRUE:\nFigure 1.5: Order mean.\ncan apply second grouping using split..\nFigure 1.6: Apply second grouping.\nFinally can apply statistical tests groups, use split.. can setting use_test = TRUE providing comparison list pairs items. test, default wilcoxon test, can modified using test. correct use tests interpretation relies user.\nFigure 1.7: Apply statistical tests.\nOne can display symbols, numbers map_signif_level:\nFigure 1.8: Apply statistical tests show p-value\n","code":"\n# Basic box plot.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\")\np\n# Generate a custom group.\nsample$custom_group = ifelse(colnames(sample) %in% sample(colnames(sample), 4000), \"A\", \"B\")\n\n# Use custom grouping.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        group.by = \"custom_group\")\np\n# Flip the box plot.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        flip = TRUE)\np\n# Use silhouette style.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        use_silhouette = TRUE)\np\n# Order by mean values.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        order = TRUE)\np\n# Apply second grouping.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        split.by = \"custom_group\")\np\n# Apply statistical tests.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        use_test = TRUE,\n                        comparisons = list(c(\"0\", \"1\"),\n                                           c(\"3\", \"4\"),\n                                           c(\"5\", \"9\")))\np\n# Apply statistical tests and show the p-value.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        use_test = TRUE,\n                        comparisons = list(c(\"0\", \"1\"),\n                                           c(\"3\", \"4\"),\n                                           c(\"5\", \"9\")),\n                        map_signif_level = FALSE)\np"},{"path":"geyser-plots.html","id":"geyser-plots","chapter":"10 Geyser plots","heading":"10 Geyser plots","text":"Geyser plots kind scatter plots characterized plotting continuous variable Y axis splitting dots categorical variable X axis. normally results dots collapsing single line along Y axis, jittering can spread , depicting shape resemble Geyser. Furthermore, better understand distribution data along Y axis, distribution intervals plotted top Geyser plots. dot depitcs median data, end thick thin lines represent 66% 95% data group, respectively.plots just alternate way representing can achieved violin plot. However, version allows aesthetic view also allowing user plot another extra variable dots, coloring continuous categorical scale.","code":""},{"path":"geyser-plots.html","id":"basic-usage-7","chapter":"10 Geyser plots","heading":"10.1 Basic usage","text":"basic version plot uses X Y variables, color cells assigned either two. can achieve using SCpubr::do_GeyserPlot() stating kind color scale want scale_type (either continuous categorical).\nFigure 1.1: SCpubr do_GeyserPlot regular use.\n","code":"\n# Geyser plot with categorical color scale.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"nCount_RNA\",\n                            scale_type = \"categorical\")\n\n# Geyser plot with continuous color scale.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"nCount_RNA\",\n                            scale_type = \"continuous\")\n\n\np <- p1 / p2\np"},{"path":"geyser-plots.html","id":"ordering-by-mean-values","chapter":"10 Geyser plots","heading":"10.2 Ordering by mean values","text":"First thing one notice, geysers ordered highest lowest mean values. can nullified using order_by_mean = FALSE. case, geysers order based alphabetical order levels variable chosen factor.\nFigure 1.2: SCpubr do_GeyserPlot without ordering mean.\n","code":"\n# Geyser plot with categorical color scale without ordering by mean.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"nCount_RNA\",\n                            scale_type = \"categorical\",\n                            order_by_mean = FALSE)\n\n# Geyser plot with continuous color scale without ordering by mean.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"nCount_RNA\",\n                            scale_type = \"continuous\",\n                            order_by_mean = FALSE)\n\n\np <- p1 / p2\np"},{"path":"geyser-plots.html","id":"plotting-symmetrical-scales","chapter":"10 Geyser plots","heading":"10.3 Plotting symmetrical scales","text":"Depending case, might case want plot continuous variable spans positive negative values. Although necessary, cases binary nature values biological meaning , therefore, assign two gradient colors (typically blue negative values red positive values) better visualize nature data. can achieve using enforce_symmetry = TRUE.\nFigure 1.3: SCpubr do_GeyserPlot plotting symmetrical scale.\n","code":"\n# Geyser plot with continuous color scale.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = FALSE)\n\n# Geyser plot with continuous and symmetrical color scale.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE)\n\n\np <- p1 / p2\np"},{"path":"geyser-plots.html","id":"select-the-groups-displayed-on-the-x-axis","chapter":"10 Geyser plots","heading":"10.4 Select the groups displayed on the X axis","text":"Furhtermore, can select groups displayed X axis group.parameter. defaults current identities sample provided. also reason X axis title called “Groups”. titles can modified usind xlab ylab, respectively.\nFigure 1.4: SCpubr do_GeyserPlot plotting different groups.\n","code":"\n# Geyser plot with categorical color scale default X axis grouping.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"categorical\",\n                            group.by = NULL,\n                            xlab = \"Seurat clusters\")\n\n# Geyser plot with categorical color scale and custom grouping.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"categorical\",\n                            group.by = \"orig.ident\",\n                            xlab = \"Individual sample\")\n\n\np <- p1 / p2\np"},{"path":"geyser-plots.html","id":"split-the-plot-by-groups","chapter":"10 Geyser plots","heading":"10.5 Split the plot by groups","text":"Apart selecting grouping, can effectively split plot another categorical variable. can achieved using split..\nFigure 1.5: SCpubr do_GeyserPlot splitting groups.\n","code":"\n# We only have one value in orig.ident. Let's modify it so that it resembles a multi-sample Seurat object.\nsample$modified_orig.ident <- sample(x = c(\"Sample_A\", \"Sample_B\", \"Sample_C\"), \n                                     size = ncol(sample), \n                                     replace = T, \n                                     prob = c(0.2, 0.7, 0.1))\n\n# Geyser plot with categorical color scale split by seurat clusters.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"categorical\",\n                            group.by = \"modified_orig.ident\",\n                            split.by = \"seurat_clusters\")\n\n# Geyser plot with continuous color scale split by seurat clusters.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            group.by = \"modified_orig.ident\",\n                            split.by = \"seurat_clusters\")\n\n\np <- p1 / p2\np"},{"path":"geyser-plots.html","id":"rotating-x-axis-labels","chapter":"10 Geyser plots","heading":"10.6 Rotating X axis labels","text":"example , X axis labels might overlap one another. can changed using rotate_x_axis_labels = FALSE,\nFigure 1.6: SCpubr do_GeyserPlot rotating X axis labels.\n","code":"\n# Geyser plot with categorical color scale split by seurat clusters rotating labels.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"categorical\",\n                            group.by = \"modified_orig.ident\",\n                            split.by = \"seurat_clusters\",\n                            rotate_x_axis_labels = FALSE)\n\n# Geyser plot with continuous color scale split by seurat clusters rotating labels.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            group.by = \"modified_orig.ident\",\n                            split.by = \"seurat_clusters\",\n                            rotate_x_axis_labels = FALSE)\n\n\np <- p1 / p2\np"},{"path":"geyser-plots.html","id":"adding-a-third-variable","chapter":"10 Geyser plots","heading":"10.7 Adding a third variable","text":"might noticed, far plots effectively “waste” one axis: either continuous color scale Y axis depict , X axis categorical color scale . can add third variable using color.parameter.\nFigure 1.7: SCpubr do_GeyserPlot adding third variable.\nbehaviour can also applied using split..\nFigure 1.8: SCpubr do_GeyserPlot adding third variable using split..\n","code":"\n# Geyser plot with categorical color scale using color.by.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"categorical\",\n                            color.by = \"modified_orig.ident\")\n\n# Geyser plot with continuous color scale using color.by.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            color.by = \"nCount_RNA\")\n\n\np <- p1 / p2\np\n# Geyser plot with categorical color scale using color.by and split.by.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"categorical\",\n                            group.by = \"orig.ident\",\n                            split.by = \"seurat_clusters\",\n                            color.by = \"modified_orig.ident\")\n\n# Geyser plot with continuous color scale using color.by and split.by.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            color.by = \"nCount_RNA\",\n                            group.by = \"orig.ident\",\n                            split.by = \"seurat_clusters\")\n\n\np <- p1 / p2\np"},{"path":"geyser-plots.html","id":"control-the-jitter-of-the-dots","chapter":"10 Geyser plots","heading":"10.8 Control the jitter of the dots","text":"one wants increase reduce degree dots disperse across X axis, jitter parameter can used, alongside number 0 0.5.\nFigure 1.9: SCpubr do_GeyserPlot controlling jittering.\n","code":"\n# Geyser plot with different jitter.\np0 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.01)\n\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.1)\n\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.2)\n\np3 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.3)\n\np4 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.4)\n\np5 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.49)\n\n\np <- p0 / p1 / p2 / p3 / p4 / p5\np"},{"path":"sankey-and-alluvial-plots.html","id":"sankey-and-alluvial-plots","chapter":"11 Sankey and alluvial plots","heading":"11 Sankey and alluvial plots","text":"Sankey alluvial plots set visualizations help depicting cells “flow” given group another. can particular interesting, let’s say, merged dataset samples different subtypes want see cells subtype distribute along different clusters sample. , similarly, cells cluster distribute across different individual datasets.","code":""},{"path":"sankey-and-alluvial-plots.html","id":"basic-usage-8","chapter":"11 Sankey and alluvial plots","heading":"11.1 Basic usage","text":"can achieve basic Sankey alluvial plots (using package):\nFigure 1.1: Basic Sankey Alluvial plots.\nkey aspects figure one provide starting end groups first_group last_group parameters, type plot type, making either alluvial sankey. major difference simply alluvial plot space groups. allows compact visualization, although can get quite messy depending colors. can keep adding many groups want using middle_groups parameter.\nFigure 1.2: Basic Sankey Alluvial plots groups.\n","code":"\n# Generate a more fine-grained clustering.\nsample <- Seurat::FindSubCluster(sample, cluster = c(\"0\", \"5\"), graph.name = \"SCT_snn\")\n#> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n#> \n#> Number of nodes: 4428\n#> Number of edges: 146366\n#> \n#> Running Louvain algorithm...\n#> Maximum modularity in 10 random starts: 0.7966\n#> Number of communities: 6\n#> Elapsed time: 0 seconds\nsample$sub.cluster <- paste0(\"sub_\", sample$sub.cluster)\n\n# Compute basic sankey plot.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            last_group = \"seurat_clusters\",\n                            type = \"sankey\")\n\n# Compute basic alluvial plot.\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            last_group = \"seurat_clusters\",\n                            type = \"alluvial\")\n\np <- p1 / p2\np\nsample$assignment <- ifelse(sample$seurat_clusters %in% c(\"0\", \"2\", \"4\"), \"A\", \"B\")\n\n# Add more groups.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\")\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"alluvial\")\n\np <- p1 / p2\np"},{"path":"sankey-and-alluvial-plots.html","id":"modify-node-aesthetics","chapter":"11 Sankey and alluvial plots","heading":"11.2 Modify node aesthetics","text":"default, color nodes fill white, can seen. One Can modify using node.fill node.color.\nFigure 1.3: Basic Sankey Alluvial plots modified colors nodes.\ncan seen, text labels, , overlap limits nodes. can fix using width parameter:\nFigure 1.4: Basic Sankey Alluvial plots modified width nodes.\n","code":"\n# Control the color and fill of the nodes.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\")\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"alluvial\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\")\n\np <- p1 / p2\np\n# Control the width of the nodes.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\")\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\",\n                            width = 0.5)\n\np <- p1 / p2\np"},{"path":"sankey-and-alluvial-plots.html","id":"control-alignment-of-the-labels","chapter":"11 Sankey and alluvial plots","heading":"11.3 Control alignment of the labels","text":"can also control alignment labels (goes different different groups default) using hjust parameter. modify nodes.\nFigure 1.5: Basic Sankey Alluvial plots modified label alignment.\ncan also turn text labels, colored based end nodes. can toggle using use_labels = TRUE.\nFigure 1.6: Sankey plots texts labels.\n","code":"\n# Control the alignment of the labels.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\",\n                            width = 0.5)\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\",\n                            width = 0.5,\n                            hjust = 0.5)\n\np <- p1 / p2\np\n# Use text or labels for the nodes.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\")\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            use_labels = TRUE,\n                            text_color = \"white\")\n\np <- p1 / p2\np"},{"path":"sankey-and-alluvial-plots.html","id":"increase-the-gap-between-the-nodes","chapter":"11 Sankey and alluvial plots","heading":"11.4 Increase the gap between the nodes","text":"One can also increase gaps nodes. done providing number space. number act “invisible” cells nodes. one needs think terms many cells dataset. bigger dataset, higher number need notice difference. set default 5% total number cells dataset.\nFigure 1.7: Sankey plots modified spaces nodes.\n","code":"\n# Modify the space between nodes.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            space =  1000)\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            space = 5000)\n\np <- p1 / p2\np"},{"path":"sankey-and-alluvial-plots.html","id":"modify-default-colors","chapter":"11 Sankey and alluvial plots","heading":"11.5 Modify default colors","text":"Finally, can modify default colors providing colors.first, colors.middle colors.last. named vector \nFigure 1.8: Sankey plots modified default colors.\n","code":"\n# Modify default colors.\ncolors.first <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                                        n = length(unique(sample$sub.cluster)))\nnames(colors.first) <- unique(sample$sub.cluster)\n\np <- SCpubr::do_SankeyPlot(sample = sample,\n                           first_group = \"sub.cluster\",\n                           middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                           last_group = \"orig.ident\",\n                           type = \"sankey\",\n                           colors.first = )\np"},{"path":"chord-diagram-plots.html","id":"chord-diagram-plots","chapter":"12 Chord Diagram plots","heading":"12 Chord Diagram plots","text":"Chord Diagram plots pretty much type visualization Sankey Alluvial plots, twist nodes located forming circle, therefore links resembling chords. type visualizations can achieved using package.","code":""},{"path":"chord-diagram-plots.html","id":"basic-usage-9","chapter":"12 Chord Diagram plots","heading":"12.1 Basic usage","text":"looks:\nBasic Chord Diagram.\n","code":"\n# Basic chord diagram.\nsample$assignment <- ifelse(sample$seurat_clusters %in% c(\"0\", \"4\", \"7\"), \"A\", \"B\")\nsample$assignment[sample$seurat_clusters %in% c(\"1\", \"2\")] <- \"C\"\nsample$assignment[sample$seurat_clusters %in% c(\"10\", \"5\")] <- \"D\"\nsample$assignment[sample$seurat_clusters %in% c(\"8\", \"9\")] <- \"E\"\n\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\")\n\np"},{"path":"chord-diagram-plots.html","id":"control-the-gaps-between-and-within-groups","chapter":"12 Chord Diagram plots","heading":"12.2 Control the gaps between and within groups","text":"can modify gaps , provided many elements can accomplished. , use big_gap:\nChord Diagram increased big gap.\nSimilarly, can also modify gaps groups inside small_gap:\nChord Diagram increased small gap.\n","code":"\n# Increase gap between from and to groups.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 big.gap = 40)\n\np\n# Increase gap width groups in from and to.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 small.gap = 5)\n\np"},{"path":"chord-diagram-plots.html","id":"control-the-alignment-of-the-diagram","chapter":"12 Chord Diagram plots","heading":"12.3 Control the alignment of the diagram","text":"can force alignment starting poing Chord diagram using alignment parameter:\nChord Diagram starting horizontally.\n\nChord Diagram starting vertically.\n","code":"\n# Control the alignment of the diagram.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 alignment = \"horizontal\")\n\np\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 alignment = \"vertical\")\n\np"},{"path":"chord-diagram-plots.html","id":"control-the-directions-of-the-links","chapter":"12 Chord Diagram plots","heading":"12.4 Control the directions of the links","text":"Also, can define direction interaction providing different values directional:\n- 0: links direction.\n- 1: links go .\n- -1: links go .\n- 2: links bidrectional.\nChord Diagram links without direction.\n\nChord Diagram links going “” “”.\n\nChord Diagram links going “” “”.\n\nChord Diagram links going directions.\n","code":"\n# We need to set direction.type to diffHeight only as arrows are, by nature, directional.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 directional = 0,\n                                 direction.type = \"diffHeight\")\n\np\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 directional = 1)\n\np\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 directional = -1)\n\np\n# We need to set direction.type to diffHeight only as arrows are, by nature, directional.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 directional = 2,\n                                 direction.type = \"diffHeight\")\n\np"},{"path":"chord-diagram-plots.html","id":"add-padding-to-the-labels","chapter":"12 Chord Diagram plots","heading":"12.5 Add padding to the labels","text":"One can add padding labels using padding_labels. number provided amount whitespaces padding label.\nChord Diagram extra padding.\n","code":"\n# Add more padding to the labels.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 padding_labels = 8)\n\np"},{"path":"chord-diagram-plots.html","id":"scale-the-nodes","chapter":"12 Chord Diagram plots","heading":"12.6 Scale the nodes","text":"want show nodes equal size, links reflecting proportion instead, can set scale = TRUE.\nChord Diagram scaled nodes.\n","code":"\n# Scale the size of the nodes.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 scale = TRUE,\n                                 padding_labels = 8)\n\np"},{"path":"chord-diagram-plots.html","id":"self-linking","chapter":"12 Chord Diagram plots","heading":"12.7 Self linking","text":"can also control whether want allow self linking nodes . , can set self.link = 2 allow self.link = 1 prevent .\nChord Diagram prevented self linking.\n\nChord Diagram allowed self linking.\n","code":"\n# Prevent self linking.\nsample$seurat_clusters2 <- sample$seurat_clusters\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"seurat_clusters2\",\n                                 self.link = 1,\n                                 scale = TRUE)\n\np\n# Allow self linking.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"seurat_clusters2\",\n                                 self.link = 2,\n                                 scale = TRUE)\n\np"},{"path":"chord-diagram-plots.html","id":"control-the-appearance-of-the-arrows","chapter":"12 Chord Diagram plots","heading":"12.8 Control the appearance of the arrows","text":"arrows can modified using link.arr.type parameter:\nChord Diagram triangle arrows.\n\nChord Diagram big arrows.\n","code":"\n# Set triangle arrows.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 link.arr.type = \"triangle\")\n\np\n# Set big arrows.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 link.arr.type = \"big.arrow\")\n\np"},{"path":"volcano-plots.html","id":"volcano-plots","chapter":"13 Volcano plots","heading":"13 Volcano plots","text":"Perhaps one known type plots bulk transcriptomics. computing DE genes across two conditions, results can plotted volcano plot. plot features genes dots, places scatter plot X axis contains degree gene differentially expressed (average log2(FC)), Y axis shows significant gene (-log10(p-value adjusted)).","code":""},{"path":"volcano-plots.html","id":"basic-usage-10","chapter":"13 Volcano plots","heading":"13.1 Basic usage","text":"generate plot, one can use SCpubr::do_VolcanoPlot(), needs input Seurat object result running Seurat::FindMarkers() choosing two groups.\nFigure 1.1: SCpubr::do_VolcanoPlot default parameters.\ncan see, four major groups genes:\n- Genes surpass p-value logFC cutoffs (blue).\n- Genes surpass p-value cutoff logFC cutoff (orange).\n- Genes surpass logFC cutoff p-value cutoff (purple, shown).\n- Genes surpass cutoff (green).","code":"\n# Generate a volcano plot.\np <- SCpubr::do_VolcanoPlot(sample = sample,\n                            de_genes = de_genes)\np"},{"path":"volcano-plots.html","id":"modify-the-cutoffss","chapter":"13 Volcano plots","heading":"13.2 Modify the cutoffss","text":"cutofss can set user using pval_cutoff (without -log10 transforming) FC_cutoff (avg log2(FC)).\nFigure 1.2: SCpubr::do_VolcanoPlot modifying cutoffs.\n","code":"\n# Modify cutoffs.\np <- SCpubr::do_VolcanoPlot(sample = sample,\n                            de_genes = de_genes,\n                            pval_cutoff = 1e-15,\n                            FC_cutoff = 0.2)\np"},{"path":"volcano-plots.html","id":"modify-the-gene-tags","chapter":"13 Volcano plots","heading":"13.3 Modify the gene tags","text":"default, top 5 genes side, ordered -log10(p-value adjusted) average log2(FC) reported. However, one can increase number using\nFigure 1.3: SCpubr::do_VolcanoPlot modifying number gene tags.\n","code":"\n# Modify number of gene tags.\np <- SCpubr::do_VolcanoPlot(sample = sample,\n                            de_genes = de_genes,\n                            n_genes = 15)\np"},{"path":"group-wise-de-analysis-plots.html","id":"group-wise-de-analysis-plots","chapter":"14 Group-wise DE analysis plots","heading":"14 Group-wise DE analysis plots","text":"common analysis can performed SC data group-wise DE analysis. , example, want compute differentially expressed (DE) genes cell clusters vs rest clusters. yields data frame DE genes comparisons, can use visualization purposes, heatmaps. process implemented SCpubr::do_GroupwiseDEPlot(). , need provide function Seurat object output following command:basic output function:\nFigure 1.2: SCpubr do_GroupwiseDEPlot default output.\ndefault, computes three different heatmaps, showing top 5 DE genes clusters groups computed DE genes, respective adjusted p-values (- log10), fold change (FC, log2) mean expression groups. Genes ordered based order groups. Therefore, heatmaps hierarchical clustering neither rows columns.","code":"\n# Seurat sample.\nsample <- your_seurat_object\n\n# Set the identities correctly.\nSeurat::Idents(sample) <- sample$seurat_clusters\n\n# Compute DE genes and transform to a tibble.\nde_genes <- tibble::tibble(Seurat::FindAllMarkers(object = sample))\n# Default output.\np <- SCpubr::do_GroupwiseDEPlot(sample = sample,\n                                de_genes = de_genes)\n\np"},{"path":"group-wise-de-analysis-plots.html","id":"increase-the-number-of-genes","chapter":"14 Group-wise DE analysis plots","heading":"14.1 Increase the number of genes","text":"number top DE genes cluster can increased reduced using top_genes.\nFigure 1.3: SCpubr do_GroupwiseDEPlot increasing number DE genes cluster.\n","code":"\n# Increase the number of top DE genes by cluster.\np <- SCpubr::do_GroupwiseDEPlot(sample = sample,\n                                de_genes = de_genes,\n                                top_genes = 10)\n\np"},{"path":"group-wise-de-analysis-plots.html","id":"modify-the-titles-of-the-rows-and-columns","chapter":"14 Group-wise DE analysis plots","heading":"14.2 Modify the titles of the rows and columns","text":"can also modify row titles heatmap bodies row_title_p_values, row_title_expression row_title_logfc column titles column_title angle rotation row titles \nFigure 1.4: SCpubr do_GroupwiseDEPlot modified row column titles.\n","code":"\n# Modify the row and column titles and the rotation.\np <- SCpubr::do_GroupwiseDEPlot(sample = sample,\n                                de_genes = de_genes,\n                                column_title = \"Title A\",\n                                row_title_p_values = \"Title B\",\n                                row_title_logfc = \"Title C\",\n                                row_title_expression = \"Title D\",\n                                row_title_rot = 0)\n\np"},{"path":"group-wise-de-analysis-plots.html","id":"add-further-layers-of-mean-expression","chapter":"14 Group-wise DE analysis plots","heading":"14.3 Add further layers of mean expression","text":"One can add groupings heatmap mean expression values making use group.parameter, set seurat_clusters default. surely groups different ones DE genes computed , need provide many row titles new heatmaps values group., even empty characters.\nFigure 1.5: SCpubr do_GroupwiseDEPlot multiple layers mean expression.\ncan useful different groupings want inspect time. Also, color scale shared expression heatmaps.","code":"\nsample$modified_orig.ident <- sample(x = c(\"Sample_A\", \"Sample_B\", \"Sample_C\"), \n                                     size = ncol(sample), \n                                     replace = T, \n                                     prob = c(0.2, 0.7, 0.1))\n\n# Add more layers of mean expression with group.by.\np <- SCpubr::do_GroupwiseDEPlot(sample = sample,\n                                de_genes = de_genes,\n                                group.by = c(\"seurat_clusters\", \n                                             \"modified_orig.ident\", \n                                             \"orig.ident\"),\n                                row_title_expression = c(\"\",\n                                                         \"Title A\",\n                                                         \"Title B\"))\n\np"},{"path":"group-wise-de-analysis-plots.html","id":"modify-color-scales","chapter":"14 Group-wise DE analysis plots","heading":"14.4 Modify color scales","text":"can modify color scales three main types heatmaps viridis_map_pvalues, viridis_map_logfc viridis_map_expression, providing letter corresponding color scale.\nFigure 1.6: SCpubr do_GroupwiseDEPlot viridis scales.\n","code":"\n# Change the viridis scales.\np <- SCpubr::do_GroupwiseDEPlot(sample = sample,\n                                de_genes = de_genes,\n                                viridis_map_pvalues = \"C\",\n                                viridis_map_logfc = \"E\",\n                                viridis_map_expression = \"D\")\n\np"},{"path":"term-enrichment-plots.html","id":"term-enrichment-plots","chapter":"15 Term Enrichment Plots","heading":"15 Term Enrichment Plots","text":"One key downstream analysis Single Cell analysis revolves list candidate genes (.e: DE genes) one wants know whether genes enriched specific biological function, pathway cell type. can easily done using enrichR package, R interface website, Enrichr. package allows query list genes 100 databases retrieve terms enriched list genes, together adjusted p-value. process, together data processing visualization comprised SCpubr::do_TermEnrichmentPlot().First , enrichR allows select site query results . can provided site parameter can one following:\n- Enrichr.\n- FlyEnrichr.\n- WormEnrichr.\n- YeastEnrichr.\n- FishEnrichr., also need specify databases query . complete list databases can consulted using:databases use need provided character vector dbs_use parameter. However, one can also provide one following pre-defined options:“”: perform query 4 databases cell types (Azimuth, Descartes, PanglaoDB Descartes) 4 databases functional terms (MsigDB, GO-BP, GO-MF KEGG). default option parameter provided.“B”: Performs query cell type databases (Azimuth, Descartes, PanglaoDB Descartes).“C”: Performs query functional terms (MsigDB, GO-BP, GO-MF KEGG).previous option return list plots. plots can, , assembled together.\nFigure 1.1: SCpubr do_TermEnrichmentPlot use case.\n","code":"\ndbs <- sort(enrichR::listEnrichrDbs()[, 'libraryName'])\n# Genes related to breast cancer.\ngenes <- c(\"ABCB1\", \"ABCG2\", \"AHR\", \"AKT1\", \"AR\")\np <- SCpubr::do_TermEnrichmentPlot(genes = genes,\n                                   dbs_use = \"C\")\npatchwork::wrap_plots(p, ncol = 1)"},{"path":"term-enrichment-plots.html","id":"modifying-the-number-of-terms-to-retrieve.","chapter":"15 Term Enrichment Plots","heading":"15.1 Modifying the number of terms to retrieve.","text":"Depending focus analysis, might want focus one database retrieve terms . can achieved using nterms parameter.\nFigure 1.2: SCpubr do_TermEnrichmentPlot increased terms.\n","code":"\n# Genes related to breast cancer.\ngenes <- c(\"ABCB1\", \"ABCG2\", \"AHR\", \"AKT1\", \"AR\")\np <- SCpubr::do_TermEnrichmentPlot(genes = genes,\n                                   dbs_use = \"GO_Biological_Process_2021\",\n                                   nterms = 15)\np"},{"path":"term-enrichment-plots.html","id":"modifying-the-length-of-the-terms","chapter":"15 Term Enrichment Plots","heading":"15.2 Modifying the length of the terms","text":"Another issue plots , normally, term takes much space. , terms wrapped according cutoff defined nchar_wrap parameter. term characters value provided, split less half, always preserving whole words.\nFigure 1.3: SCpubr do_TermEnrichmentPlot reduced term length.\nway, one can enhance limit order term just one row.","code":"\n# Genes related to breast cancer.\ngenes <- c(\"ABCB1\", \"ABCG2\", \"AHR\", \"AKT1\", \"AR\")\np1 <- SCpubr::do_TermEnrichmentPlot(genes = genes,\n                                    dbs_use = \"GO_Biological_Process_2021\",\n                                    nterms = 15)\np2 <- SCpubr::do_TermEnrichmentPlot(genes = genes,\n                                    dbs_use = \"GO_Biological_Process_2021\",\n                                    nterms = 15,\n                                    nchar_wrap = 30)\np <- p1 / p2\np"},{"path":"term-enrichment-plots.html","id":"increase-the-font-size-of-the-labels","chapter":"15 Term Enrichment Plots","heading":"15.3 Increase the font size of the labels","text":"want increase font size labels - , anything part legend titles, use text_labels_size parameter:\nFigure 1.4: SCpubr do_TermEnrichmentPlot modified fontsize\n","code":"\n# Genes related to breast cancer.\ngenes <- c(\"ABCB1\", \"ABCG2\", \"AHR\", \"AKT1\", \"AR\")\np1 <- SCpubr::do_TermEnrichmentPlot(genes = genes,\n                                   dbs_use = \"GO_Biological_Process_2021\")\np2 <- SCpubr::do_TermEnrichmentPlot(genes = genes,\n                                   text_labels_size = 6,\n                                   dbs_use = \"GO_Biological_Process_2021\")\n\np <- p1 / p2\np"},{"path":"enrichment-score-heatmaps.html","id":"enrichment-score-heatmaps","chapter":"16 Enrichment score heatmaps","heading":"16 Enrichment score heatmaps","text":"common approach make sense cells query several list marker genes, retrieved literature, compute enriched cell given list genes. achieved using Seurat::AddModuleScore. scores can visualized Feature plot, one can also aggregate enrichment scores variable interest, instance different clusters sample.kind heatmaps can easily computed using SCpubr::do_EnrichmentHeatmap():","code":""},{"path":"enrichment-score-heatmaps.html","id":"single-grouping-variable","chapter":"16 Enrichment score heatmaps","heading":"16.1 Single grouping variable","text":"\nFigure 1.1: SCpubr::do_EnrichmentHeatmap default parameters.\ndefault, SCpubr::do_EnrichmentHeatmap aggregates values current identity. However, metadata variables can used aggregate . , provide name group.parameter.\nFigure 1.2: SCpubr::do_EnrichmentHeatmap custom aggregation.\nmatrix can transposed using transpose = TRUE.\nFigure 1.3: SCpubr::do_EnrichmentHeatmap transposed matrix.\nrows column names can rotated using column_names_rot row_names_rot parameters, providing desired angle.\nFigure 1.4: SCpubr::do_EnrichmentHeatmap transposed matrix different angle column names.\n","code":"\n# Define list of genes.\ngenes <- list(\"Naive CD4+ T\" = c(\"IL7R\", \"CCR7\"),\n              \"CD14+ Mono\" = c(\"CD14\", \"LYZ\"),\n              \"Memory CD4+\" = c(\"S100A4\"),\n              \"B\" = c(\"MS4A1\"),\n              \"CD8+ T\" = c(\"CD8A\"),\n              \"FCGR3A+ Mono\" = c(\"FCGR3A\", \"MS4A7\"),\n              \"NK\" = c(\"GNLY\", \"NKG7\"),\n              \"DC\" = c(\"FCER1A\", \"CST3\"),\n              \"Platelet\" = c(\"PPBP\"))\n\n# Default parameters.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes)\np\n# Custom aggregated values.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  group.by = \"orig.ident\")\np\n# Transposing the matrix.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  transpose = TRUE)\np\n# Rotating the labels.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  transpose = TRUE,\n                                  column_names_rot = 0)\np"},{"path":"enrichment-score-heatmaps.html","id":"changing-the-cell-size-in-the-heatmap.","chapter":"16 Enrichment score heatmaps","heading":"16.2 Changing the cell size in the heatmap.","text":"design, aspect ratio tiles heatmap fixed cells squares, rectangles. However, user possibility increase/decrease cell size tile modifying cell_size parameter. set 5 default.\nFigure 1.5: SCpubr::do_EnrichmentHeatmap transposed matrix using split.changing tile size.\n","code":"\n# Modifying the tile size.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  transpose = TRUE,\n                                  column_names_rot = 0,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  cell_size = 7)\np"},{"path":"enrichment-score-heatmaps.html","id":"symmetrical-scales","chapter":"16 Enrichment score heatmaps","heading":"16.3 Symmetrical scales","text":"one wants symmetrical scale,\nFigure 1.6: SCpubr::do_EnrichmentHeatmap symmetrical scale.\n\nFigure 1.7: SCpubr::do_EnrichmentHeatmap symmetrical scale.\n","code":"\n# Symmetrical scale viriis.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  transpose = TRUE,\n                                  column_names_rot = 0,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  cell_size = 7,\n                                  symmetrical_scale = TRUE)\np\n# Modifying the symmetrical scale non viridis.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  transpose = TRUE,\n                                  column_names_rot = 0,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  cell_size = 7,\n                                  symmetrical_scale = TRUE,\n                                  use_viridis = FALSE)\np"},{"path":"correlation-matrix-heatmaps.html","id":"correlation-matrix-heatmaps","chapter":"17 Correlation matrix heatmaps","heading":"17 Correlation matrix heatmaps","text":"common analysis perform single cell data assess much different subsets data correlated . , correlation matrices used, typically displayed heatmaps. implemented SCpubr::do_CorrelationPlot(). Right now, works single use case: computing correlation matrix highly variable genes desired groups. use cases implemented future.","code":""},{"path":"correlation-matrix-heatmaps.html","id":"using-highly-variable-genes","chapter":"17 Correlation matrix heatmaps","heading":"17.1 Using Highly Variable Genes","text":"\nFigure 1.1: SCpubr::do_CorrelationPlot default parameters.\ndefault, computes correlation current identities object. can changed providing another metadata variable group..\nFigure 1.2: SCpubr::do_CorrelationPlot custom grouping.\nAxes labels can also rotated.\nFigure 1.3: SCpubr::do_CorrelationPlot rotated axis labels.\n","code":"\n# Default values.\np <- SCpubr::do_CorrelationPlot(sample = sample)\np\n# Custom grouping.\nsample$custom_group <- ifelse(sample$seurat_clusters %in% c(\"1\", \"3\", \"5\", \"7\", \"9\"), \"Group A\", \"Group B\")\np <- SCpubr::do_CorrelationPlot(sample = sample, group.by = \"custom_group\", cell_size = 10)\np\n# Rotated axis labels.\np <- SCpubr::do_CorrelationPlot(sample = sample,\n                                column_names_rot = 90)\np"},{"path":"correlation-matrix-heatmaps.html","id":"changing-the-cell-size-in-the-heatmap","chapter":"17 Correlation matrix heatmaps","heading":"17.2 Changing the cell size in the heatmap","text":"Enrichment Heatmaps, aspect ratio tiles heatmap fixed cells squares, rectangles. can changed modifying cell_size parameter. set 5 default.\nFigure 1.4: SCpubr::do_CorrelationPlot rotated axis labels.\n","code":"\n# Increase cell size.\np <- SCpubr::do_CorrelationPlot(sample = sample,\n                                column_names_rot = 0,\n                                cell_size = 7)\np"},{"path":"cellular-state-plots.html","id":"cellular-state-plots","chapter":"18 Cellular State Plots","heading":"18 Cellular State Plots","text":"plots , bare basis, scatter plots. today, completely sure correct name plot, follow name provided plot Neftel, et al, 2019. core concept function computing plots, SCpubr::do_CellularStatesPlot() need Seurat object named list gene signatures. , function compute enrichment scores using Seurat::AddModuleScore() store metadata object, use plotting later . , alongside list gene signatures, user needs provide names lists plotted arguments.","code":"\ngene_set <- list(\"A\" = Seurat::VariableFeatures(sample)[1:10],\n                 \"B\" = Seurat::VariableFeatures(sample)[11:20],\n                 \"C\" = Seurat::VariableFeatures(sample)[21:30],\n                 \"D\" = Seurat::VariableFeatures(sample)[31:40])"},{"path":"cellular-state-plots.html","id":"variable-plots","chapter":"18 Cellular State Plots","heading":"18.1 2 variable plots","text":"easiest case. , user needs provide name two gene signatures present list genes provided input_gene_list parameter:\n- x1: enrichment scores computed list displayed X axis.\n- y1: enrichment scores computed list displayed Y axis.\nFigure 1.2: SCpubr::do_CellularStatesPlot, 2 variables\nway, can see much effect gene set regards gene set B. One can enforce symmetry plot enforce_symmetry = TRUE.\nFigure 1.3: SCpubr::do_CellularStatesPlot, 2 variables symmetry enforced\n","code":"\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"B\")\np\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"B\",\n                                   enforce_symmetry = TRUE)\np"},{"path":"cellular-state-plots.html","id":"variables","chapter":"18 Cellular State Plots","heading":"18.2 3 variables","text":"plot retrieved Tirosh, et al, 2016 plot requires user provide three gene sets, enrichment scores computed using Seurat::AddModuleScore. X axis, two gene sets assigned . Cells placed towards right enriched x1 towards left enriched x2. decided , first, retrieving enrichment scores lists keeping highest two. score turn positive negative depending gene list highest enrichment score belonged : positive x1 negative x2. Y axis. one gene set provided. value Y axis computed subtracting enrichment scores y1 value X axis.plot makes lot sense, showcased Tirosh, et al, 2016, Y axis shows differentiation trajectory. , contains enrichment scores stemness genes. Therefore, lower Y axis, less stem given cell . X axis, cells order depending whether enriched x1 x2. extreme value X axis, differentiated towards given list genes cell .\nFigure 1.4: SCpubr::do_CellularStatesPlot, 3 variables\nenforce_symmetry set true, X axis 0 middle point.\nFigure 1.5: SCpubr::do_CellularStatesPlot, 3 variables symmetry enforced\n","code":"\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"B\",\n                                   x2 = \"C\")\np\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"B\",\n                                   x2 = \"C\",\n                                   enforce_symmetry = TRUE)\np"},{"path":"cellular-state-plots.html","id":"variables-1","chapter":"18 Cellular State Plots","heading":"18.3 4 variables","text":"complicated variant plot, retrieved Neftel, et al, 2019. makes use four gene sets: x1, x2, y1 y2. general, brief description, enrichment scores computed 4 gene sets cells locate resulting figure according list enriched , towards given corner, following scheme shown .achieved assuming:\n- x1 x2 connected, y1 y2. first step decide highest score x1-x2 y1-y2, locate cells either upper lower half (Y axis).\n- , X axis, depending whether score Y axis positive negative, values computed log2 logarithm absolute difference enrichment scores plus 1: log2(abs((x1 y1) - (x2 y2)) + 1). resulting value positive negative depending whether score x1 y1 higher lower score x2 y2.\nFigure 1.6: SCpubr::do_CellularStatesPlot, 4 variables\nenforce_symmetry set true, plot completely squared.\nFigure 1.7: SCpubr::do_CellularStatesPlot, 4 variables symmetry enforced\n","code":"\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"C\",\n                                   x2 = \"B\",\n                                   y2 = \"D\")\np\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"C\",\n                                   x2 = \"B\",\n                                   y2 = \"D\",\n                                   enforce_symmetry = TRUE)\np"},{"path":"cellular-state-plots.html","id":"continuous-features","chapter":"18 Cellular State Plots","heading":"18.4 Continuous features","text":"addition , one can also query resulting plot feature accepted regular SCpubr::do_FeaturePlot(). plots returned alongside original one. behavior achieved using plot_features = TRUE providing desired features features parameter.\nFigure 1.8: SCpubr::do_CellularStatesPlot, 4 variables symmetry enforced querying features\nFurthermore, original list genes queried can also plotted enrichment scores. can achieved plot_enrichment_scores = TRUE:\nFigure 1.9: SCpubr::do_CellularStatesPlot, 4 variables symmetry enforced querying enrichment scores original list genes\n","code":"\n# Plot continuous features.\nout <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                     input_gene_list = gene_set,\n                                     x1 = \"A\",\n                                     y1 = \"C\",\n                                     x2 = \"B\",\n                                     y2 = \"D\",\n                                     plot_cell_borders = TRUE,\n                                     enforce_symmetry = TRUE,\n                                     plot_features = TRUE,\n                                     features = c(\"PC_1\", \"nFeature_RNA\"))\np <- out$main | out$PC_1 | out$nFeature_RNA\np\n# Plot enrichment scores for the input gene lists.\nout <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                     input_gene_list = gene_set,\n                                     x1 = \"A\",\n                                     y1 = \"C\",\n                                     x2 = \"B\",\n                                     y2 = \"D\",\n                                     plot_cell_borders = TRUE,\n                                     enforce_symmetry = TRUE,\n                                     plot_enrichment_scores = TRUE)\nlayout <- \"AABC\n           AADE\"\np <- patchwork::wrap_plots(A = out$main,\n                           B = out$A,\n                           C = out$B,\n                           D = out$C,\n                           E = out$D,\n                           design = layout)\np"},{"path":"ligand-receptor-analysis.html","id":"ligand-receptor-analysis","chapter":"19 Ligand-Receptor analysis","heading":"19 Ligand-Receptor analysis","text":"One interesting analysis can carried Ligand-Receptor analysis. allows compute whether specific clusters interact based co-expression ligand receptor respective clusters. interactions retrieved different databases plethora tools released tackle analysis. One liana, framework allows run integrate results several tools, providing meta-analysis co-expression ligand-receptor pairs. SCpubr makes use liana analysis visualization integrated SCpubr::do_LigandReceptorPlot() function.","code":""},{"path":"ligand-receptor-analysis.html","id":"basic-usage-11","chapter":"19 Ligand-Receptor analysis","heading":"19.1 Basic usage","text":"default, user run liana provide resulting output input function. following code produces object SCpubr::do_LigandReceptorPlot() expects input:important note liana_output contain five different methods. design choice. output looks like:\nFigure 1.2: SCpubr do_LigandReceptorPlot default output.\n","code":"\nliana_output <- liana::liana_wrap(sce = sample,\n                                  method = c(\"natmi\", \"connectome\", \"logfc\", \"sca\", \"cellphonedb\"),\n                                  idents_col = NULL,\n                                  verbose = FALSE,\n                                  assay = \"SCT\")\n# Ligand Receptor analysis plot.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output)\np"},{"path":"ligand-receptor-analysis.html","id":"increase-the-top-significant-interactions-plotted","chapter":"19 Ligand-Receptor analysis","heading":"19.2 Increase the top significant interactions plotted","text":"default, top 25 unique, significant interactions retrieved plotted. However, can changed using top_interactions. Also, clusters interactions, source target, removed.:\nFigure 1.3: SCpubr do_LigandReceptorPlot default output extra interactions.\n","code":"\n# Ligand Receptor analysis plot with extra interactions.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   top_interactions = 50)\np"},{"path":"ligand-receptor-analysis.html","id":"add-or-remove-missing-source-target-combinations","chapter":"19 Ligand-Receptor analysis","heading":"19.3 Add or remove missing source-target combinations","text":"Depending value select top_interactions, might find specific source-target combinations interactions . show resulting dotplot empty columns. design choice, SCpubr brings combinations back NA values, thus making different panels dotplot easier read. However, small number interactions, might result empty dotplot. Also, many different sources, plot can also become long.cases like , might rather go relevant columns. can toggle /behaviour using ``:\nFigure 1.4: SCpubr do_LigandReceptorPlot without missing LR combinations.\n","code":"\n# Add missing LR combinations.\np1 <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                    add_missing_LR_combinations = TRUE)\n\n# Restrict the results to only the LR combinations that have a value.\np2 <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                    add_missing_LR_combinations = FALSE)\np <- p1 /p2\np"},{"path":"ligand-receptor-analysis.html","id":"modify-the-size-of-dots","chapter":"19 Ligand-Receptor analysis","heading":"19.4 Modify the size of dots","text":"Size dots can modified dot.size:\nFigure 1.5: SCpubr do_LigandReceptorPlot increased dot size.\n","code":"\n# Ligand Receptor analysis plot with increased dot size.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   dot.size = 2)\np"},{"path":"ligand-receptor-analysis.html","id":"toggle-grid-lines","chapter":"19 Ligand-Receptor analysis","heading":"19.5 Toggle grid lines","text":"One can also draw grid lines. specially useful plot gets big. can achieved using plot.grid = TRUE/FALSE. grid lines can controlled using grid.type color grid.color:\nFigure 1.6: SCpubr do_LigandReceptorPlot grid lines.\n","code":"\n# Ligand Receptor analysis plot with grid.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   grid.color = \"steelblue\")\np"},{"path":"ligand-receptor-analysis.html","id":"invert-axis","chapter":"19 Ligand-Receptor analysis","heading":"19.6 Invert axis","text":"cases one want plot lot interactions, plot can flipped flip = TRUE. X axis labels can rotated x_labels_angle, providing either 0, 45 90 degrees strip text can also rotated rotate_strip_text = TRUE.\nFigure 1.7: SCpubr do_LigandReceptorPlot inverted axes.\n","code":"\n# Ligand Receptor analysis plot with inverted axes.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   flip = TRUE, \n                                   x_labels_angle = 90,\n                                   rotate_strip_text = TRUE)\np"},{"path":"ligand-receptor-analysis.html","id":"split-the-plot-by-ligand-or-receptor-complex","chapter":"19 Ligand-Receptor analysis","heading":"19.7 Split the plot by ligand or receptor complex","text":"Furthermore, plot can also divided grouping interactions common ligand receptor complex. can achieved using split.parameter.:\nFigure 1.8: SCpubr do_LigandReceptorPlot split ligand.complex.\n\nFigure 1.9: SCpubr do_LigandReceptorPlot split receptor.complex.\n","code":"\n# Ligand Receptor analysis plot grouped by ligand.complex.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   plot.grid = TRUE,\n                                   grid.color = \"grey90\",\n                                   grid.type = \"dotted\",\n                                   x_labels_angle = 90,\n                                   rotate_strip_text = TRUE,\n                                   split.by = \"ligand.complex\")\np\n# Ligand Receptor analysis plot grouped by ligand.complex.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   split.by = \"receptor.complex\")\np"},{"path":"ligand-receptor-analysis.html","id":"restrict-the-plot-to-given-source-andor-targets","chapter":"19 Ligand-Receptor analysis","heading":"19.8 Restrict the plot to given source and/or targets","text":"Finally, one can also restrict output given source target clusters. can achieved provided desired identities keep_source keep_target:\nFigure 1.10: SCpubr do_LigandReceptorPlot filtered source targets.\n","code":"\n# Ligand Receptor analysis plot with inverted axes with filtered source and targets.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   flip = F, \n                                   keep_source = c(\"0\", \"3\", \"9\"),\n                                   keep_target = c(\"3\", \"4\", \"9\"))\np"},{"path":"ligand-receptor-analysis.html","id":"compute-chord-diagrams-of-the-interactions","chapter":"19 Ligand-Receptor analysis","heading":"19.9 Compute chord diagrams of the interactions","text":"Another supplementary visualizations one can results liana visualize:\n- total number significant interactions pair clusters.\n- number interactions top_interactions ligand-receptor pairs.can achieved providing compute_ChordDiagrams = TRUE. return list dot plot chord diagrams.However, plot can become quite messy. , becomes interesting use combination keep_source keep_target parameters:","code":"\n# Chord diagram of the total significant interactions from each cluster and all the rest.\nout <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                     top_interactions = 25,\n                                     compute_ChordDiagrams = TRUE)\nout$chord_total_interactions\n# Chord diagram of the total ligand-receptor interactions from each cluster and all the rest.\nout$chord_ligand_receptor\n# Chord diagram of the total significant interactions from each cluster and all the rest.\nout <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                     top_interactions = 25,\n                                     keep_source = c(\"0\", \"7\"),\n                                     compute_ChordDiagrams = TRUE)\nout$chord_total_interactions\n# Chord diagram of the total ligand-receptor interactions from each cluster and all the rest.\nout$chord_ligand_receptor"},{"path":"copy-number-variant-analysis-plots.html","id":"copy-number-variant-analysis-plots","chapter":"20 Copy Number Variant analysis plots","heading":"20 Copy Number Variant analysis plots","text":"Copy Number Variant analysis another common analysis one can compute single-cell transcriptomics data. Provided reference one can compute, rest cells, whether Copy Number Variations (CNVs) cells across chromosomes. comes really handy distinguish tumor healthy cells, provided one CNV reference event rely . many tools compute analysis, one highly used covered section inferCNV.InferCNV returns many outputs. interesting straightforward one final image, one :\n, can observe , different clusters, regions called chromosome gains colored red regions called chromosome losses colored blue. image, end, heatmap, meaning , output inferCNV, matrix scores cell gene, can make use . object called, default, run.final.infercnv_obj. one use.","code":""},{"path":"copy-number-variant-analysis-plots.html","id":"transferring-the-scores-to-a-featureplot","chapter":"20 Copy Number Variant analysis plots","heading":"20.1 Transferring the scores to a FeaturePlot","text":"One cool things can object, transfer inferCNV scores back Seurat object plot FeaturePlot. can achieved function SCpubr::do_CopyNumberVariantPlot(). function, one needs provide Seurat object final inferCNV object, together chromosome locations. metacells computed (necessary, used example), mapping cell-metacell provided well:\nFigure 1.1: SCpubr::do_CopyNumberVariantPlot FeaturePlot.\nScores 1 mean chromosome gain loss. Higher one mean gain lower mean loss. function automatically computes plots chromosome regions. want restrict output single chromosome, can stating chromosome_focus parameter.","code":"\n# This loads \"human_chr_locations\" into the environment.\nutils::data(\"human_chr_locations\", package = \"SCpubr\")\n\nout <- SCpubr::do_CopyNumberVariantPlot(sample = sample,\n                                        infercnv_object = infercnv_object,\n                                        using_metacells = T,\n                                        metacell_mapping = sample$metacell_mapping,\n                                        chromosome_locations = human_chr_locations)\np <- out$`11p_umap`\np\nout <- SCpubr::do_CopyNumberVariantPlot(sample = sample,\n                                        infercnv_object = infercnv_object,\n                                        using_metacells = T,\n                                        metacell_mapping = sample$metacell_mapping,\n                                        chromosome_locations = human_chr_locations,\n                                        chromosome_focus = \"11\")"},{"path":"copy-number-variant-analysis-plots.html","id":"plotting-the-scores-grouped-by-a-group-of-interest","chapter":"20 Copy Number Variant analysis plots","heading":"20.2 Plotting the scores grouped by a group of interest","text":"Sometimes, however, FeaturePlot sufficient get insights want scores. , output SCpubr::do_CopyNumberVariantPlot() also contains another set Geyser plots, showcase distribution scores per cells, grouped variable interest.\nFigure 1.3: SCpubr::do_CopyNumberVariantPlot dot plot.\n, can observe scores different groups, dot cells. Due overplotting, also report distribution data group center, dot median distribution, thicker lines representing 66% data thinner lines 95%. way, one can also see majority cells reside group. can also select variables group .\nFigure 1.4: SCpubr::do_CopyNumberVariantPlot dot plot.\n","code":"\nout <- SCpubr::do_CopyNumberVariantPlot(sample = sample,\n                                        infercnv_object = infercnv_object,\n                                        using_metacells = T,\n                                        metacell_mapping = sample$metacell_mapping,\n                                        chromosome_locations = human_chr_locations,\n                                        chromosome_focus = \"11\",\n                                        rotate_x_axis_labels = FALSE)\np <- out$`11p_geyser`\np\nsample$modified_orig.ident <- sample(x = c(\"Sample_A\", \"Sample_B\", \"Sample_C\"), \n                                     size = ncol(sample), \n                                     replace = T, \n                                     prob = c(0.2, 0.7, 0.1))\n\nout <- SCpubr::do_CopyNumberVariantPlot(sample = sample,\n                                        infercnv_object = infercnv_object,\n                                        using_metacells = T,\n                                        group.by = \"modified_orig.ident\",\n                                        metacell_mapping = sample$metacell_mapping,\n                                        chromosome_locations = human_chr_locations,\n                                        chromosome_focus = \"11\",\n                                        rotate_x_axis_labels = FALSE)\np <- out$`11p_geyser` + ggplot2::xlab(\"\")\np"},{"path":"copy-number-variant-analysis-plots.html","id":"joint-analysis","chapter":"20 Copy Number Variant analysis plots","heading":"20.3 Joint analysis","text":"ideal use case functions plot side side regular UMAP well:\nFigure 1.5: SCpubr::do_CopyNumberVariantPlot joint analysis.\nway, can see clusters UMAP, see scores also visualize distributions!","code":"\n\np1 <- SCpubr::do_DimPlot(sample = sample,\n                         plot_cell_borders = TRUE,\n                         border.size = 1.5,\n                         pt.size = 1)\nout <- SCpubr::do_CopyNumberVariantPlot(sample = sample,\n                                        infercnv_object = infercnv_object,\n                                        using_metacells = T,\n                                        metacell_mapping = sample$metacell_mapping,\n                                        chromosome_locations = human_chr_locations,\n                                        chromosome_focus = \"11\",\n                                        rotate_x_axis_labels = FALSE)\np2 <- out$`11p_umap`\np3 <- out$`11p_geyser` + ggplot2::xlab(\"\")\n\np <- (p1 | p2) / p3\np"},{"path":"pathway-activity-inference-analysis.html","id":"pathway-activity-inference-analysis","chapter":"21 Pathway Activity inference analysis","heading":"21 Pathway Activity inference analysis","text":"section highly similar TF Activity inference analysis makes use source package visualizations.Another important analysis can carried , cells defined groups (.e: cell clusters), Pathway Activity inference analysis. different tools perform task, one use called decoupleR (P.Badia--Mompel et al. 2022). tool allows inference biological activities Omics data. , requires dataset act prior knowledge. Pathway Activity inference, progeny used. allows computation activity scores cell basis depicting much (little) cell enriched cancer Pathways stored database.order visualize enrichment cells pathways, results need computed:, can proceed plot results SCpubr::do_PathwayActivityPlot().","code":"\n# Define your sample and assay.\nsample <- your_seurat_object\nassay <- \"your_normalized_data_assay\"\n\n# Retrieve prior knowledge network.\nnetwork <- decoupleR::get_progeny(organism = \"human\")\n\n# Run weighted means algorithm.\nactivities <- decoupleR::run_wmean(mat = as.matrix(sample@assays[[assay]]@data),\n                                   network = network,\n                                   .source = \"source\",\n                                   .targe = \"target\",\n                                   .mor = \"weight\",\n                                   times = 100,\n                                   minsize = 5)"},{"path":"pathway-activity-inference-analysis.html","id":"heatmap-of-averaged-scores","chapter":"21 Pathway Activity inference analysis","heading":"21.1 Heatmap of averaged scores","text":"informative , perhaps, straightforward approach visualize resulting scores averaged groups defined, heatmap. default output SCpubr::do_PathwayActivityPlot().\nFigure 1.2: SCpubr do_PathwayActivityPlot heatmap output.\n","code":"\n# General heatmap.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities)\np <- out$heatmaps$average_scores\np"},{"path":"pathway-activity-inference-analysis.html","id":"feature-plots-of-the-scores","chapter":"21 Pathway Activity inference analysis","heading":"21.2 Feature plots of the scores","text":"Perhaps interested visualizing scores Feature plot. way can observe trends enrichment activities. can achieved providing plot_FeaturePlots = TRUE.\nFigure 1.3: SCpubr do_PathwayActivityPlot feature plot output.\n","code":"\n# Retrieve feature plots.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_FeaturePlots = TRUE)\np1 <- SCpubr::do_DimPlot(sample)\np2 <- out$feature_plots$EGFR\np <- p1 | p2\np"},{"path":"pathway-activity-inference-analysis.html","id":"geyser-plots-of-the-scores","chapter":"21 Pathway Activity inference analysis","heading":"21.3 Geyser plots of the scores","text":"fashion feature plots, can also visualize scores Geyser plots, get sense distribution scores alongside groups. can achieved providing plot_GeyserPlots = TRUE.\nFigure 1.4: SCpubr do_PathwayActivityPlot geyser plot output.\n","code":"\n# Retrieve Geyser plots.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE)\np1 <- SCpubr::do_DimPlot(sample)\np2 <- out$geyser_plots$EGFR\np <- p1 | p2\np"},{"path":"pathway-activity-inference-analysis.html","id":"use-non-symmetrical-color-scales","chapter":"21 Pathway Activity inference analysis","heading":"21.4 Use non-symmetrical color scales","text":"one wants just plot continuous color scale Feature plots Geyser plots, can achieved using enforce_symmetry = FALSE.\nFigure 1.5: SCpubr do_PathwayActivityPlot non-symmetrical color scale.\n","code":"\n# Use non-symmetrical color scale.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE,\n                                      plot_FeaturePlots = TRUE,\n                                      enforce_symmetry = FALSE)\np1 <- out$feature_plots$EGFR\np2 <- out$geyser_plots$EGFR\n\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE,\n                                      plot_FeaturePlots = TRUE,\n                                      enforce_symmetry = TRUE)\np3 <- out$feature_plots$EGFR\np4 <- out$geyser_plots$EGFR\n\np <- (p1 | p2) / (p3 | p4)\np"},{"path":"pathway-activity-inference-analysis.html","id":"order-geysers-by-the-mean","chapter":"21 Pathway Activity inference analysis","heading":"21.5 Order geysers by the mean","text":"can also decide order Geyser plots mean values. can providing geyser_order_by_mean = FALSE.\nFigure 1.6: SCpubr do_PathwayActivityPlot ordering mean values.\n","code":"\n# Not order Geyser plot by mean values.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE,\n                                      enforce_symmetry = TRUE,\n                                      geyser_order_by_mean = FALSE)\np1 <- out$geyser_plots$EGFR\n\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE,\n                                      enforce_symmetry = TRUE,\n                                      geyser_order_by_mean = TRUE)\np2 <- out$geyser_plots$EGFR\n\np <- p1 | p2\np"},{"path":"pathway-activity-inference-analysis.html","id":"plot-another-variable-in-the-geyser-plots","chapter":"21 Pathway Activity inference analysis","heading":"21.6 Plot another variable in the geyser plots","text":"Furthermore, can also recolor Geyser plots based another variable choice. can achieve using geyser_color.geyser_scale_type, providing name variable plot type (continuous, categorical).\nFigure 1.7: SCpubr do_PathwayActivityPlot using color..\n","code":"\n# Plot a third variable in Geyser plots.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE,\n                                      geyser_color.by = \"seurat_clusters\",\n                                      geyser_scale_type = \"categorical\")\np1 <- out$geyser_plots$EGFR\n\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE,\n                                      geyser_color.by = \"nCount_RNA\",\n                                      geyser_scale_type = \"continuous\")\np2 <- out$geyser_plots$EGFR\n\np <- p1 | p2\np"},{"path":"pathway-activity-inference-analysis.html","id":"split-the-heatmap-into-different-groups","chapter":"21 Pathway Activity inference analysis","heading":"21.7 Split the heatmap into different groups","text":"can also divide heatmap groups. can achieved using split.parameter.\nFigure 1.8: SCpubr do_PathwayActivityPlot splitting heatmap.\n","code":"\n# Split the heatmap by another variable.\nsample$split.me <- ifelse(sample$seurat_clusters %in% c(\"0\", \"3\", \"7\"), \"Group A\",\"Group B\")\n\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      split.by = \"split.me\")\np <- out$heatmaps$average_scores\np"},{"path":"tf-activity-inference-analysis.html","id":"tf-activity-inference-analysis","chapter":"22 TF Activity inference analysis","heading":"22 TF Activity inference analysis","text":"section highly similar Pathway Activity inference analysis makes use source package visualizations.Transcriptional Factor (TF) Activity inference analysis can also carried SC dataset. previous chapter, use decoupleR (P.Badia--Mompel et al. 2022). , dorothea used. allows computation activity scores cell basis depicting much (little) cell enriched TF dowstream targets (regulon).order visualize enrichment cells pathways, results need computed:, can proceed plot results SCpubr::do_TFActivityPlot().","code":"\n# Define your sample and assay.\nsample <- your_seurat_object\nassay <- \"your_normalized_data_assay\"\n\n# Retrieve prior knowledge network.\nnetwork <- decoupleR::get_dorothea(organism = \"human\",\n                                   levels = c(\"A\", \"B\", \"C\"))\n\n# Run weighted means algorithm.\nactivities <- decoupleR::run_wmean(mat = as.matrix(sample@assays[[assay]]@data),\n                                   network = network,\n                                   .source = \"source\",\n                                   .targe = \"target\",\n                                   .mor = \"mor\",\n                                   times = 100,\n                                   minsize = 5)"},{"path":"tf-activity-inference-analysis.html","id":"heatmap-of-averaged-scores-1","chapter":"22 TF Activity inference analysis","heading":"22.1 Heatmap of averaged scores","text":"informative , perhaps, straightforward approach visualize resulting scores averaged groups defined, heatmap. default output SCpubr::do_TFActivityPlot().\nFigure 1.2: SCpubr do_TFActivityPlot heatmap output.\n","code":"\n# General heatmap.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities)\np <- out$heatmaps$average_scores\np"},{"path":"tf-activity-inference-analysis.html","id":"select-the-number-of-top-tfs-to-plot","chapter":"22 TF Activity inference analysis","heading":"22.2 Select the number of top TFs to plot","text":"can select number TFs include analysis using n_tfs variable.\nFigure 1.3: SCpubr do_TFActivityPlot heatmap output increased TFs.\n","code":"\n# Increase number of TFs included in the analysis.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 n_tfs = 40)\np <- out$heatmaps$average_scores\np"},{"path":"tf-activity-inference-analysis.html","id":"feature-plots-of-the-scores-1","chapter":"22 TF Activity inference analysis","heading":"22.3 Feature plots of the scores","text":"Perhaps interested visualizing scores Feature plot. way can observe trends enrichment activities. can achieved providing plot_FeaturePlots = TRUE.\nFigure 1.4: SCpubr do_TFActivityPlot feature plot output.\n","code":"\n# Retrieve feature plots.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_FeaturePlots = TRUE)\np1 <- SCpubr::do_DimPlot(sample)\np2 <- out$feature_plots$GLI2\np <- p1 | p2\np"},{"path":"tf-activity-inference-analysis.html","id":"geyser-plots-of-the-scores-1","chapter":"22 TF Activity inference analysis","heading":"22.4 Geyser plots of the scores","text":"fashion feature plots, can also visualize scores Geyser plots, get sense distribution scores alongside groups. can achieved providing plot_GeyserPlots = TRUE.\nFigure 1.5: SCpubr do_TFActivityPlot geyser plot output.\n","code":"\n# Retrieve Geyser plots.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE)\np1 <- SCpubr::do_DimPlot(sample)\np2 <- out$geyser_plots$GLI2\np <- p1 | p2\np"},{"path":"tf-activity-inference-analysis.html","id":"use-non-symmetrical-color-scales-1","chapter":"22 TF Activity inference analysis","heading":"22.5 Use non-symmetrical color scales","text":"one wants just plot continuous color scale Feature plots Geyser plots, can achieved using enforce_symmetry = FALSE.\nFigure 1.6: SCpubr do_TFActivityPlot non-symmetrical color scale.\n","code":"\n# Use non-symmetrical color scale.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE,\n                                 plot_FeaturePlots = TRUE,\n                                 enforce_symmetry = FALSE)\np1 <- out$feature_plots$GLI2\np2 <- out$geyser_plots$GLI2\n\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE,\n                                 plot_FeaturePlots = TRUE,\n                                 enforce_symmetry = TRUE)\np3 <- out$feature_plots$GLI2\np4 <- out$geyser_plots$GLI2\n\np <- (p1 | p2) / (p3 | p4)\np"},{"path":"tf-activity-inference-analysis.html","id":"order-geysers-by-the-mean-1","chapter":"22 TF Activity inference analysis","heading":"22.6 Order geysers by the mean","text":"can also decide order Geyser plots mean values. can providing geyser_order_by_mean = FALSE.\nFigure 1.7: SCpubr do_TFActivityPlot ordering mean values.\n","code":"\n# Not order Geyser plot by mean values.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE,\n                                 enforce_symmetry = TRUE,\n                                 geyser_order_by_mean = FALSE)\np1 <- out$geyser_plots$GLI2\n\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE,\n                                 enforce_symmetry = TRUE,\n                                 geyser_order_by_mean = TRUE)\np2 <- out$geyser_plots$GLI2\n\np <- p1 | p2\np"},{"path":"tf-activity-inference-analysis.html","id":"plot-another-variable-in-the-geyser-plots-1","chapter":"22 TF Activity inference analysis","heading":"22.7 Plot another variable in the geyser plots","text":"Furthermore, can also recolor Geyser plots based another variable choice. can achieve using geyser_color.geyser_scale_type, providing name variable plot type (continuous, categorical).\nFigure 1.8: SCpubr do_TFActivityPlot using color..\n","code":"\n# Plot a third variable in Geyser plots.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE,\n                                 geyser_color.by = \"seurat_clusters\",\n                                 geyser_scale_type = \"categorical\")\np1 <- out$geyser_plots$GLI2\n\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE,\n                                 geyser_color.by = \"nCount_RNA\",\n                                 geyser_scale_type = \"continuous\")\np2 <- out$geyser_plots$GLI2\n\np <- p1 | p2\np"},{"path":"tf-activity-inference-analysis.html","id":"split-the-heatmap-into-different-groups-1","chapter":"22 TF Activity inference analysis","heading":"22.8 Split the heatmap into different groups","text":"can also divide heatmap groups. can achieved using split.parameter.\nFigure 1.9: SCpubr do_TFActivityPlot splitting heatmap.\n","code":"\n# Split the heatmap by another variable.\nsample$split.me <- ifelse(sample$seurat_clusters %in% c(\"0\", \"3\", \"7\"), \"Group A\",\"Group B\")\n\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 split.by = \"split.me\")\np <- out$heatmaps$average_scores\np"},{"path":"pseudotime-analysis.html","id":"pseudotime-analysis","chapter":"23 Pseudotime analysis","heading":"23 Pseudotime analysis","text":"Pseudotime analysis , perhaps, one major analysis can carried SC data. aims depict trajectory, sort order cells transition B. defines process, starting end point heavily driven research question, nature data prior knowledge. inferring using data-driven approaches possible, SCpubr implement prior-knowledge driven approach specific use case., make use monocle3. many uses monocle3, can infer trajectory graph cells , based list marker genes, can order cells along graph selecting either cell highest lowest enrichment score provided list genes starting point. example:general sense, working data set given biological phenotype expected. phenotype, list genes accurately characterize process. process needs differentiation kind, meaning cells transition based list genes state state B. conditions met, can make use trajectory graph alongside enrichment scores cells list genes. Depending whether list genes depict start end process, can use cell highest lowest enrichment scores starting point differentiation trajectory, ordering rest cells based computing associated pseudotime.course, selecting one cell highest lowest enrichment scores might simplistic approach, elevated low enrichment score might due technical bias. order correct bit, first select cluster (selected group) , average, highest lowest mean enrichment score cluster select cell highest lowest score, accordingly.clear, , like remark specific use case analysis much can done using monocle3. Please look vignette information pseudotime analysis. specific use case, SCpubr::do_PseudotimePlot() can used.","code":""},{"path":"pseudotime-analysis.html","id":"setting-up-partitions-and-clusters","chapter":"23 Pseudotime analysis","heading":"23.1 Setting up partitions and clusters","text":"function work, need Seurat object together Cell Data Set (CDS) object, needs generated SeuratWrappers::.cell_data_set().First thing take account monocle3 computes partitions clusters. , cells far away, trajectory disconnected, generating partitions different start end trajectories. can tweak process forcing data single partition keep identities group desire. can done using compute_monocle_partitions compute_monocle_clusters parameters.use following genes example, depict CD14+ mono cells.","code":"\n# Genes to use.\npseudotime_genes <- c(\"CD14\", \"LYN\")\n# Define your sample.\nsample <- your_seurat_object\n# Transform into CDS.\ncds <- SeuratWrappers::as.cell_data_set(sample)\n\n# Compute monocle clusters and partitions.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = TRUE,\n                                 pseudotime_genes = pseudotime_genes)\n\n# Compute monocle clusters and keep a single partition.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = FALSE,\n                                 compute_monocle_clusters = TRUE,\n                                 pseudotime_genes = pseudotime_genes)\n\n# Compute monocle partitions but keep original identities as clusters.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes)\n\n# Keep original identities as clusters and a single partition.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = FALSE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes)\n\n# Set a metadata varible as clusters and a single partition.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = FALSE,\n                                 compute_monocle_clusters = FALSE,\n                                 group.by = \"orig.ident\")"},{"path":"pseudotime-analysis.html","id":"visualizing-the-trajectory-graph","chapter":"23 Pseudotime analysis","heading":"23.2 Visualizing the trajectory graph","text":"\nSCpubr do_PseudotimePlot trajectory graph output.\ncan increase trajectory graph width using trajectory_graph_segment_size color trajectory_graph_color parameters.\nSCpubr do_PseudotimePlot trajectory graph different widths color.\n\nSCpubr do_PseudotimePlot trajectory graph roots, branches leaves.\ncan inspect pseudotime providing whether root trajectory highest lowest enrichment score, is_max_score_the_start parameter.\nSCpubr do_PseudotimePlot pseudotime output different ordering.\ncan also visualize enrichment scores feature plot alongside pseudotime, either symmetrical scale enforce_symmetry.\nSCpubr do_PseudotimePlot pseudotime output enrichment scores.\n","code":"\n# Compute trajectory graph.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes)\n# Retrieve trajectory groups.\np1 <- out$trajectory_groups\n# Retrieve trajectory partitions.\np2 <- out$trajectory_partitions\n\np <- p1 | p2\np\n# Change trajectory graph width.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 1)\np1 <- out$trajectory_partitions\n\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 2)\np2 <- out$trajectory_partitions\n\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 3)\np3 <- out$trajectory_partitions\n\n\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 3,\n                                 trajectory_graph_color = \"white\")\np4 <- out$trajectory_partitions\n\np <- (p1 | p2) / (p3 | p4)\np\n# Add nodes, branches and leaves to the trajectory graph.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 2,\n                                 label_roots = TRUE)\np1 <- out$trajectory_partitions\n\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 2,\n                                 label_roots = TRUE,\n                                 label_branches = TRUE)\np2 <- out$trajectory_partitions\n\n\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 2,\n                                 label_roots = TRUE,\n                                 label_branches = TRUE,\n                                 label_leaves = TRUE)\np3 <- out$trajectory_partitions\n\np <- p1 / p2 / p3\np\n# Plot pseudotime with monocle partitions using highest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 is_max_score_the_start = TRUE)\np1 <- out$pseudotime\n\n# Plot pseudotime with monocle partitions using lowest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 is_max_score_the_start = FALSE)\np2 <- out$pseudotime\n\n\n# Plot pseudotime with monocle partitions using highest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = FALSE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 is_max_score_the_start = TRUE)\np3 <- out$pseudotime\n\n# Plot pseudotime with monocle partitions using lowest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = FALSE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 is_max_score_the_start = FALSE)\np4 <- out$pseudotime\n\np <- (p1 | p2) / (p3 | p4)\np\n# Plot pseudotime with monocle partitions using highest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 enforce_symmetry = FALSE,\n                                 is_max_score_the_start = TRUE)\np1 <- out$pseudotime\np3 <- out$enrichment\n# Plot pseudotime with monocle partitions using lowest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 enforce_symmetry = TRUE,\n                                 is_max_score_the_start = FALSE)\np2 <- out$pseudotime\np4 <- out$enrichment\n\np <- (p1 | p2) / (p3 | p4)\np"},{"path":"color-palettes.html","id":"color-palettes","chapter":"24 Color palettes","heading":"24 Color palettes","text":"Almost important plot correct choice colors. continuous variables, viridis package wonders. However, comes categorical variables, define set values, choosing correct colors can difficult task, normally leading sub-optimal choices.Targeting problem, colortools package designed Gaston Sanchez. However, 23-06-2022, package removed CRAN, without clear signs restored (date writing section, 13-07-2022). cover functionally, SCpubr function called SCpubr::do_ColorPalette(), recapitulates critical functionalities package. core code functionality belongs Gaston Sanchez, source code can found colortools’ GitHub. plotting complete report functionalities SCpubr’s additions code.","code":""},{"path":"color-palettes.html","id":"generate-color-palettes","chapter":"24 Color palettes","heading":"24.1 Generate color palettes","text":"simplest way generate color palette SCpubr::do_ColorPalette() provide single color colors.use parameter. important remark one color provided. function iterates whole range HUE values generate equally spaced colors.default, returns 12 colors, can changed using n parameter.Just colors vector great use right away plotting functions. However, one can visualize colors look like using plot = TRUE.\nFigure 1.2: SCpubr::do_ColorPalette basic plot.\n","code":"\n# Generate a color palette.\nSCpubr::do_ColorPalette(colors.use = \"steelblue\")\n#>  [1] \"#4682B4\" \"#464BB4\" \"#7846B4\" \"#AF46B4\" \"#B44682\"\n#>  [6] \"#B4464B\" \"#B47846\" \"#B4AF46\" \"#82B446\" \"#4BB446\"\n#> [11] \"#46B478\" \"#46B4AF\"\n# Generate a color palette with a given number of colors.\nSCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                        n = 7)\n#> [1] \"#4682B4\" \"#6846B4\" \"#B446A1\" \"#B44946\" \"#B4A746\"\n#> [6] \"#63B446\" \"#46B488\"\n# Generate a color palette and plot it.\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             plot = TRUE)\n\np"},{"path":"color-palettes.html","id":"generate-combination-of-colors","chapter":"24 Color palettes","heading":"24.2 Generate combination of colors","text":"times, one might just want given combination colors, following color theory. different parameters can used. Using force n 12, use n parameter alongside , effect.","code":""},{"path":"color-palettes.html","id":"opposite-colors","chapter":"24 Color palettes","heading":"24.2.1 Opposite colors","text":"\nFigure 1.3: SCpubr::do_ColorPalette opposite colors.\n","code":"\n# Generate opposite colors.\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             opposite = TRUE,\n                             plot = TRUE)\n\np"},{"path":"color-palettes.html","id":"adjacent-colors","chapter":"24 Color palettes","heading":"24.2.2 Adjacent colors","text":"\nFigure 1.4: SCpubr::do_ColorPalette adjacent colors.\n","code":"\n# Generate adjacent colors.\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             adjacent = TRUE,\n                             plot = TRUE)\n\np"},{"path":"color-palettes.html","id":"triadic-colors","chapter":"24 Color palettes","heading":"24.2.3 Triadic colors","text":"\nFigure 1.5: SCpubr::do_ColorPalette triadic colors.\n","code":"\n# Generate triadic colors.\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             triadic = TRUE,\n                             plot = TRUE)\n\np"},{"path":"color-palettes.html","id":"split-complementary-colors.","chapter":"24 Color palettes","heading":"24.2.4 Split complementary colors.","text":"\nFigure 1.6: SCpubr::do_ColorPalette split complementary colors.\n","code":"\n# Generate split complementary colors.\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             split_complementary = TRUE,\n                             plot = TRUE)\n\np"},{"path":"color-palettes.html","id":"tetradic-colors","chapter":"24 Color palettes","heading":"24.2.5 Tetradic colors","text":"\nFigure 1.7: SCpubr::do_ColorPalette tetradic colors.\n","code":"\n# Generate tetradic colors\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             tetradic = TRUE,\n                             plot = TRUE)\n\np"},{"path":"color-palettes.html","id":"square-colors","chapter":"24 Color palettes","heading":"24.2.6 Square colors","text":"\nFigure 1.8: SCpubr::do_ColorPalette square colors.\n","code":"\n# Generate square colors\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             square = TRUE,\n                             plot = TRUE)\n\np"},{"path":"color-palettes.html","id":"generate-a-color-report","chapter":"24 Color palettes","heading":"24.3 Generate a color report","text":"However, might case one wants combinations time, select one works best. achieve , set complete_output = TRUE.\nFigure 1.9: SCpubr::do_ColorPalette square colors.\n","code":"\n# Generate a color report.\nout <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                               complete_output = TRUE)\n\n# Retrieve the color vectors.\ncolor_vectors <- out$colors\n\n# Retrieve the individual plots.\nplots <- out$plots\n\n# Retrieve a joint plot.\np <- out$combined_plot\np"},{"path":"common-features-across-plots.html","id":"common-features-across-plots","chapter":"Common features across plots","heading":"Common features across plots","text":"page aims list common features present across different functions package (functions ).Changing font size: Use font.size parameter provide number.Changing font type: Use font.type parameter provide either sans, mono serif.Add plot titles, subtitles captions: Use plot.title, plot.subtitle plot.caption parameters alongside text display.Changing legend types continuous variables: Use legend.type parameter provide either normal, colorbar colorsteps.Relocate legend: Use legend.position parameter alongside top, bottom, left right none remove .Changing font size: Use font.size parameter provide number.Modify default colors: Use colors.use categorical variables viridis_color_map continuous (exceptions apply, see corresponding subsection) provide valid color representations valid viridis color map.\n_ Modify direction continuous color scales: Used alongsize viridis_color_map, provide either 1 -1 viridis_direction specify whether viridis scale goes dark light vice versa.Plot borders around cells: Use plot_cell_borders parameter alongside border.size border.color customize looks.Toggle grid : Use plot.grid parameter alongside grid.type type lines grid.color grid color customize .Toggle axes : Use plot.axes parameter remove axes.","code":""},{"path":"rasterized-figures.html","id":"rasterized-figures","chapter":"Rasterized figures","heading":"Rasterized figures","text":"Many times want generate figures PDF format can later modify aspects image editors. problem comes work datasets , let’s say, 50.000 cells save plot PDF, cell now becomes item needs tracked PDF file. , SCpubr::do_DimPlot() SCpubr::do_FeaturePlot() present parameter raster, set TRUE turns image rasterized image., two major concepts take account generating rasterized images: pt.size raster.dpi.","code":""},{"path":"rasterized-figures.html","id":"effect-of-point-size-in-the-plots","chapter":"Rasterized figures","heading":"Effect of point size in the plots","text":"Depending point size provided, value lower 1, default cells become plus signs.\nFigure 1.1: Effect point size rasterized images.\n","code":"\np.0.5 <- SCpubr::do_DimPlot(sample = sample, \n                            raster = TRUE,\n                            pt.size = 0.5,\n                            plot.title = \"pt.size = 0.5\",\n                            raster.dpi = 512) |\n         SCpubr::do_FeaturePlot(sample = sample,\n                                raster = TRUE,\n                                features = \"CD14\",\n                                pt.size = 0.5,\n                            raster.dpi = 512)\n\np.1.0 <- SCpubr::do_DimPlot(sample = sample, \n                            raster = TRUE,\n                            pt.size = 1,\n                            plot.title = \"pt.size = 1.0\",\n                            raster.dpi = 512) |\n         SCpubr::do_FeaturePlot(sample = sample,\n                                raster = TRUE,\n                                features = \"CD14\",\n                                pt.size = 1,\n                            raster.dpi = 512)\n\np.2.0 <- SCpubr::do_DimPlot(sample = sample, \n                            raster = TRUE,\n                            pt.size = 2,\n                            plot.title = \"pt.size = 2.0\",\n                            raster.dpi = 512) |\n         SCpubr::do_FeaturePlot(sample = sample,\n                                raster = TRUE,\n                                features = \"CD14\",\n                                pt.size = 2,\n                            raster.dpi = 512)\np <- p.0.5 / p.1.0 / p.2.0\np"},{"path":"rasterized-figures.html","id":"effect-of-raster-dpi-in-the-plots","chapter":"Rasterized figures","heading":"Effect of raster dpi in the plots","text":"Depending value provided raster.dpi, overall resolution plot vary. Let’s focus setting pt.size = 2 vary raster.dpi:\nFigure 1.2: Effect raster dpi rasterized images.\nTherefore, optimal combination depend dataset size want look like.","code":"\np.0.5 <- SCpubr::do_DimPlot(sample = sample, \n                            raster = TRUE,\n                            pt.size = 2,\n                            plot.title = \"raster.dpi = 512\",\n                            raster.dpi = 512) |\n         SCpubr::do_FeaturePlot(sample = sample,\n                                raster = TRUE,\n                                features = \"CD14\",\n                                pt.size = 2,\n                            raster.dpi = 512)\n\np.1.0 <- SCpubr::do_DimPlot(sample = sample, \n                            raster = TRUE,\n                            pt.size = 2,\n                            plot.title = \"raster.dpi = 1024\",\n                            raster.dpi = 1024) |\n         SCpubr::do_FeaturePlot(sample = sample,\n                                raster = TRUE,\n                                features = \"CD14\",\n                                pt.size = 2,\n                            raster.dpi = 1024)\n\np.2.0 <- SCpubr::do_DimPlot(sample = sample, \n                            raster = TRUE,\n                            pt.size = 2,\n                            plot.title = \"raster.dpi = 2048\",\n                            raster.dpi = 2048) |\n         SCpubr::do_FeaturePlot(sample = sample,\n                                raster = TRUE,\n                                features = \"CD14\",\n                                pt.size = 2,\n                            raster.dpi = 2048)\np <- p.0.5 / p.1.0 / p.2.0\np"},{"path":"save-the-figures.html","id":"save-the-figures","chapter":"Save the figures","heading":"Save the figures","text":"Creating good plots just half process. equally important properly save . purpose SCpubr::save_Plot. function handy tool save plots easily different formats, .pdf, .png, .jpeg, .tiff .svg. can achieved providing following output_format parameter:\"\": store provided plot 5 formats.\"publication\": store plot .pdf, .png .svg.Individual format: Provide desired format saved one.Width Height set default 8 inches , plot squared. However, really important parameters modified user’s need. name file can provided file_name parameter path store files can specified figure_path. provided, figure_path default current working environment file_name default combination current date time. examples.","code":"\n# Generate a plot.\np <- SCpubr::do_DimPlot(sample = sample)\n\n# Default parameters.\nSCpubr::save_Plot(plot = p)\n\n# Specifying the name and folder.\nSCpubr::save_Plot(plot = p,\n                 figure_path = \"/path/to/my/figures/\",\n                 file_name = \"my_figure\")\n\n# Specify to also create a new folder.\nSCpubr::save_Plot(plot = p,\n                 figure_path = \"/path/to/my/figures/\",\n                 file_name = \"my_figure\",\n                 create_path = TRUE)\n\n# Set dimensions for the figure.\nSCpubr::save_Plot(plot = p,\n                 figure_path = \"/path/to/my/figures/\",\n                 file_name = \"my_figure\",\n                 create_path = TRUE,\n                 width = 8,\n                 height = 8)\n\n# Set quality (dpi).\nSCpubr::save_Plot(plot = p,\n                 figure_path = \"/path/to/my/figures/\",\n                 file_name = \"my_figure\",\n                 create_path = TRUE,\n                 width = 8,\n                 height = 8,\n                 dpi = 300)"},{"path":"troubleshooting.html","id":"troubleshooting","chapter":"Troubleshooting","heading":"Troubleshooting","text":"section aims clarify provide fixes common errors might appear due external factors.","code":""},{"path":"troubleshooting.html","id":"correcly-defining-the-number-of-columns-and-rows-in-the-legend","chapter":"Troubleshooting","heading":"Correcly defining the number of columns and rows in the legend","text":"Sometimes, using legend.ncol legend.nrow parameter across functions SCpubr implemented, output number columns rows reflect number provided. stands particularly true using legend.ncol. happens, apparently, due internal checks ggplot2 , today, solution found. However, due reason, legend.nrow introduced, attempt cases defining total number rows instead. However, normally cases normally arise legend forced uneven number items per row/column. Therefore, suggested always generated evenly distributed legends. representative example:","code":"\np1 <- SCpubr::do_DimPlot(sample, legend.ncol = 5)\np2 <- SCpubr::do_DimPlot(sample, legend.ncol = 8)\np3 <- SCpubr::do_DimPlot(sample, legend.ncol = 10)\np4 <- SCpubr::do_DimPlot(sample, legend.ncol = 8, legend.nrow = 2)\np5 <- SCpubr::do_DimPlot(sample, legend.nrow = 3)\np6 <- SCpubr::do_DimPlot(sample, legend.nrow = 7)\np1 / p2 / p3 / p4 / p5 / p6"},{"path":"citation.html","id":"citation","chapter":"Citation","heading":"Citation","text":"cite SCpubr publications, please use:can also use following BibLaTeX entry:","code":"Blanco-Carmona, E. Generating publication ready visualizations \nfor Single Cell transcriptomics using SCpubr. bioRxiv (2022) \ndoi:10.1101/2022.02.28.482303.@article{blanco-carmona_generating_2022,\n    title = {Generating publication ready visualizations for Single Cell transcriptomics using {SCpubr}},\n    url = {https://www.biorxiv.org/content/early/2022/03/01/2022.02.28.482303},\n    doi = {10.1101/2022.02.28.482303},\n    abstract = {Single Cell transcriptomic analysis has become a widespread technology of choice when it comes to understanding the differences at a transcriptomic level in heterogeneous samples. As a consequence, a plethora of analysis tools have been published to tackle the different analysis steps from count matrix generation to downstream analysis. Many of them provide ways to generate visualizations of the data. While some design choices are made, it is a common practice to provide the user with visualizations as raw as possible so that they can be customized to the user needs. However, in many cases these final customization steps are either time consuming or demand a very specific set of skills. This problem is addressed by {SCpubr}, which sacrifices some of this initial freedom of choice in aesthetics to provide the user a more streamlined way of generating high quality Single Cell transcriptomic visualizations.Competing Interest {StatementThe} authors have declared no competing interest.},\n    journaltitle = {{bioRxiv}},\n    author = {Blanco-Carmona, Enrique},\n    date = {2022},\n    note = {Publisher: Cold Spring Harbor Laboratory\n\\_eprint: https://www.biorxiv.org/content/early/2022/03/01/2022.02.28.482303.full.pdf},\n}"}]
