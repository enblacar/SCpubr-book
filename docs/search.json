[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SCpubr",
    "section": "",
    "text": "About this package\nWoops! You stumbled upon the in-development website for SCpubr v2.0.0! There is still a bit of time before the release, but stay tuned for the update!\nYou can have a peek to the changes here and in this website as it is being rebuilt!\nThanks!!"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "SCpubr",
    "section": "License",
    "text": "License\nSCpubr and corresponding documentation book licensed under GPL v3\n\n\nQC control and dimensional reduction\nIntegration\nC\n\n\n\n\nhist(c(1, 2, 3, 4))\n\n\n\n\n\n\n\nhist(c(2, 4, 3, 4))"
  },
  {
    "objectID": "preface/Installation-guide.html",
    "href": "preface/Installation-guide.html",
    "title": "Installation guide",
    "section": "",
    "text": "To install this package, use the following commands:\n\n# From CRAN - Official release:\ninstall.packages(\"SCpubr\")\n\n# From GitHub - Latest stable development version:\nif(!requireNamespace(\"devtools\", quietly = TRUE)){\n  install.packages(\"devtools\") # If not installed.\n}\n\ndevtools::install_github(\"enblacar/SCpubr\", ref = \"v2.0.0-dev-stable\")\n\nNote that additional packages may be required to run certain functions. This information is usually displayed when you load the package for the first time in the session.\n\nlibrary(\"SCpubr\")\n\n\nThis summary will provide you with the information you need to run the package:\n\nThe version of SCpubr you have installed and the latest version available.\nThe status of your dependencies (installed or missing), including the current and latest version of each installed dependency.\nThe functions that can be run based on your currently installed dependencies.\n\nNote that some packages, such as Seurat, ggplot2, or dplyr, require a minimum version. If your installed version is not high enough, these packages will be marked with an exclamation mark.\nIf you do not see this message, you can always generate it by using SCpubr::package_report().\nYou can also check the required packages for a specific function by using SCpubr::check_dependencies() and specifying the function name."
  },
  {
    "objectID": "preface/Dataset.html",
    "href": "preface/Dataset.html",
    "title": "Dataset used",
    "section": "",
    "text": "Through this manual we are going to use a publicly available dataset containing 10K raw cells. The following code is used to generate a Seurat object ready for plotting.\n\ncounts_path &lt;- \"path_to_count_matrix\"\n\n# Path count matrix.\ncounts &lt;- Seurat::Read10X(counts_path)\n\n# Create Seurat object.\nsample &lt;- Seurat::CreateSeuratObject(counts = counts, project = \"10K_pbmc\")\n\n# Compute percentage of mithochondrial RNA.\nsample &lt;- Seurat::PercentageFeatureSet(sample, pattern = \"^MT-\", col.name = \"percent.mt\")\n\n# Compute QC.\nmask1 &lt;- sample$nCount_RNA &gt;= 1000\nmask2 &lt;- sample$nFeature_RNA &gt;= 500\nmask3 &lt;- sample$percent.mt &lt;= 20\nmask &lt;- mask1 & mask2 & mask3\nsample &lt;- sample[, mask]\n\n# Normalize.\nsample &lt;- Seurat::SCTransform(sample)\n\n# Dimensional reduction.\nsample &lt;- Seurat::RunPCA(sample)\nsample &lt;- Seurat::RunUMAP(sample, dims = 1:30)\n\n# Find clusters.\nsample &lt;- Seurat::FindNeighbors(sample, dims = 1:30)\nsample &lt;- Seurat::FindClusters(sample, resolution = 0.2)"
  },
  {
    "objectID": "functions/DimPlots.html#basic-usage",
    "href": "functions/DimPlots.html#basic-usage",
    "title": "do_DimPlot() | Dimensional Reduction scatter plots",
    "section": "Basic usage",
    "text": "Basic usage\nDimPlots can be generated in SCpubr using the function SCpubr::do_DimPlot():\n\np &lt;- SCpubr::do_DimPlot(sample = sample)\n\np"
  },
  {
    "objectID": "functions/DimPlots.html#modifying-axes-behavior",
    "href": "functions/DimPlots.html#modifying-axes-behavior",
    "title": "do_DimPlot() | Dimensional Reduction scatter plots",
    "section": "Modifying axes behavior",
    "text": "Modifying axes behavior\nAxes are removed by default from the plot, together with the axes titles. This behaviour can be overridden with plot.axes = TRUE:\n\n# Bring back the Axes.\np &lt;- SCpubr::do_DimPlot(sample = sample,\n                        plot.axes = TRUE)\np\n\n\n\nBring back the axes."
  },
  {
    "objectID": "functions/DimPlots.html#label-the-clusters",
    "href": "functions/DimPlots.html#label-the-clusters",
    "title": "do_DimPlot() | Dimensional Reduction scatter plots",
    "section": "Label the clusters",
    "text": "Label the clusters\nIn some cases, we might want to remove the legend entirely, and instead plot labels on top of each cluster. This can be achieved by using label = TRUE.\n\n# Put labels on top of the clusters.\np &lt;- SCpubr::do_DimPlot(sample, \n                     label = TRUE)\np\n\n\n\n\n\n\n\nThese labels are, in essence the result of applying ggplot2::geom_label() on the plot. However, we might also want to have them as pure text instead of the labels. We can achieve that by providing label.box = FALSE.\n\n# Labels as text\np &lt;- SCpubr::do_DimPlot(sample = sample, \n                        label = TRUE,\n                        label.box = FALSE)\np\n\n\n\nLabels as text.\n\n\n\n\nHowever, we can play further with other parameters of the function such as label.color which will provide a different color for the text inside the labels and label.fill to modify the background of the labels.:\n\n# Change the color of the label text.\np1 &lt;- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.color = \"white\",\n                         label.fill = \"black\")\n\n# Change the color of the text.\np2 &lt;- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.color = \"black\",\n                         label.box = FALSE)\np &lt;- p1 | p2\np\n\n\n\n\n\n\n\nAlso, we can modify the size of the labels/text by using label.size paramter:\n\n# Change the size of the label text.\np1 &lt;- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.size = 6)\n\n# Change the size of the text.\np2 &lt;- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.box = FALSE,\n                         label.size = 6)\np &lt;- p1 | p2\np\n\n\n\n\n\n\n\nFinally, if the labels/text are overlapping one to another, we can try to fix that by repelling the labels from one to another. We can achieve this by using repel = TRUE:\n\n# Repel the labels.\np1 &lt;- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.color = \"black\",\n                         repel = TRUE)\n\n# Repel the text.\np2 &lt;- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.color = \"black\",\n                         label.box = FALSE,\n                         repel = TRUE)\np &lt;- p1 | p2\np"
  },
  {
    "objectID": "functions/DimPlots.html#changing-the-order-of-plotting",
    "href": "functions/DimPlots.html#changing-the-order-of-plotting",
    "title": "do_DimPlot() | Dimensional Reduction scatter plots",
    "section": "Changing the order of plotting",
    "text": "Changing the order of plotting\nBe default SCpubr::do_DimPlot() plots cells randomly using shuffle = TRUE. This is different from the default behavior of Seurat::DimPlot(), which plots cells based on their identity factor levels.\n\np1 &lt;- SCpubr::do_DimPlot(sample = sample,\n                         reduction = \"pca\",\n                         shuffle = TRUE)\n\np2 &lt;- SCpubr::do_DimPlot(sample = sample,\n                         reduction = \"pca\",\n                         shuffle = FALSE)\n\np &lt;- p1 | p2\np"
  },
  {
    "objectID": "functions/DimPlots.html#highlighting-cells",
    "href": "functions/DimPlots.html#highlighting-cells",
    "title": "do_DimPlot() | Dimensional Reduction scatter plots",
    "section": "Highlighting cells",
    "text": "Highlighting cells\nWe can highlight a certain group of cells in the plot. This is achieved by using the cells.highlight parameter.\n\ncells.use &lt;- sample(x = colnames(sample), \n                    size = 1500)\n\np &lt;- SCpubr::do_DimPlot(sample = sample,\n                        cells.highlight = cells.use)\n\np\n\n\n\n\n\n\n\nOne can also change the color of the highligted cells by providing single color to colors.use and the color of the not selected cells with na.value:\n\n# Change color of highlighted and non-highlighted cells.\np &lt;- SCpubr::do_DimPlot(sample = sample, \n                        cells.highlight = cells.use,\n                        colors.use = \"dodgerblue\",\n                        na.value = \"grey90\")\np\n\n\n\n\n\n\n\nThe size of the highlighted dots can be modified with the parameter sizes.highlight.\n\n# Increase the size of the highlighted cells.\np &lt;- SCpubr::do_DimPlot(sample = sample, \n                        cells.highlight = cells.use, \n                        sizes.highlight = 2)\np\n\n\n\n\n\n\n\nWe can also highlight whole identities with idents.highlight parameter. For this, just provide the desired identities to be selected. It can also work in combination with cells.highlight.\n\n# Using cells.highlight.\np1 &lt;- SCpubr::do_DimPlot(sample = sample, \n                         cells.highlight = cells.use)\n\n# Using idents.highlight.\np2 &lt;- SCpubr::do_DimPlot(sample = sample, \n                         idents.highlight = c(\"6\"))\n\n# Using both.\np3 &lt;- SCpubr::do_DimPlot(sample = sample, \n                         cells.highlight = cells.use, \n                         idents.highlight = c(\"6\"))\n\np &lt;- p1 | p2 | p3\np"
  },
  {
    "objectID": "functions/DimPlots.html#restrict-the-identitites-displayed",
    "href": "functions/DimPlots.html#restrict-the-identitites-displayed",
    "title": "do_DimPlot() | Dimensional Reduction scatter plots",
    "section": "Restrict the identitites displayed",
    "text": "Restrict the identitites displayed\nSometimes, we are interested in showing only some of the identities or groups in our sample. Instead of highlighting cells, we still want to keep the original colors and legend. For this use case, one might be tempted to just subset the sample as follows:\n\n# Subset desired identities in a DimPlot.\np &lt;- SCpubr::do_DimPlot(sample = sample[, sample$seurat_clusters %in% c(\"0\", \"5\", \"2\", \"4\")])\n\np\n\n\n\nSubsetting the Seurat object to restrict the identities shown.\n\n\n\n\nHowever, we end up losing the UMAP silhouette. For this use case, SCpubr::do_DimPlot() introduces idents.keep parameter, for which you can provide a vector with the identities you want to keep. This will assign to the rest of the cells a value of NA and they will be colored according to na.value parameter:\n\n# Select identities with idents.keep.\np1 &lt;- SCpubr::do_DimPlot(sample = sample,\n                         idents.keep = c(\"0\", \"5\", \"2\",  \"4\"))\n\n# Also, non-selected cells's color can be modified.\np2 &lt;- SCpubr::do_DimPlot(sample = sample,\n                         idents.keep = c(\"0\", \"5\", \"2\",  \"4\"),\n                         na.value = \"grey50\")\np &lt;- p1 | p2\np"
  },
  {
    "objectID": "functions/DimPlots.html#group-by-another-metadata-variable",
    "href": "functions/DimPlots.html#group-by-another-metadata-variable",
    "title": "do_DimPlot() | Dimensional Reduction scatter plots",
    "section": "Group by another metadata variable",
    "text": "Group by another metadata variable\nSo far, all the DimPlots displayed have shown the identities as the ones that are currently set in the object. This can be consulted by using Seurat::Idents(sample). However, naturally, we might want to display different metadata variables. This can be easily achieved by using group.by parameter:\n\n# Generate another metadata variable to group the cells by.\nsample$annotation &lt;- sample(c(\"A\", \"B\", \"C\"), ncol(sample), replace = TRUE)\n\n# Group by another metadata variable.\np1 &lt;- SCpubr::do_DimPlot(sample, \n                         group.by = \"seurat_clusters\")\n\np2 &lt;- SCpubr::do_DimPlot(sample, \n                         group.by = \"annotation\")\n\np &lt;- p1 | p2\np"
  },
  {
    "objectID": "functions/DimPlots.html#splitting-by-a-category",
    "href": "functions/DimPlots.html#splitting-by-a-category",
    "title": "do_DimPlot() | Dimensional Reduction scatter plots",
    "section": "Splitting by a category",
    "text": "Splitting by a category\nAnother useful parameter is split.by, which allows you to split your DimPlot into multiple panels, each one containing a different unique value of the metadata variable you have provided to the argument. One can understand this as using the group.by parameter and then splitting the resulting DimPlot into different panels. In this example, we are going to use the different clusters as an example. This is how it looks by default:\n\n# SCpubr's DimPlot using split.by\np &lt;- SCpubr::do_DimPlot(sample, \n                        split.by = \"seurat_clusters\", \n                        ncol = 5, \n                        legend.position = \"none\",\n                        font.size = 24)\n\np\n\n\n\n\n\n\n\nIf we are interested only in a subset of the possible values, we can use idents.keep alongside a vector containing the values to keep from the unique values in split.by:\n\n# Using split.by and restricting the number of output plots with idents.keep.\np &lt;- SCpubr::do_DimPlot(sample, \n                        split.by = \"seurat_clusters\", \n                        ncol = 3, \n                        idents.keep = c(\"0\", \"1\", \"7\"),\n                        legend.position = \"none\",\n                        font.size = 24)\n\np"
  },
  {
    "objectID": "functions/DimPlots.html#group-by-a-variable-but-split-by-another",
    "href": "functions/DimPlots.html#group-by-a-variable-but-split-by-another",
    "title": "do_DimPlot() | Dimensional Reduction scatter plots",
    "section": "Group by a variable but split by another",
    "text": "Group by a variable but split by another\nFinally, but also importantly, users might want to split the UMAP using split.by, while also grouping (coloring) the values by another variable using group.by. Using these two parameters in combination yields the following:\n\n# Using split.by and group.by in combination.\nsample$orig.ident &lt;- sample(c(\"A\", \"B\", \"C\"), \n                            ncol(sample), \n                            replace = TRUE, \n                            prob = c(0.05, 0.1, 0.85))\n\np &lt;- SCpubr::do_DimPlot(sample, \n                        group.by = \"seurat_clusters\",\n                        split.by = \"orig.ident\", \n                        font.size = 24)\n\np"
  },
  {
    "objectID": "functions/FeaturePlots.html",
    "href": "functions/FeaturePlots.html",
    "title": "Feature plots",
    "section": "",
    "text": "And more!\nThere are many synergies across functions. Have a look at the section Shared features across functions!"
  },
  {
    "objectID": "functions/FeaturePlots.html#control-axis-limits",
    "href": "functions/FeaturePlots.html#control-axis-limits",
    "title": "Feature plots",
    "section": "Control axis limits",
    "text": "Control axis limits\nMore often than not, we encounter that very few cells are driving the color axis. Very few cells with very high values will inevitably comprise the cells in a very limited color range due to their values. For this, we can manually set up the limits by using min.cutoff and max.cutoff.\n\np1 &lt;- SCpubr::do_FeaturePlot(sample = sample,\n                             features = \"PC_1\",\n                             min.cutoff = 0)\n\np2 &lt;- SCpubr::do_FeaturePlot(sample = sample,\n                             features = \"PC_1\",\n                             max.cutoff = 0)\np &lt;- p1 | p2\np"
  },
  {
    "objectID": "functions/FeaturePlots.html#plot-a-subset-of-cells",
    "href": "functions/FeaturePlots.html#plot-a-subset-of-cells",
    "title": "Feature plots",
    "section": "Plot a subset of cells",
    "text": "Plot a subset of cells\nWe can also restrict which cells are taken into account for the plot and grey out the rest. This is specially important if we want to inspect population-wise patterns of expression, for instance.\n\n# Use a vector of cells\np1 &lt;- SCpubr::do_FeaturePlot(sample = sample,\n                             features = c(\"PC_1\"),\n                             cells.highlight = sample(colnames(sample), 500))\n\n# Select identities.\np2 &lt;- SCpubr::do_FeaturePlot(sample = sample,\n                             features = c(\"PC_1\"),\n                             idents.highlight = c(\"0\", \"2\", \"5\"))\np &lt;- p1 | p2\np\n\n\n\n\n\n\n\nA combination of cells.highlight and idents.highlight is also possible!"
  },
  {
    "objectID": "functions/FeaturePlots.html#split-by-a-variable",
    "href": "functions/FeaturePlots.html#split-by-a-variable",
    "title": "Feature plots",
    "section": "Split by a variable",
    "text": "Split by a variable\nWe can also plot the cells split by a metadata variable using split.by:\n\n# Use a vector of cells\np &lt;- SCpubr::do_FeaturePlot(sample = sample,\n                            features = c(\"PC_1\"),\n                            split.by = \"seurat_clusters\",\n                            ncol = 5)\np\n\n\n\n\n\n\n\nAnd we can restrict which identities are shown when using split.by with idents.keep.\n\n# Use a vector of cells\np &lt;- SCpubr::do_FeaturePlot(sample = sample,\n                            features = c(\"PC_1\"),\n                            split.by = \"seurat_clusters\",\n                            idents.keep = c(\"0\", \"5\", \"7\"),\n                            ncol = 3)\np"
  },
  {
    "objectID": "functions/BarPlots.html#basic-usage",
    "href": "functions/BarPlots.html#basic-usage",
    "title": "Bar plots",
    "section": "Basic usage",
    "text": "Basic usage\n\n# Basic bar plot, horizontal.\np1 &lt;- SCpubr::do_BarPlot(sample = sample, \n                         group.by = \"seurat_clusters\", \n                         legend.position = \"none\", \n                         plot.title = \"Number of cells per cluster\")\n\n# Basic bar plot, vertical.\np2 &lt;- SCpubr::do_BarPlot(sample = sample, \n                         group.by = \"seurat_clusters\", \n                         legend.position = \"none\",\n                         plot.title = \"Number of cells per cluster\", \n                         flip = TRUE)\np &lt;- p1 | p2\np\n\n\n\nBasic bar plot.\n\n\n\n\nUsing SCpubr::do_BarPlot() with only group.by yields a simple bar plot which is ordered by descending value. We can also set up the direction of the bars with flip = TRUE/FALSE, which by default is set to be vertical. There is an underlying assumption that is being taken to generate these plots:\n\nThe values in group.by need to be metadata variables, stored in object@meta.data. They have to be either a character or factor columns."
  },
  {
    "objectID": "functions/BarPlots.html#grouping-by-a-second-variable",
    "href": "functions/BarPlots.html#grouping-by-a-second-variable",
    "title": "Bar plots",
    "section": "Grouping by a second variable",
    "text": "Grouping by a second variable\nLetâ€™s expand on the previous example on the number of cells per cluster. What if we were interested not only on that, but we would like to profile how many cells from each cluster are present in each of the unique samples present in the Seurat object? For this, we need to provide SCpubr::do_BarPlot() with a second parameter, split.by, that tackles how we want the feature to be grouped:\n\nsample$modified_orig.ident &lt;- sample(x = c(\"Sample_A\", \"Sample_B\", \"Sample_C\"), \n                                     size = ncol(sample), \n                                     replace = TRUE, \n                                     prob = c(0.2, 0.7, 0.1))\n\n# Split by a second variable.\np1 &lt;- SCpubr::do_BarPlot(sample,\n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         plot.title = \"Number of cells per cluster in each sample\",\n                         position = \"stack\")\n\np2 &lt;- SCpubr::do_BarPlot(sample, \n                         group.by = \"modified_orig.ident\", \n                         split.by = \"seurat_clusters\",\n                         plot.title = \"Number of cells per sample in each cluster\",\n                         position = \"stack\")\np &lt;- p1 | p2\np\n\n\n\nSplit the bars by another variable.\n\n\n\n\nAs we can see, this nicely yields as many number of bars as unique values in the group.by, and this bars are segmented by as many times as unique values in split.by. At first, this is hard to grasp, but it helps thinking of these two parameters, when used together, as:\n\n\ngroup.by: What I want to show as different bars, the total number of counts.\n\nsplit.by: Secondary variable on which the bars generated by group.by can be further subdivided."
  },
  {
    "objectID": "functions/BarPlots.html#representing-proportions",
    "href": "functions/BarPlots.html#representing-proportions",
    "title": "Bar plots",
    "section": "Representing proportions",
    "text": "Representing proportions\nAnother interesting parameter introduced in the last example is position. Position can be either stack or fill. The difference between them is that position = \"stack\" will yield the total number of cells for each of the unique values in feature, while position = \"fill\" will bring all bars to the same height and will split each bar into the proportions within each bar of the different groups (only one if group.by = NULL and as many groups if group.by is used). To use position = fill, you must also provide a value for split.by.\n\n\np1 &lt;- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         position = \"fill\",\n                         flip = FALSE)\n\np2 &lt;- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         position = \"fill\",\n                         flip = TRUE)\n\n\np &lt;- p1 | p2\np\n\n\n\nPosition = fill"
  },
  {
    "objectID": "functions/BarPlots.html#add-total-counts",
    "href": "functions/BarPlots.html#add-total-counts",
    "title": "Bar plots",
    "section": "Add total counts",
    "text": "Add total counts\nFinally, it is also interesting to report the total number of counts for each of the bars. This is done withe following combination of parameters: - add.n: Whether you want to add the total counts or not. - add.n.expand: How much you want the axes to expand. A number that will be added on top of the fraction. If you put 0.25, then the Y axis will range from 0 to 1.25. - add.n.size: Size of the labels.\nOne has to play with these parameters until a suitable combination is found for the given picture, as it will greatly depend on the dimensions set for the picture.\n\n\np1 &lt;- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         position = \"fill\",\n                         flip = FALSE,\n                         add.n = TRUE,\n                         add.n.size = 4)\n\np2 &lt;- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         position = \"fill\",\n                         add.n = TRUE,\n                         flip = TRUE,\n                         add.n.size = 4)\n\n\np &lt;- p1 | p2\np\n\n\n\nPosition = fill"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#basic-parameters",
    "href": "cheatsheets/Shared_Features.html#basic-parameters",
    "title": "Shared features across functions",
    "section": "Basic parameters",
    "text": "Basic parameters\nThere are a handful of parameters needed to run mostly any function in SCpubr:\n\n\nsample: Seurat object to use for plotting.\n\ngroup.by: Metadata variable to group the values to plot by.\n\nsplit.by: Metadata variable to split the values to plot by.\n\nfeatures: Genes, metadata columns, dimensional reduction column names to use for plotting.\n\ninput_gene_list: Named list with different gene sets to use for plotting.\n\nassay: Assay name to pull the data from.\n\nslot: Slot in assay to pull the data from.\n\nreduction: Which dimensional reduction to use for plotting.\n\ndims: A vector with numbers representing which dimensions of the dimensional reduction embedding to use.\n\nna.value: Color used for NA values.\n\nraster: Whether to rasterize (TRUE) an image or not (FALSE).\n\nraster.dpi: Resolution of the rasterization."
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#change-colors-categorical",
    "href": "cheatsheets/Shared_Features.html#change-colors-categorical",
    "title": "Shared features across functions",
    "section": "Change colors | categorical",
    "text": "Change colors | categorical\nSCpubr has a built-in custom color palette for categorical variables. However, it is very often the case that we do want our own color system in the plots. This is always achieved by using the colors.use parameter. The input to this parameter can vary on a per function basis, but it is always one for the following:\n\nA vector of named values. The names correspond to each of the unique values that the categorical variable to plot has, and the values are the colors corresponding to each of those values.\nA named list of vectors of named values. In more complex scenarios, we have different categorical variables to plot. For this, the names of the list will correspond to the names of the categorical variables stored in the metadata of the Seurat object, and the values will be the vectors of named values (like in the example above). Each vector should contain as many values as unique occurrences in the metadata variable.\n\n\n\nVector of named values\nList of vectors\n\n\n\n\nCodecolors &lt;- c(\"0\" = \"#001219\",\n            \"1\" = \"#005f73\",\n            \"2\" = \"#0a9396\",\n            \"3\" = \"#94d2bd\",\n            \"4\" = \"#e9d8a6\",\n            \"5\" = \"#ee9b00\",\n            \"6\" = \"#ca6702\",\n            \"7\" = \"#bb3e03\",\n            \"8\" = \"#ae2012\",\n            \"9\" = \"#9b2226\")\n\nSCpubr::do_DimPlot(sample,\n                   colors.use = colors)\n\n\n\n\n\n\n\n\n\n\nCodecolors &lt;- list(\"seurat_clusters\" = c(\"0\" = \"#001219\",\n                                     \"1\" = \"#005f73\",\n                                     \"2\" = \"#0a9396\",\n                                     \"3\" = \"#94d2bd\",\n                                     \"4\" = \"#e9d8a6\",\n                                     \"5\" = \"#ee9b00\",\n                                     \"6\" = \"#ca6702\",\n                                     \"7\" = \"#bb3e03\",\n                                     \"8\" = \"#ae2012\",\n                                     \"9\" = \"#9b2226\"),\n               \"annotation\" = c(\"A\" = \"#ca6702\",\n                                \"B\" = \"#0a9396\"))\n\nSCpubr::do_SCExpressionHeatmap(sample,\n                               features = Seurat::VariableFeatures(sample)[1:20],\n                               metadata = c(\"seurat_clusters\", \"annotation\"),\n                               metadata.colors = colors)"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#change-colors-continuous",
    "href": "cheatsheets/Shared_Features.html#change-colors-continuous",
    "title": "Shared features across functions",
    "section": "Change colors | continuous",
    "text": "Change colors | continuous\nFor continuous variables, we do have a more complex system. First of all, SCpubr has implemented both RColorBrewer palettes and Viridis palettes palettes, and use them interchangeably depending on the function. This behavior can accessed and customized with the following parameters:\n\n\nuse_viridis: Whether to use a viridis palette (TRUE) or not (FALSE).\n\nviridis.palette: Which viridis palette to use. Can be either the long name or the shortened version.\n\nsequential.palette: Which RColorBrewer continuous palette to use.\n\nviridis.direction: Whether to map the darkest colors to the lowest values (1) or not (-1).\n\nsequential.direction: Whether to map the darkest colors to the lowest values (-1) or not (1).\n\n\n\nViridis palettes\nRColorBrewer palettes\nDirections\n\n\n\n\n\nA | magma\nB | inferno\nC | plasma\nD | viridis\nE | cividis\nF | rocket\nG | mako\nH | turbo\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = TRUE,\n                      viridis.palette = \"A\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = TRUE,\n                      viridis.palette = \"B\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = TRUE,\n                      viridis.palette = \"C\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = TRUE,\n                      viridis.palette = \"D\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = TRUE,\n                      viridis.palette = \"E\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = TRUE,\n                      viridis.palette = \"F\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = TRUE,\n                      viridis.palette = \"G\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = TRUE,\n                      viridis.palette = \"H\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYlOrRd\nYlOrBr\nYlGnBu\nYlGn\nReds\nRdPu\nPurples\nPuRd\nPuBuGn\nPuBu\nOrRd\nOranges\nGreys\nGreens\nGnBu\nBuPu\nBuGn\nBlues\n\n\n\n\nCode# Yellow --&gt; Orange --&gt; Red\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"YlOrRd\")\n\n\n\n\n\n\n\n\n\n\nCode# Yellow --&gt; Orange --&gt; Brown\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"YlOrBr\")\n\n\n\n\n\n\n\n\n\n\nCode# Yellow --&gt; Green --&gt; Blue\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"YlGnBu\")\n\n\n\n\n\n\n\n\n\n\nCode# Yellow --&gt; Green\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"YlGn\")\n\n\n\n\n\n\n\n\n\n\nCode# Reds\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"Reds\")\n\n\n\n\n\n\n\n\n\n\nCode# Red --&gt; Purple\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"RdPu\")\n\n\n\n\n\n\n\n\n\n\nCode# Purples\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"Purples\")\n\n\n\n\n\n\n\n\n\n\nCode# Purple --&gt; Red\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"PuRd\")\n\n\n\n\n\n\n\n\n\n\nCode# Purple --&gt; Blue --&gt; Green\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"PuBuGn\")\n\n\n\n\n\n\n\n\n\n\nCode# Purple --&gt; Blue\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"PuBu\")\n\n\n\n\n\n\n\n\n\n\nCode# Orange --&gt; Red\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"OrRd\")\n\n\n\n\n\n\n\n\n\n\nCode# Oranges\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"Oranges\")\n\n\n\n\n\n\n\n\n\n\nCode# Greys\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"Greys\")\n\n\n\n\n\n\n\n\n\n\nCode# Greens\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"Greens\")\n\n\n\n\n\n\n\n\n\n\nCode# Green --&gt; Blue\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"GnBu\")\n\n\n\n\n\n\n\n\n\n\nCode# Blue --&gt; Purple\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"BuPu\")\n\n\n\n\n\n\n\n\n\n\nCode# Blue --&gt; Green\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"BuGn\")\n\n\n\n\n\n\n\n\n\n\nCode# Blues\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.palette = \"Blues\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nViridis | direction = 1\nViridis | direction = -1\nRColorBrewer | direction = 1\nRColorBrewer | direction = -1\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = TRUE,\n                      viridis.direction = 1)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = TRUE,\n                      viridis.direction = -1)\n\n\n\n\n\n\n\n\n\n\nCode# Blues\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.direction = 1)\n\n\n\n\n\n\n\n\n\n\nCode# Blues\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      use_viridis = FALSE,\n                      sequential.direction = -1)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlease note that the direction is inverted between viridis and RColorBrewer palettes."
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#change-colors-diverging",
    "href": "cheatsheets/Shared_Features.html#change-colors-diverging",
    "title": "Shared features across functions",
    "section": "Change colors | diverging",
    "text": "Change colors | diverging\nFinally, there is a special case of sequential palettes in which there is a clear emphasis on the two ends of the scale. Those are called diverging palettes. This is a very usual case in scaled data. Normally the middle values are colored in a very light color in contrast with the two ends of the scale, which will have a very dark color. This can be used with the following:\n\n\ndiverging.palette: Which RColorBrewer diverging palette to use.\n\nIn such cases, the color palette used is chosen among the diverging palettes in RColorBrewer and can be chosen using diverging.palette.\n\n\nSpectral\nRdYlGn\nRdGy\nRdBu\nPuOr\nPRGn\nPiYG\nBrBG\n\n\n\n\nCode# Spectral\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      enforce_symmetry = TRUE,\n                      diverging.palette = \"Spectral\")\n\n\n\n\n\n\n\n\n\n\nCode# Red --&gt; Yellow --&gt; Green\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      enforce_symmetry = TRUE,\n                      diverging.palette = \"RdYlGn\")\n\n\n\n\n\n\n\n\n\n\nCode# Red --&gt; Grey\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      enforce_symmetry = TRUE,\n                      diverging.palette = \"RdGy\")\n\n\n\n\n\n\n\n\n\n\nCode# Red --&gt; Blue\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      enforce_symmetry = TRUE,\n                      diverging.palette = \"RdBu\")\n\n\n\n\n\n\n\n\n\n\nCode# Purple --&gt; Orange\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      enforce_symmetry = TRUE,\n                      diverging.palette = \"PuOr\")\n\n\n\n\n\n\n\n\n\n\nCode# Purple --&gt; Green\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      enforce_symmetry = TRUE,\n                      diverging.palette = \"PRGn\")\n\n\n\n\n\n\n\n\n\n\nCode# Pink --&gt; Yellow-Green\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      enforce_symmetry = TRUE,\n                      diverging.palette = \"PiYG\")\n\n\n\n\n\n\n\n\n\n\nCode# Brown --&gt; Blue-Green\nSCpubr::do_FeaturePlot(sample,\n                      features = \"PC_1\", \n                      enforce_symmetry = TRUE,\n                      diverging.palette = \"BrBG\")"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#symmetrical-plots",
    "href": "cheatsheets/Shared_Features.html#symmetrical-plots",
    "title": "Shared features across functions",
    "section": "Symmetrical plots",
    "text": "Symmetrical plots\nSome visualizations have a tendency to be symmetrical. While this is not always achieved naturally, they greatly benefit from it. One example are volcano plots, where having the 0 in the X axis in the center helps understanding the spatial disposition of the dots in the plot. Some other cases, we might be plotting a continuous variable that has a diverging nature, and we would like to have a diverging color scale used on it and the limits of the scale also being centered around the middle point. for this, we can use the following:\n\n\nenforce_symmetry: Whether to make the plot symmetrical (TRUE) or not (FALSE). This varies depending on the function. It can make the axes symmetrical between them or make the color scale diverging and the limits centered around the middle value.\n\n\n\nSymmetrical: equal scales\nSymmetrical: equal color scale limits\n\n\n\n\nCodegenes &lt;- list(\"A\" = Seurat::VariableFeatures(sample)[1:20],\n              \"B\" = Seurat::VariableFeatures(sample)[21:40],\n              \"C\" = Seurat::VariableFeatures(sample)[41:60],\n              \"D\" = Seurat::VariableFeatures(sample)[61:80])\n\np1 &lt;- SCpubr::do_CellularStatesPlot(sample,\n                                    input_gene_list = genes,\n                                    x1 = \"A\",\n                                    x2 = \"B\",\n                                    y1 = \"C\",\n                                    y2 = \"D\",\n                                    enforce_symmetry = FALSE)\n\np2 &lt;- SCpubr::do_CellularStatesPlot(sample,\n                                    input_gene_list = genes,\n                                    x1 = \"A\",\n                                    x2 = \"B\",\n                                    y1 = \"C\",\n                                    y2 = \"D\",\n                                    enforce_symmetry = TRUE)\n\np &lt;- p1 | p2\np\n\n\n\n\n\n\n\n\n\n\nCodep1 &lt;- SCpubr::do_FeaturePlot(sample,\n                             features = \"PC_1\", \n                             enforce_symmetry = FALSE)\n\np2 &lt;- SCpubr::do_FeaturePlot(sample,\n                             features = \"PC_1\", \n                             enforce_symmetry = TRUE)\n\np &lt;- p1 | p2\np"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#set-limits-to-continuous-variables",
    "href": "cheatsheets/Shared_Features.html#set-limits-to-continuous-variables",
    "title": "Shared features across functions",
    "section": "Set limits to continuous variables",
    "text": "Set limits to continuous variables\nMany times, we encounter plots where the color scale is completely driven by a single outlier in the data, therefore rendering the rest of values very difficult to visually compare. To solve this, you can use:\n\n\nmin.cutoff: Minimum value for the color scale.\n\nmax.cutoff: Maximum value for the color scale.\n\nThis basically performs a transformation of the values outside the defined range, turning them into either the minimum or maximum value designated by the user.\n\n\nSet minimum value\nSet maximum value\nSet both\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample = sample,\n                       features = \"PC_1\",\n                       min.cutoff = 0)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample = sample,\n                       features = \"PC_1\",\n                       max.cutoff = 0)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_FeaturePlot(sample = sample,\n                       features = \"PC_1\",\n                       min.cutoff = -10,\n                       max.cutoff = 10)"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#flip-the-axes",
    "href": "cheatsheets/Shared_Features.html#flip-the-axes",
    "title": "Shared features across functions",
    "section": "Flip the axes",
    "text": "Flip the axes\nIn many cases, it is possible to completely switch the plot axes. Sometimes information can be more easily conveyed by using a X/Y setup rather than Y/X. This can be achieved by:\n\n\nflip: Whether to swap X and Y axes (TRUE) or not (FALSE).\n\n\n\nNo flip\nFlip\n\n\n\n\nCodeSCpubr::do_BarPlot(sample = sample,\n                   group.by = \"seurat_clusters\",\n                   split.by = \"annotation\",\n                   position = \"fill\",\n                   flip = FALSE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_BarPlot(sample = sample,\n                   group.by = \"seurat_clusters\",\n                   split.by = \"annotation\",\n                   position = \"fill\",\n                   flip = TRUE)"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#modify-plot-titles",
    "href": "cheatsheets/Shared_Features.html#modify-plot-titles",
    "title": "Shared features across functions",
    "section": "Modify plot titles",
    "text": "Modify plot titles\nWhen applicable (some functions might restrict the access to these parameters), the different titles of the plot can be modified by using the following parameters:\n\n\nplot.title: Title of the plot.\n\nplot.subtitle: Subtitle of the plot.\n\nplot.caption: Caption of the plot.\n\nxlab: X axis title.\n\nylab: Y axis title.\n\nlegend.title: Title of the legend.\n\n\nCodeSCpubr::do_BarPlot(sample = sample,\n                   group.by = \"seurat_clusters\",\n                   split.by = \"annotation\",\n                   position = \"fill\",\n                   flip = TRUE,\n                   plot.title = \"This is a title\",\n                   plot.subtitle = \"This is a subtitle\",\n                   plot.caption = \"This is a caption\",\n                   xlab = \"My X axis title\",\n                   ylab = \"My Y axis title\",\n                   legend.title = \"My custom title\")"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#control-plot-aesthetics",
    "href": "cheatsheets/Shared_Features.html#control-plot-aesthetics",
    "title": "Shared features across functions",
    "section": "Control plot aesthetics",
    "text": "Control plot aesthetics\nPretty much mirroring the style of ggplot2::theme(), SCpubr offers a wide range of parameters to adjust the way text elements in the plots are displayed:\n\n\nfont.size: Controls the general font size of the plot. Different elements will have higher or lower font size to keep them coherent.\n\nfont.type: Controls the type of font used, can be one of: sans, serif, mono.\n\nplot.title.face: Controls the style of the font of the plot title.\n\nplot.subtitle.face: Controls the style of the font of the plot subtitle.\n\nplot.caption.face: Controls the style of the font of the plot caption.\n\naxis.title.face: Controls the style of the font of the axes titles.\n\naxis.text.face: Controls the style of the font of the text displayed in the axes.\n\nlegend.title.face: Controls the style of the font of the legend title.\n\nlegend.text.face: Controls the style of the font of the text in the legend.\n\nstrip.text.face: Controls the style of the font of the text in the strips (defined by ggplot2::facet_grid() or ggplot2::facet_wrap()).\n\nCan be one of: plain, italic, bold or bold.italic.\n\nCodeSCpubr::do_BarPlot(sample = sample,\n                   group.by = \"seurat_clusters\",\n                   split.by = \"annotation\",\n                   position = \"fill\",\n                   flip = TRUE,\n                   plot.title = \"This is a title\",\n                   plot.subtitle = \"This is a subtitle\",\n                   plot.caption = \"This is a caption\",\n                   xlab = \"My X axis title\",\n                   ylab = \"My Y axis title\",\n                   legend.title = \"My custom title\",\n                   plot.title.face = \"italic\",\n                   plot.subtitle.face = \"bold.italic\",\n                   plot.caption.face = \"bold\",\n                   axis.title.face = \"italic\",\n                   axis.text.face = \"plain\",\n                   legend.title.face = \"italic\",\n                   legend.text.face = \"bold.italic\",\n                   font.type = \"mono\",\n                   font.size = 15)"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#control-legend-aesthetics",
    "href": "cheatsheets/Shared_Features.html#control-legend-aesthetics",
    "title": "Shared features across functions",
    "section": "Control legend aesthetics",
    "text": "Control legend aesthetics\nApart from the parameters above, one can control other aspects of the legend with:\n\n\nlegend.position: Position of the legend in the plot. Either top, bottom, left, right or none to remove it entirely.\n\nlegend.title.position: Position of the title in the legend. Can be one of: top, bottom, right, left.\n\nlegend.icon.size: Size of each elements in the legend (for a categorical variable).\n\nlegend.ncoland legend.nrow: How many rows and columns the legend should have (in categorical variables).\n\nlegend.byrow: Whether the legend should be filled by rows (TRUE) or columns (FALSE).\n\nlegend.type: Whether to have a normal-looking legend (normal) or a bigger, more spacious colorbar (colorbar).\n\nlegend.tickcolor: Controls the color of the ticks in the legend (continuous variables).\n\nlegend.framecolor: Controls the color of the border in the legend (continuous variables).\n\nlegend.length: Controls the length of the legend (continuous variables).\n\nlegend.width: Controls the height of the legend (continuous variables).\n\nlegend.framewidth: Controls the width of the border line in the legend (continuous variables).\n\nlegend.tickwidth: Controls the width of the ticks in the legend (continuous variables).\n\nnumber.breaks: Defines the number of breaks in the legend (might slightly vary)."
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#control-grid-aesthetics",
    "href": "cheatsheets/Shared_Features.html#control-grid-aesthetics",
    "title": "Shared features across functions",
    "section": "Control grid aesthetics",
    "text": "Control grid aesthetics\nIn some plots, it is also possible to draw the grid lines to help guiding the user across the information displayed on them. The following parameters control the grid aesthetics:\n\n\nplot.grid: Whether to show the grid (TRUE) or not (FALSE).\n\ngrid.color: Color of the grid lines.\n\ngrid.type: Type of lines used in the grid. Can be one of: blank, solid, dashed, dotted, dotdash, longdash, twodash.\n\n\n\nShow grid\nGrid color\nGrid type\n\n\n\n\n\nNo grid\nGrid\n\n\n\n\nCodeSCpubr::do_BarPlot(sample,\n                   group.by = \"seurat_clusters\",\n                   plot.grid = FALSE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_BarPlot(sample,\n                   group.by = \"seurat_clusters\",\n                   plot.grid = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDefault grid color\nBlack\n\n\n\n\nCodeSCpubr::do_BarPlot(sample,\n                   group.by = \"seurat_clusters\",\n                   plot.grid = TRUE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_BarPlot(sample,\n                   group.by = \"seurat_clusters\",\n                   plot.grid = TRUE,\n                   grid.color = \"black\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType = blank\nType = solid\nType = dashed\nType = dotdash\nType = longdash\nType = twodash\n\n\n\n\nCodeSCpubr::do_BarPlot(sample,\n                   group.by = \"seurat_clusters\",\n                   plot.grid = TRUE,\n                   grid.type = \"blank\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_BarPlot(sample,\n                   group.by = \"seurat_clusters\",\n                   plot.grid = TRUE,\n                   grid.type = \"solid\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_BarPlot(sample,\n                   group.by = \"seurat_clusters\",\n                   plot.grid = TRUE,\n                   grid.type = \"dashed\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_BarPlot(sample,\n                   group.by = \"seurat_clusters\",\n                   plot.grid = TRUE,\n                   grid.type = \"dotdash\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_BarPlot(sample,\n                   group.by = \"seurat_clusters\",\n                   plot.grid = TRUE,\n                   grid.type = \"longdash\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_BarPlot(sample,\n                   group.by = \"seurat_clusters\",\n                   plot.grid = TRUE,\n                   grid.type = \"twodash\")"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#control-cell-borders",
    "href": "cheatsheets/Shared_Features.html#control-cell-borders",
    "title": "Shared features across functions",
    "section": "Control cell borders",
    "text": "Control cell borders\nA very nice addition than enhances visibility of any plot where cells are drawn as dots is to add a black border around them. However, just changing the shape to a dot with border results in a very clogged visualization. It is more interesting to add another layer of black cells underneath the real plotting layer, so that only the cells on the edges will be visible, thus forming an outline border.\nWhile this greatly increases the plot size, it is a trade-off one can consider when making a final figure for a publication. This behavior can be accessed via the following parameters:\n\n\nplot_cell_borders: Whether to plot the cell borders (TRUE) or not (FALSE).\n\nborder.size: Size of the dots used for the cell borders.\n\nborder.color: Color of the dots used for the cell borders.\n\nborder.density: Controls how many cells are used to generate the borders. A value between 0 and 1`. It computes a 2D kernel density of the cells in the dimensional reduction embedding and based on this cells falling below the border.density quantile are excluded. This helps decreasing the added weight to the plot when plot_cell_borders = TRUE, but might result in an uneven border for the cells.\n\n\n\nShow cell borders\nBorder size\nBorder color\nBorder density\n\n\n\n\n\nNo cell borders\nCell borders\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = FALSE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDecrease cell borders\nNormal\nIncrease cell borders\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE,\n                   border.size = 1.25)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE,\n                   border.size = 2)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE,\n                   border.size = 4)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDefault border color\nRed\nBlue\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE,\n                   border.color = \"#87191c\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE,\n                   border.color = \"#243a76\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDefault border density\nDensity = 0.75\nDensity = 0.50\nDensity = 0.25\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE,\n                   border.density = 0.75)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE,\n                   border.density = 0.5)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_cell_borders = TRUE,\n                   border.density = 0.25)"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#plot-marginal-distributions",
    "href": "cheatsheets/Shared_Features.html#plot-marginal-distributions",
    "title": "Shared features across functions",
    "section": "Plot marginal distributions",
    "text": "Plot marginal distributions\nIn some cases, it is also possible to plot marginal distributions of the density of the values in a scatter plot across a given axis. This is used by some functions in SCpubr and the functionality can be accessed by:\n\n\nplot_marginal_distributions: Whether to plot marginal distributions (TRUE) or not (FALSE).\n\nmarginal.type: Type of distribution to plot. Can be one of: density, histogram, boxplot, violin, densigram.\n\nmarginal.size: Size ratio between the main and marginal plots.\n\nmarginal.group: Whether to split the marginal plot by the current identities (TRUE) or not (FALSE).\n\nThere is a catch: marginal distributions cannot be computed alongside split.by or plot_cell_borders or cells.highlight/idents.highlight.\n\n\nShow marginal distributions\nGroup by identities\nType of distribution\n\n\n\n\n\nNo marginal distributions\nMarginal distributions\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_marginal_distributions = FALSE,\n                   plot_cell_borders = FALSE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_marginal_distributions = TRUE,\n                   plot_cell_borders = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMarginal group = TRUE\nMarginal group = FALSE\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_marginal_distributions = TRUE,\n                   plot_cell_borders = FALSE,\n                   marginal.group = TRUE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_marginal_distributions = TRUE,\n                   plot_cell_borders = FALSE,\n                   marginal.group = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDensity\nHistogram\nBoxplot\nViolin\nDensigram\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_marginal_distributions = TRUE,\n                   plot_cell_borders = FALSE,\n                   marginal.type = \"density\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_marginal_distributions = TRUE,\n                   plot_cell_borders = FALSE,\n                   marginal.type = \"histogram\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_marginal_distributions = TRUE,\n                   plot_cell_borders = FALSE,\n                   marginal.type = \"boxplot\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_marginal_distributions = TRUE,\n                   plot_cell_borders = FALSE,\n                   marginal.type = \"violin\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_marginal_distributions = TRUE,\n                   plot_cell_borders = FALSE,\n                   marginal.type = \"densigram\")"
  },
  {
    "objectID": "cheatsheets/Shared_Features.html#plot-density-contours-in-dimensional-reduction-visualizations",
    "href": "cheatsheets/Shared_Features.html#plot-density-contours-in-dimensional-reduction-visualizations",
    "title": "Shared features across functions",
    "section": "Plot density contours in dimensional reduction visualizations",
    "text": "Plot density contours in dimensional reduction visualizations\nStrictly pertaining to dimensional reduction visualizations, one can also plot density contour lines in these plots:\n\n\nplot_density_contour: Whether to plot the density contours (TRUE) or not (FALSE).\n\ncontour.position: Whether to place the contour layer on top or bottom of the rest of the layers (this will make some of the lines visible or not).\n\ncontour.color: Color of the lines that draw the contour.\n\ncontour_expand_axes: Whether to increase the limits of the X and Y axes to make the contours fit the plot. This is a number between 0 and 1 and represents how much in proportion the axes should be expanded.\n\n\n\nShow density contours\nPosition of the contours\nColor of the contours\nExpand the axes\n\n\n\n\n\nNo density contours\nDensity contours\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_density_contour = FALSE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_density_contour = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPosition = top\nDensity contours\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_density_contour = TRUE,\n                   contour.position = \"top\")\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_density_contour = TRUE,\n                   contour.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDefault contour color\nBlack\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_density_contour = TRUE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_density_contour = TRUE,\n                   contour.color = \"black\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDonâ€™t expand axes\nExpand axes\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_density_contour = TRUE)\n\n\n\n\n\n\n\n\n\n\nCodeSCpubr::do_DimPlot(sample = sample,\n                   plot_density_contour = TRUE,\n                   contour_expand_axes = 0.5)"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#regular-dimplot",
    "href": "cheatsheets/DimPlots.html#regular-dimplot",
    "title": "do_DimPlot()",
    "section": "Regular DimPlot",
    "text": "Regular DimPlot\n\nSCpubr::do_DimPlot(sample = sample)"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#group-by-a-variable",
    "href": "cheatsheets/DimPlots.html#group-by-a-variable",
    "title": "do_DimPlot()",
    "section": "Group by a variable",
    "text": "Group by a variable\n\nSCpubr::do_DimPlot(sample = sample,\n                   group.by = \"annotation\")"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#split-by-a-variable",
    "href": "cheatsheets/DimPlots.html#split-by-a-variable",
    "title": "do_DimPlot()",
    "section": "Split by a variable",
    "text": "Split by a variable\n\nSCpubr::do_DimPlot(sample = sample,\n                   split.by = \"annotation\")"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#group-by-a-variable-and-split-by-a-second-variable",
    "href": "cheatsheets/DimPlots.html#group-by-a-variable-and-split-by-a-second-variable",
    "title": "do_DimPlot()",
    "section": "Group by a variable and split by a second variable",
    "text": "Group by a variable and split by a second variable\n\nSCpubr::do_DimPlot(sample = sample,\n                   group.by = \"seurat_clusters\",\n                   split.by = \"annotation\")"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#restrict-the-identities-shown-to-a-subset.",
    "href": "cheatsheets/DimPlots.html#restrict-the-identities-shown-to-a-subset.",
    "title": "do_DimPlot()",
    "section": "Restrict the identities shown to a subset.",
    "text": "Restrict the identities shown to a subset.\n\nSCpubr::do_DimPlot(sample = sample,\n                   idents.keep = c(\"0\", \"2\"))"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#highlight-cells",
    "href": "cheatsheets/DimPlots.html#highlight-cells",
    "title": "do_DimPlot()",
    "section": "Highlight cells",
    "text": "Highlight cells\n\n# Highlight a given set of cells\nSCpubr::do_DimPlot(sample = sample,\n                   cells.highlight = sample(colnames(sample), 100))\n\n\n\n\n\n\n\n\n# Highlight a given identity from Seurat::Idents(sample).\nSCpubr::do_DimPlot(sample = sample,\n                   idents.highlight = \"0\")\n\n\n\n\n\n\n\nA combination of cells.highlight and idents.hightlight also works!"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#select-a-dimensional-reduction-embedding",
    "href": "cheatsheets/DimPlots.html#select-a-dimensional-reduction-embedding",
    "title": "do_DimPlot()",
    "section": "Select a dimensional reduction embedding",
    "text": "Select a dimensional reduction embedding\n\nSCpubr::do_DimPlot(sample = sample,\n                   reduction = \"pca\")"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#select-which-dimensions-to-plot",
    "href": "cheatsheets/DimPlots.html#select-which-dimensions-to-plot",
    "title": "do_DimPlot()",
    "section": "Select which dimensions to plot",
    "text": "Select which dimensions to plot\n\nSCpubr::do_DimPlot(sample = sample,\n                   reduction = \"pca\",\n                   dims = c(1, 2))\n\n\n\n\n\n\n\nNote that, by default, the dimensional reduction of choice is the lastest computed in the Seurat object."
  },
  {
    "objectID": "cheatsheets/DimPlots.html#add-back-the-axes",
    "href": "cheatsheets/DimPlots.html#add-back-the-axes",
    "title": "do_DimPlot()",
    "section": "Add back the Axes",
    "text": "Add back the Axes\n\nSCpubr::do_DimPlot(sample = sample,\n                   plot.axes = TRUE)"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#label-the-clusters",
    "href": "cheatsheets/DimPlots.html#label-the-clusters",
    "title": "do_DimPlot()",
    "section": "Label the clusters",
    "text": "Label the clusters\n\n# Label the clusters - label geom.\nSCpubr::do_DimPlot(sample = sample,\n                   label = TRUE)\n\n\n\n\n\n\n\n\n# Label the clusters - text geom.\nSCpubr::do_DimPlot(sample = sample,\n                   label = TRUE,\n                   label.box = FALSE)"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#label-the-clusters-and-repel-the-labels",
    "href": "cheatsheets/DimPlots.html#label-the-clusters-and-repel-the-labels",
    "title": "do_DimPlot()",
    "section": "Label the clusters and repel the labels",
    "text": "Label the clusters and repel the labels\n\n# Label the clusters - label geom.\nSCpubr::do_DimPlot(sample = sample,\n                   label = TRUE,\n                   repel = TRUE)\n\n\n\n\n\n\n\n\n# Label the clusters - text geom.\nSCpubr::do_DimPlot(sample = sample,\n                   label = TRUE,\n                   label.box = FALSE,\n                   repel = TRUE)"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#modify-the-color-and-fill-of-labels",
    "href": "cheatsheets/DimPlots.html#modify-the-color-and-fill-of-labels",
    "title": "do_DimPlot()",
    "section": "Modify the color and fill of labels",
    "text": "Modify the color and fill of labels\n\n# Label the clusters - modify the color of the text and label border..\nSCpubr::do_DimPlot(sample = sample,\n                   label = TRUE,\n                   repel = TRUE,\n                   label.color = \"blue\")\n\n\n\n\n\n\n\n\n# Label the clusters - modify the fill of the labels.\nSCpubr::do_DimPlot(sample = sample,\n                   label = TRUE,\n                   repel = TRUE,\n                   label.color = \"yellow\",\n                   label.fill = \"black\")"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#change-the-default-colors",
    "href": "cheatsheets/DimPlots.html#change-the-default-colors",
    "title": "do_DimPlot()",
    "section": "Change the default colors",
    "text": "Change the default colors\n\n# Define a set of colors.\ncolors &lt;- c(\"0\" = \"#001219\",\n            \"1\" = \"#005f73\",\n            \"2\" = \"#0a9396\",\n            \"3\" = \"#94d2bd\",\n            \"4\" = \"#e9d8a6\",\n            \"5\" = \"#ee9b00\",\n            \"6\" = \"#ca6702\",\n            \"7\" = \"#bb3e03\",\n            \"8\" = \"#ae2012\",\n            \"9\" = \"#9b2226\")\n\n# Label the clusters - text geom.\nSCpubr::do_DimPlot(sample = sample,\n                   colors.use = colors)"
  },
  {
    "objectID": "cheatsheets/DimPlots.html#and-more",
    "href": "cheatsheets/DimPlots.html#and-more",
    "title": "do_DimPlot()",
    "section": "And more!",
    "text": "And more!\nThere are many synergies across functions. Have a look at the section Shared features across functions!"
  },
  {
    "objectID": "cheatsheets/BarPlots.html#group-by-a-variable",
    "href": "cheatsheets/BarPlots.html#group-by-a-variable",
    "title": "do_BarPlot()",
    "section": "Group by a variable",
    "text": "Group by a variable\n\nSCpubr::do_BarPlot(sample, \n                   group.by = \"seurat_clusters\")"
  },
  {
    "objectID": "cheatsheets/BarPlots.html#split-by-a-variable",
    "href": "cheatsheets/BarPlots.html#split-by-a-variable",
    "title": "do_BarPlot()",
    "section": "Split by a variable",
    "text": "Split by a variable\n\nSCpubr::do_BarPlot(sample, \n                   group.by = \"seurat_clusters\",\n                   split.by = \"modified_orig.ident\")"
  },
  {
    "objectID": "cheatsheets/BarPlots.html#plot-proportions",
    "href": "cheatsheets/BarPlots.html#plot-proportions",
    "title": "do_BarPlot()",
    "section": "Plot proportions",
    "text": "Plot proportions\n\nSCpubr::do_BarPlot(sample, \n                   group.by = \"seurat_clusters\",\n                   split.by = \"modified_orig.ident\",\n                   position = \"fill\")"
  },
  {
    "objectID": "cheatsheets/BarPlots.html#add-total-number-of-counts",
    "href": "cheatsheets/BarPlots.html#add-total-number-of-counts",
    "title": "do_BarPlot()",
    "section": "Add total number of counts",
    "text": "Add total number of counts\n\nSCpubr::do_BarPlot(sample, \n                   group.by = \"seurat_clusters\",\n                   split.by = \"modified_orig.ident\",\n                   position = \"fill\",\n                   add.n = TRUE)"
  }
]