[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SCpubr",
    "section": "",
    "text": "About this package\n This package aims to provide a streamlined way of generating publication ready plots for known Single-Cell trascriptomics in a “publication ready” format (SCpubr). This is, the aim is to generate with minimal effort plots with the highest quality possible, that can be used right away or with minimal modifications for a research article."
  },
  {
    "objectID": "01-Installation-guide.html",
    "href": "01-Installation-guide.html",
    "title": "Installation guide",
    "section": "",
    "text": "This package can be installed using the following commands:\n\n# From CRAN - Official release:\ninstall.packages(\"SCpubr\")\n\n# From GitHub - Latest stable development version:\nif(!requireNamespace(\"devtools\", quietly = TRUE)){\n  install.packages(\"devtools\") # If not installed.\n}\n\ndevtools::install_github(\"enblacar/SCpubr\", ref = \"v1.1.1-dev-stable\")\n\nFurther packages are needed in order to run the different functions:\n\n# Install CRAN packages.\ncran_packages <- c(\"assertthat\",\n                   \"circlize\",\n                   \"colorspace\",\n                   \"dplyr\",\n                   \"ggbeeswarm\",\n                   \"ggdist\",\n                   \"ggExtra\",\n                   \"ggnewscale\",\n                   \"ggplot2\",\n                   \"ggplotify\",\n                   \"ggrastr\",\n                   \"ggrepel\",\n                   \"ggridges\",\n                   \"ggsignif\",\n                   \"graphics\",\n                   \"magrittr\",\n                   \"patchwork\",\n                   \"pheatmap\",\n                   \"plyr\",\n                   \"rlang\",\n                   \"scales\",\n                   \"scattermore\",\n                   \"Seurat\",\n                   \"tibble\",\n                   \"tidyr\",\n                   \"forcats\",\n                   \"Matrix\",\n                   \"purrr\",\n                   \"stringr\",\n                   \"svglite\",\n                   \"viridis\")\n\ninstall.packages(cran_packages)\n\n# Install bioconductor packages.\nbioconductor_packages <- c(\"AUCell\",\n                           \"ComplexHeatmap\",\n                           \"clusterProfiler\",\n                           \"enrichplot\",\n                           \"infercnv\",\n                           \"Nebulosa\",\n                           \"UCell\")\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(bioconductor_packages)\n\n# Install github packages.\ngithub_packages <- c(\"ggsankey\",\n                     \"liana\",\n                     \"monocle3\")\n\nif (!requireNamespace(\"remotes\", quietly = TRUE))\n    install.packages(\"remotes\")\n\nremotes::install_github(github_packages)\n\nOne can check the dependencies by running SCpubr::state_dependencies()."
  },
  {
    "objectID": "02-Dataset.html",
    "href": "02-Dataset.html",
    "title": "Dataset used",
    "section": "",
    "text": "Through this manual we are going to use a publicly available dataset containing 10K raw cells. The following code is used to generate a Seurat object ready for plotting.\n\ncounts_path <- \"path_to_count_matrix\"\n\n# Path count matrix.\ncounts <- Seurat::Read10X(counts_path)\n\n# Create Seurat object.\nsample <- Seurat::CreateSeuratObject(counts = counts, project = \"10K_pbmc\")\n\n# Compute percentage of mithochondrial RNA.\nsample <- Seurat::PercentageFeatureSet(sample, pattern = \"^MT-\", col.name = \"percent.mt\")\n\n# Compute QC.\nmask1 <- sample$nCount_RNA >= 1000\nmask2 <- sample$nFeature_RNA >= 500\nmask3 <- sample$percent.mt <= 20\nmask <- mask1 & mask2 & mask3\nsample <- sample[, mask]\n\n# Normalize.\nsample <- Seurat::SCTransform(sample)\n\n# Dimensional reduction.\nsample <- Seurat::RunPCA(sample)\nsample <- Seurat::RunUMAP(sample, dims = 1:30)\n\n# Find clusters.\nsample <- Seurat::FindNeighbors(sample, dims = 1:30)\nsample <- Seurat::FindClusters(sample, resolution = 0.2)"
  },
  {
    "objectID": "03-DimPlots.html#basic-usage",
    "href": "03-DimPlots.html#basic-usage",
    "title": "\n1  Dim plots\n",
    "section": "\n1.1 Basic usage",
    "text": "1.1 Basic usage\nSCpubr makes use of the default output and Seurat::DimPlot() and further modifies it to achieve the following result.\n\n# Seurat's DimPlot.\np1 <- Seurat::DimPlot(sample)\n\n# SCpubr's DimPlot.\np2 <- SCpubr::do_DimPlot(sample = sample)\n\np <- p1 | p2\np\n\n\n\nSCpubr DimPlot vs Seurat DimPlot."
  },
  {
    "objectID": "03-DimPlots.html#modifying-axes-behavior",
    "href": "03-DimPlots.html#modifying-axes-behavior",
    "title": "\n1  Dim plots\n",
    "section": "\n1.2 Modifying axes behavior",
    "text": "1.2 Modifying axes behavior\nEven though axes are removed from UMAP reductions, the title for the axes is kept for any other reduction used. The same is applied for UMAP if the default dimension order is altered.\n\n# Example using PCA reduction.\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         reduction = \"pca\")\n\n# Example using a non-canonical set of dimensions.\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         dims = c(2, 1))\n\np <- p1 | p2\np\n\n\n\nAxes titles come back whenever it is not UMAP_1 vs UMAP_2.\n\n\n\n\nFurthermore, this behavior can be completely cancelled by using plot.axes = TRUE.\n\n# Bring back the Axes.\np <- SCpubr::do_DimPlot(sample = sample,\n                        plot.axes = TRUE)\np\n\n\n\nBring back the axes."
  },
  {
    "objectID": "03-DimPlots.html#modify-legend-appearance",
    "href": "03-DimPlots.html#modify-legend-appearance",
    "title": "\n1  Dim plots\n",
    "section": "\n1.3 Modify legend appearance",
    "text": "1.3 Modify legend appearance\nWe can change the legend’s number of columns or rows with legend.ncol and legend.nrow.\n\n# Modify the number of columns in the legend.\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.ncol = 2)\n\n# Modify the number of rows in the legend.\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.nrow = 3)\n\np <- p1 | p2 \np\n\n\n\nModify legend rows and colums.\n\n\n\n\nYou can also alter how the legend is being “filled” with legend.byrow = TRUE/FALSE. This is, by default the legend items are being placed column-wise. If we set legend.byrow = FALSE, the legend items are placed row-wise.\n\n# Fill the legend by column.\np1 <- SCpubr::do_DimPlot(sample = sample,\n                         legend.byrow = FALSE)\n\n# Fill the legend by rows.\np2 <- SCpubr::do_DimPlot(sample = sample,\n                         legend.byrow = TRUE)\n\np <- p1 | p2 \np\n\n\n\nModify legend item placement behavior."
  },
  {
    "objectID": "03-DimPlots.html#label-the-clusters",
    "href": "03-DimPlots.html#label-the-clusters",
    "title": "\n1  Dim plots\n",
    "section": "\n1.4 Label the clusters",
    "text": "1.4 Label the clusters\nIn some cases, especially early on in the analysis where we do only have numbers as cluster names, we might want to remove the legend entirely, and instead plot labels on top of each cluster. This is achieved by using label = TRUE.\n\n# Put labels on top of the clusters.\np <- SCpubr::do_DimPlot(sample, \n                     label = TRUE)\np\n\n\n\nLabels on top of the clusters.\n\n\n\n\nThese labels are, in essence the result of applying ggplot2::geom_label() on the plot. However, we might also want to have them as pure text instead of the labels. We can achieve that by providing label.box = FALSE.\n\n# Labels as text\np <- SCpubr::do_DimPlot(sample = sample, \n                        label = TRUE,\n                        label.box = FALSE)\np\n\n\n\nLabels as text.\n\n\n\n\nHowever, we can play further with other parameters of the function such as label.color which will provide a different color for the text inside the labels:\n\n# Change the color of the label text.\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.color = \"black\")\n\n# Change the color of the text.\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.color = \"black\",\n                         label.box = FALSE)\np <- p1 | p2\np\n\n\n\nChange label/text color.\n\n\n\n\nAlso, we can modify the size of the labels/text by using label.size paramter:\n\n# Change the size of the label text.\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.color = \"black\",\n                         label.size = 6)\n\n# Change the size of the text.\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.color = \"black\",\n                         label.box = FALSE,\n                         label.size = 6)\np <- p1 | p2\np\n\n\n\nChange label/text size\n\n\n\n\nFinally, if the labels/text are overlapping one to another, we can try to fix that by repelling the labels from one to another. We can achieve this by using repel = TRUE:\n\n# Repel the labels.\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.color = \"black\",\n                         repel = TRUE)\n\n# Repel the text.\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         label.color = \"black\",\n                         label.box = FALSE,\n                         repel = TRUE)\np <- p1 | p2\np\n\n\n\nRepel the labels/text."
  },
  {
    "objectID": "03-DimPlots.html#legend-behavior",
    "href": "03-DimPlots.html#legend-behavior",
    "title": "\n1  Dim plots\n",
    "section": "\n1.5 Legend behavior",
    "text": "1.5 Legend behavior\nSometimes, the legend is completely redundant, as we are already displaying the same information as labels in the text. Othertimes, we just want to remove it. In any case, this can be achieved by using legend.position = \"none\".\n\n# Remove the legend from the plot.\np <- SCpubr::do_DimPlot(sample = sample, \n                        label = TRUE, \n                        legend.position = \"none\")\np\n\n\n\nRemove the legend.\n\n\n\n\nIn other cases, we might just be interested in modifying the placement of the legend. This can also be achieved by using legend.position = \"bottom/top/right/left\":\n\n# Top\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.position = \"top\")\n\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.position = \"bottom\")\n\np3 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.position = \"left\")\n\np4 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.position = \"right\")\n\np <- (p1 | p2) / (p3 | p4)\np\n\n\n\nModify legend placement.\n\n\n\n\nFinally, we can add a custom legend title to the plot by using legend.title parameter:\n\n# Add a legend title.\np <- SCpubr::do_DimPlot(sample = sample, \n                        legend.title = \"My clusters\")\np\n\n\n\nAdd a legend.title.\n\n\n\n\nWe can also control the position of the legend title by using legend.title.position:\n\n# Top\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.title = \"My clusters\",\n                         legend.title.position = \"top\")\n\n# Bottom\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.title = \"My clusters\",\n                         legend.title.position = \"bottom\")\n\n# Left\np3 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.title = \"My clusters\",\n                         legend.title.position = \"left\")\n\n# Right\np4 <- SCpubr::do_DimPlot(sample = sample, \n                         legend.title = \"My clusters\",\n                         legend.title.position = \"right\")\n\np <- (p1 | p2) / (p3 | p4)\np\n\n\n\nModify legend title placement."
  },
  {
    "objectID": "03-DimPlots.html#changing-the-order-of-plotting",
    "href": "03-DimPlots.html#changing-the-order-of-plotting",
    "title": "\n1  Dim plots\n",
    "section": "\n1.6 Changing the order of plotting",
    "text": "1.6 Changing the order of plotting\nBy default, cells in SCpubr::do_DimPlot() are randomly plotted by using shuffle = TRUE. This is done as the default behavior of Seurat::DimPlot() is to plot the cells based on the factor levels of the identities. Sometimes, this way of plotting results in some clusters not being visible as another one is on top of it. However, this behavior might be intended, and even more, we would like a specific identity to stand out from the rest. This can be achieved by providing to order parameter either a vector with all the identities ordered however you want, or just some of the identities, which will then be plotted on top of the rest. However, it is still not clear whether using order alongside shuffle = TRUE have unexpected side effects. For this, please use it alongside shuffle = FALSE. For the following example, we are going to test:\n\nWe are going to bring cluster 5 to the front.\n\norder with one value or all values.\n\norder with shuffle = TRUE/FALSE.\nWe will increase the dot size to better see cells in cluster 7, as this data set has a lack of overlapping clusters..\n\n\n# Regular SCpubr DimPlot.\np1 <- SCpubr::do_DimPlot(sample = sample,\n                         reduction = \"pca\",\n                         plot.title = \"Normal DimPlot\")\n\n# Using order with one value and shuffle = TRUE.\np2 <- SCpubr::do_DimPlot(sample = sample,\n                         shuffle = TRUE,\n                         order = \"5\",\n                         reduction = \"pca\",\n                         plot.title = \"shuffle = TRUE\")\n\n# Using order with one value and shuffle = FALSE.\np3 <- SCpubr::do_DimPlot(sample = sample,\n                         shuffle = FALSE,\n                         order = \"5\",\n                         reduction = \"pca\",\n                         plot.title = \"shuffle = FALSE\")\n\n# Using order with all values.\np4 <- SCpubr::do_DimPlot(sample = sample,\n                         shuffle = FALSE,\n                         order = c(\"5\", \"8\", \"4\",\n                                   \"9\", \"3\", \"1\",\n                                   \"6\", \"0\", \"7\", \"2\"),\n                         reduction = \"pca\",\n                         plot.title = \"shuffle = FALSE all identities\")\n\np <- (p1 | p2) / (p3 | p4)\np\n\n\n\nModifying order of plotted identities in a DimPlot\n\n\n\n\nWe can see that cluster 5 always plots on top of cluster 0 when order is set. While still not clear how order and shuffle interact, it is apparent that using order cancels the original behavior of shuffle. Therefore, if both order and shuffle are set, SCpubr::do_DimPlot() will throw a warning."
  },
  {
    "objectID": "03-DimPlots.html#highlighting-cells",
    "href": "03-DimPlots.html#highlighting-cells",
    "title": "\n1  Dim plots\n",
    "section": "\n1.7 Highlighting cells",
    "text": "1.7 Highlighting cells\nOne of the nice features of Seurat::DimPlot() is the possibility of highlighting a certain group of cells in the plot. This is achieved by using the cells.highligh parameter. This is how the default plot looks like and SCpubr::do_DimPlot()’s take on it:\n\ncells.use <- sample(x = colnames(sample), \n                    size = 1500)\n\n# Compare Seurat and SCpubr way of highlighting cells.\np1 <- Seurat::DimPlot(sample, \n                      cells.highlight = cells.use)\n\np2 <- SCpubr::do_DimPlot(sample = sample,\n                         cells.highlight = cells.use)\n\np <- p1 | p2\np\n\n\n\nHighlighting cells, a comparison.\n\n\n\n\nOne can also change the color of the highligted cells by providing single color to colors.use and the color of the not selected cells with na.value:\n\n# Change color of highlighted and non-highlighted cells.\np <- SCpubr::do_DimPlot(sample = sample, \n                        cells.highlight = cells.use,\n                        colors.use = \"black\",\n                        na.value = \"grey90\")\np\n\n\n\nChange default color of highlighted and non-highlighted cells.\n\n\n\n\nBy default, the size of all cells in SCpubr::do_DimPlot() is the same. However, the size of the highlighted dots can be modified with the parameter sizes.highlight.\n\n# Increase the size of the highlighted cells.\np <- SCpubr::do_DimPlot(sample = sample, \n                        cells.highlight = cells.use, \n                        sizes.highlight = 1)\np\n\n\n\nIncrease dot size of highlighted cells.\n\n\n\n\nWe can also highlight whole identities with idents.highlight parameter. For this, just provide the desired identities to be selected. It can also work in combination with cells.highlight.\n\n# Using cells.highlight.\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         cells.highlight = cells.use)\n\n# Using idents.highlight.\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         idents.highlight = c(\"6\"))\n\n# Using both.\np3 <- SCpubr::do_DimPlot(sample = sample, \n                         cells.highlight = cells.use, \n                         idents.highlight = c(\"6\"))\n\np <- p1 | p2 | p3\np\n\n\n\nUsing a combination of cells.highlight and idents.highlight."
  },
  {
    "objectID": "03-DimPlots.html#restrict-the-identitites-displayed",
    "href": "03-DimPlots.html#restrict-the-identitites-displayed",
    "title": "\n1  Dim plots\n",
    "section": "\n1.8 Restrict the identitites displayed",
    "text": "1.8 Restrict the identitites displayed\nSometimes, we are interested in showing only some of the identities or groups in our sample. Instead of highlighting cells, we still want to keep the original colors and legend. For this use case, one might be tempted to just subset the sample as follows:\n\n# Subset desired identities in a DimPlot.\np <- SCpubr::do_DimPlot(sample = sample[, sample$seurat_clusters %in% c(\"0\", \"5\")])\n\np\n\n\n\nSubsetting the Seurat object to restrict the identities shown.\n\n\n\n\nHowever, we end up losing the UMAP silhouette. For this, SCpubr::do_DimPlot() introduces idents.keep parameter, for which you can provide a vector with the identities you want to keep. This will assign to the rest of the cells a value of NA and they will be colored according to na.value parameter:\n\n# Select identities with idents.keep.\np1 <- SCpubr::do_DimPlot(sample = sample,\n                         idents.keep = c(\"0\", \"5\"))\n\n# Also, non-selected cells's color can be modified.\np2 <- SCpubr::do_DimPlot(sample = sample,\n                         idents.keep = c(\"0\", \"5\"),\n                         na.value = \"grey50\")\np <- p1 | p2\np\n\n\n\nSelect the identities to display."
  },
  {
    "objectID": "03-DimPlots.html#group-by-another-metadata-variable",
    "href": "03-DimPlots.html#group-by-another-metadata-variable",
    "title": "\n1  Dim plots\n",
    "section": "\n1.9 Group by another metadata variable",
    "text": "1.9 Group by another metadata variable\nSo far, all the DimPlots displayed have shown the identities as the ones that are currently set in the object. This can be consulted by using Seurat::Idents(sample). However, naturally, we might want to display different metadata variables. This can be easily achieved by using group.by parameter:\n\n# Generate another metadata variable to group the cells by.\nsample$annotation <- sample(c(\"A\", \"B\", \"C\"), ncol(sample), replace = TRUE)\n\n# Group by another metadata variable.\np1 <- SCpubr::do_DimPlot(sample, \n                         group.by = \"seurat_clusters\")\n\np2 <- SCpubr::do_DimPlot(sample, \n                         group.by = \"annotation\")\n\np <- p1 | p2\np\n\n\n\nGroup by another metadata variable."
  },
  {
    "objectID": "03-DimPlots.html#splitting-by-a-category",
    "href": "03-DimPlots.html#splitting-by-a-category",
    "title": "\n1  Dim plots\n",
    "section": "\n1.10 Splitting by a category",
    "text": "1.10 Splitting by a category\nAnother useful parameter of Seurat::DimPlot is split.by, which allows you to split your DimPlot into multiple panels, each one containing a different unique value of the metadata variable you have provided to the argument. One can understand this as using the group.by parameter and then splitting the resulting DimPlot into different panels. In this example, we are going to use the different clusters as an example. This is how it looks by default:\n\n# Seurat's DimPlot using split.by\np <- Seurat::DimPlot(sample, \n                     split.by = \"seurat_clusters\", \n                     ncol = 5)\n\np\n\n\n\nUsing split.by in Seurat.\n\n\n\n\nAs can be observed, this plot accomplish the task of separating the cells into each panel, but the approach followed actually makes interpretation difficult. Clusters such as Cluster 9, with fewer cells, tell pretty much nothing. Besides, losing the UMAP silhouette is a major downside of this approach. This is where SCpubr focus on. It generates as many plots as unique values in the metadata to split the plot by, but uses cells.highlight instead, which keeps the rest of cells greyed out according to na.value color. This is how it looks:\n\n# SCpubr's DimPlot using split.by\np <- SCpubr::do_DimPlot(sample, \n                        split.by = \"seurat_clusters\", \n                        ncol = 5, \n                        legend.position = \"none\",\n                        font.size = 24)\n\np\n\n\n\nUsing split.by in SCpubr.\n\n\n\n\nThis way, we can see that clusters such as Cluster 7 are way more disperse than the rest, accounting not only for standalone groups of cells but also blending into other bigger clusters.\nIf we are interested only in a subset of the possible values, we can use idents.keep alongside a vector containing the values to keep from the unique values in split.by:\n\n# Using split.by and restricting the number of output plots with idents.keep.\np <- SCpubr::do_DimPlot(sample, \n                        split.by = \"seurat_clusters\", \n                        ncol = 3, \n                        idents.keep = c(\"0\", \"1\", \"7\"),\n                        legend.position = \"none\",\n                        font.size = 24)\n\np\n\n\n\nSelect only some identities in split.by"
  },
  {
    "objectID": "03-DimPlots.html#group-by-a-variable-but-split-by-another",
    "href": "03-DimPlots.html#group-by-a-variable-but-split-by-another",
    "title": "\n1  Dim plots\n",
    "section": "\n1.11 Group by a variable but split by another",
    "text": "1.11 Group by a variable but split by another\nFinally, but also importantly, users might want to split the UMAP using split.by, while also grouping (coloring) the values by another variable using group.by. Using these two parameters in combination yields the following:\n\n# Using split.by and group.by in combination.\nsample$orig.ident <- sample(c(\"A\", \"B\", \"C\"), \n                            ncol(sample), \n                            replace = TRUE, \n                            prob = c(0.05, 0.1, 0.85))\n\np <- SCpubr::do_DimPlot(sample, \n                        group.by = \"seurat_clusters\",\n                        split.by = \"orig.ident\", \n                        font.size = 24)\n\np\n\n\n\nSplit by a variable but color by another one.\n\n\n\n\nActually, the user might want to change the color of the highlighted cells in this split DimPlot. This is achieved by using colors.use parameter and providing either a vector of valid color representations of equal length to unique values in split.by or just a single color to use in all panels.\n\n# Create a color scale for the unique values in seurat clusters.\ncolors <- c(\"0\" = \"#001219\",\n            \"1\" = \"#005f73\",\n            \"2\" = \"#0a9396\",\n            \"3\" = \"#94d2bd\",\n            \"4\" = \"#e9d8a6\",\n            \"5\" = \"#ee9b00\",\n            \"6\" = \"#ca6702\",\n            \"7\" = \"#bb3e03\",\n            \"8\" = \"#ae2012\",\n            \"9\" = \"#9b2226\")\n\n# Use a custom set of colors, one for each identity.\np1 <- SCpubr::do_DimPlot(sample, \n                         split.by = \"seurat_clusters\", \n                         ncol = 5, \n                         legend.position = \"none\", \n                         colors.use = colors,\n                         font.size = 24)\n\n# Use the same color for all identities.\np2 <- SCpubr::do_DimPlot(sample, \n                         split.by = \"seurat_clusters\", \n                         ncol = 5, \n                         legend.position = \"none\",\n                         colors.use = \"#008080\",\n                         font.size = 24)\n                         \np <- p1 / p2\np\n\n\n\nChange default colors."
  },
  {
    "objectID": "04-FeaturePlots.html#basic-usage",
    "href": "04-FeaturePlots.html#basic-usage",
    "title": "\n2  Feature plots\n",
    "section": "\n2.1 Basic usage",
    "text": "2.1 Basic usage\nThis is SCpubr’s take on Seurat::FeaturePlot():\n\n# Seurat's Feature Plot.\np1 <- Seurat::FeaturePlot(sample, \n                          features = \"PC_1\")\n\n# SCpubr's Feature Plot.\np2 <- SCpubr::do_FeaturePlot(sample = sample,\n                             features = \"PC_1\")\n\np <- p1 | p2\np\n\n\n\nSCpubr FeaturePlot vs Seurat FeaturePlot\n\n\n\n\nBy default, SCpubr::do_FeaturePlot() enlarges the dots a bit and modifies the legend, to better stand out. Even though axes are removed from UMAP reductions, the title for the axes is kept for any other reduction used. The same is applied for UMAP if the default dimension order is altered.\n\n# Use case with PCA embedding.\np1 <- SCpubr::do_FeaturePlot(sample = sample, \n                             features = \"CD14\",\n                             plot.title = \"Plotting PCA coordinates\",\n                             reduction = \"pca\")\n\n# Use case with non-canonical dimensions.                             \np2 <- SCpubr::do_FeaturePlot(sample = sample, \n                             features = \"CD14\",\n                             plot.title = \"Plotting UMAP coordinates in a different order\",\n                             dims = c(2, 1))\n\np <- p1 | p2\np\n\n\n\nShow axes titles."
  },
  {
    "objectID": "04-FeaturePlots.html#multiple-features",
    "href": "04-FeaturePlots.html#multiple-features",
    "title": "\n2  Feature plots\n",
    "section": "\n2.2 Multiple features",
    "text": "2.2 Multiple features\nSCpubr::do_FeaturePlot() can tackle multiple queries at the same time. Plots can be rearranged as desired with ncol parameter:\n\np <- SCpubr::do_FeaturePlot(sample, features = c(\"nCount_RNA\", \n                                                 \"nFeature_RNA\", \n                                                 \"percent.mt\", \n                                                 \"CD14\"), \n                            plot.title = \"A collection of features\", \n                            ncol = 2)\n\np\n\n\n\nPlot multiple features at the same time."
  },
  {
    "objectID": "04-FeaturePlots.html#limit-the-color-scale-to-a-max-and-min-values",
    "href": "04-FeaturePlots.html#limit-the-color-scale-to-a-max-and-min-values",
    "title": "\n2  Feature plots\n",
    "section": "\n2.3 Limit the color scale to a max and min values",
    "text": "2.3 Limit the color scale to a max and min values\nSimilar to what Seurat does with the min.cutoff and max.cutoff parameter, this feature will be availble in a future update. In the meantime, please refer to this hotfix."
  },
  {
    "objectID": "04-FeaturePlots.html#working-with-subsets-of-cells",
    "href": "04-FeaturePlots.html#working-with-subsets-of-cells",
    "title": "\n2  Feature plots\n",
    "section": "\n2.4 Working with subsets of cells",
    "text": "2.4 Working with subsets of cells\nOne of the things that can be misleading is that it could be the case that a very specific subset of cells are driving the ends of the color scales. Let’s say that we have identified that clusters 2, 5, and 8 are responsible for this behavior. We would like to plot the values without taking those cells into consideration. The very first thing that comes to mind is, indeed, removing the cells completely, resulting in the following:\n\ncells.plot <- colnames(sample[, !(sample$seurat_clusters %in% c(\"2\", \"5\", \"8\"))])\n\np <- SCpubr::do_FeaturePlot(sample[, cells.plot], \n                            features = c(\"CD14\"))\n\np\n\n\n\nSubsetting cells.\n\n\n\n\nHowever, this falls back to the same problem as with Seurat::DimPlot with the split.by parameter. We lose the overall context of where the cells are, as we lost the original UMAP silhouette. This can be fixed by using the cells.highlight parameter:\n\n# Using cells.highlight parameter to select the cells we want to include in the plot.\np <- SCpubr::do_FeaturePlot(sample = sample, \n                            cells.highlight = cells.plot, \n                            features = c(\"CD14\"))\n\np\n\n\n\nOnly use the designated cells.\n\n\n\n\nThis way, by adding the cells back and modifying the legend, we accomplish the desired effect. Furthermore, SCpubr::do_FeaturePlot() also accepts a vector of the identities to plot, as long as they are part of levels(seurat_object). This can be achieved by using the idents.highlight instead.\n\n# Selecting given identitites to include in the plot.\np <- SCpubr::do_FeaturePlot(sample = sample, \n                            idents.highlight = levels(sample)[!(levels(sample) %in% c(\"0\", \"2\", \"5\", \"8\"))], \n                            features = c(\"CD14\"))\n\np\n\n\n\nOnly use the designated identities."
  },
  {
    "objectID": "04-FeaturePlots.html#splitting-the-featureplot-by-a-variable",
    "href": "04-FeaturePlots.html#splitting-the-featureplot-by-a-variable",
    "title": "\n2  Feature plots\n",
    "section": "\n2.5 Splitting the FeaturePlot by a variable",
    "text": "2.5 Splitting the FeaturePlot by a variable\nIn some cases, we want to visualize a given feature, let’s say, the expression of LYN across another variable, for instance seurat_clusters. This can be achieved easily in Seurat by using the split.by parameter. For the sake of representation, let’s reduce the number of clusters.\n\n# Group clusters into three values for visualization purposes.\nsample$new_clusters <- as.character(sample$seurat_clusters)\nsample$new_clusters[sample$new_clusters %in% c(\"0\", \"1\", \"2\", \"3\")] <- \"Cluster 1\"\nsample$new_clusters[sample$new_clusters %in% c(\"4\", \"5\", \"6\")] <- \"Cluster 2\"\nsample$new_clusters[sample$new_clusters %in% c(\"7\", \"8\", \"9\")] <- \"Cluster 3\"\n\n# Seurat Feature Plot using split.by.\np <- Seurat::FeaturePlot(sample, \n                         features = \"LYN\", \n                         split.by = \"new_clusters\")\np\n\n\n\nSplit by a given variable - Seurat.\n\n\n\n\nApart from the general aesthetic discrepancies mentioned before, there are two main aspects missing. First, is the loss of the UMAP silhouette. Secondly, knowing that, by default, the color scale is shared across all the plots, we would like to know the range of values this color scale is displaying. In this two aspects is where SCpubr::do_FeaturePlot() delves into:\n\n# SCpubr Feature Plot using split.by\np <- SCpubr::do_FeaturePlot(sample = sample, \n                            features = \"LYN\", \n                            split.by = \"new_clusters\")\n\np\n\n\n\nSplit by a given variable - SCpubr.\n\n\n\n\nWe can even subset the previous plot to any set of identities in split.by we are particularly interested in. The color scale also limits itself to contain only the values in the selected identities. This can be achieved by provided a vector with the identities to split.by.idents parameter.\n\n# Using split.by.idents parameter alongside split.by.\np <- SCpubr::do_FeaturePlot(sample, \n                            features = c(\"LYN\"), \n                            split.by = \"seurat_clusters\", \n                            split.by.idents = c(\"2\", \"5\"))\n\np\n\n\n\nRestrict the identities to show when using split.by."
  },
  {
    "objectID": "04-FeaturePlots.html#subset-the-color-scale-to-a-minimum-and-maximum",
    "href": "04-FeaturePlots.html#subset-the-color-scale-to-a-minimum-and-maximum",
    "title": "\n2  Feature plots\n",
    "section": "\n2.6 Subset the color scale to a minimum and maximum",
    "text": "2.6 Subset the color scale to a minimum and maximum\nThe color scale can be restricted to minimum and maximum values using min.cutoff and max.cutoff:\n\n# Use min.cutoff and max.cutoff.\np1 <- SCpubr::do_FeaturePlot(sample, \n                             features = c(\"LYN\"))\n\np2 <- SCpubr::do_FeaturePlot(sample, \n                             features = c(\"LYN\"),\n                             min.cutoff = 1,\n                             max.cutoff = 2)\np <- p1 | p2\np\n\n\n\nSubset the color scale to a maximum and a minimum.\n\n\n\n\nHowever, it is important to note that cells outside the range of min.cutoff and max.cutoff have their values modified to either min.cutoff or max.cutoff. Therefore, it is important to take this into account when using this functionality, that the end colors of the continuous scale represent cells outside the desired range, and not the actual values. This is specially important for the values below min.cutoff, as it may seem that the cells are not expressed when they truly might be."
  },
  {
    "objectID": "04-FeaturePlots.html#apply-symmetrical-color-scales",
    "href": "04-FeaturePlots.html#apply-symmetrical-color-scales",
    "title": "\n2  Feature plots\n",
    "section": "\n2.7 Apply symmetrical color scales",
    "text": "2.7 Apply symmetrical color scales\nThere are times in which we want to color the Feature plot using a two-end continuous color scale. We can achieve this by using enforce_symmetry = TRUE:\n\n# Enforce two-end symmetrical color scale.\np1 <- SCpubr::do_FeaturePlot(sample, \n                             features = \"PC_1\",\n                             enforce_symmetry = FALSE)\n\np2 <- SCpubr::do_FeaturePlot(sample, \n                             features = \"PC_1\",\n                             enforce_symmetry = TRUE)\n\np <- p1 | p2\np\n\n\n\nUse a symmetrical color scale.\n\n\n\n\nAs one can observe, this parameters sets a scale centered around 0, with the two ends being of the same value. This allows for direct comparison between the colors."
  },
  {
    "objectID": "05-NebulosaPlots.html#basic-usage",
    "href": "05-NebulosaPlots.html#basic-usage",
    "title": "\n3  Nebulosa plots\n",
    "section": "\n3.1 Basic usage",
    "text": "3.1 Basic usage\n\np <- Nebulosa::plot_density(sample,\n                            features = \"CD14\")\np\n\n\n\nNebulosa plot.\n\n\n\n\nThis way, not only we do know which clusters are enriched in CD14, we also know the regions of it with the highest density of cells expressing it. Minor modifications, on the line of the rest of plots, are applied in SCpubr:\n\np <- SCpubr::do_NebulosaPlot(sample = sample, \n                             features = \"CD14\")\np\n\n\n\nNebulosa plot with SCpubr.\n\n\n\n\nThen, this type visualization becomes a natural partner to `Seurat::FeaturePlot()’ as not only we are able to visualize the expression of a variable, but also query the density of the surrounding cells. Here is an example:\n\np1 <- SCpubr::do_FeaturePlot(sample = sample, \n                             features = \"CD14\") \n\np2 <- SCpubr::do_NebulosaPlot(sample = sample, \n                              features = \"CD14\")\np <- p1 | p2\np\n\n\n\nComparison of a Nebulosa vs a FeaturePlot.\n\n\n\n\nNebulosa package also offers the option to query multiple features at the same time:\n\np <- SCpubr::do_NebulosaPlot(sample, \n                             features = c(\"CD14\", \"CD8A\"))\np\n\n\n\nNebulosa plot with multiple features."
  },
  {
    "objectID": "05-NebulosaPlots.html#compute-joint-densities",
    "href": "05-NebulosaPlots.html#compute-joint-densities",
    "title": "\n3  Nebulosa plots\n",
    "section": "\n3.2 Compute joint densities",
    "text": "3.2 Compute joint densities\nBut, more intriguingly, it can also compute the joint density of the features. This is achieved by parsing joint = TRUE.\n\np <- SCpubr::do_NebulosaPlot(sample = sample, \n                             features = c(\"CD14\", \"CD8A\"), \n                             joint = TRUE)\np \n\n\n\nPlot joint densities.\n\n\n\n\nIf we were interested in retrieving only the joint density plot, we can accomplish it with return_only_joint parameter. Please note that, since this will return only one plot, if wanted to modify the plot title, use plot.title instead:\n\nfeatures.use <- c(\"CD14\", \"CD8A\")\n\np <- SCpubr::do_NebulosaPlot(sample = sample, \n                             features = c(\"CD14\", \"CD8A\"), \n                             joint = TRUE, \n                             return_only_joint = TRUE,\n                             plot.title = \"Joint density CD14+-CD8A+\")\n\np\n\n\n\nPlot joint densities and return only the last plot."
  },
  {
    "objectID": "06-BeeSwarmPlots.html#using-categorical-variables",
    "href": "06-BeeSwarmPlots.html#using-categorical-variables",
    "title": "\n4  Bee Swarm plots\n",
    "section": "\n4.1 Using categorical variables",
    "text": "4.1 Using categorical variables\nLet’s say we want to focus on how much each cluster is driven by the PC_1 and PC_2. The first thought is to just use SCpubr::do_Dimplot() to plot the PCA embedding instead of the UMAP. We also query PC_3 and PC_4 to have a not-so-clear example.\n\np1 <- SCpubr::do_DimPlot(sample, \n                         reduction = \"pca\", \n                         label = TRUE, \n                         legend.position = \"none\", \n                         dims = c(1, 2)) \np2 <- SCpubr::do_DimPlot(sample, \n                         reduction = \"pca\", \n                         label = TRUE, \n                         legend.position = \"none\",\n                         dims = c(3, 4)) \n\np <- p1 | p2\np\n\n\n\nPCA embeddings in a DimPlot.\n\n\n\n\nWith this, we get right away a decent overview. Clusters 0, 5, 7 and 8 separate on PC_1 from the rest. However, in many cases this will not be clear, such as the image on the right. This is where Bee Swarm plots come in handy. This is implemented in SCpubr::do_BeeSwarmPlot(). This function needs the user to provide: - The variable to rank to feature_to_rank. - The groups to divide the plot into to group.by. - Whether the output should be colored with a categorical or continuous scale, with continuous_feature.\n\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         reduction = \"pca\", \n                         label = TRUE, \n                         legend.position = \"none\",\n                         dims = c(1, 2))\n\np2 <- SCpubr::do_DimPlot(sample = sample, \n                         reduction = \"pca\", \n                         label = TRUE, \n                         legend.position = \"none\",\n                         dims = c(3, 4)) \n\np3 <- SCpubr::do_BeeSwarmPlot(sample = sample, \n                              feature_to_rank = \"PC_1\", \n                              group.by = \"seurat_clusters\", \n                              continuous_feature = FALSE)\n\np4 <- SCpubr::do_BeeSwarmPlot(sample = sample, \n                              feature_to_rank = \"PC_4\", \n                              group.by = \"seurat_clusters\", \n                              continuous_feature = FALSE)\n\np <- (p1 | p3) / (p2 | p4)\np\n\n\n\nBee Swarm plots - Categorical\n\n\n\n\nHere, we have selected PC_1 and PC_4. We can observe how the X axis of the Bee Swarm plot displays the ordering (rank) of all of the cells across the selected feature. Focusing on PC_1, we can see that cluster 0 is completely shifted to the right on PC_1, with is nicely displayed in the Bee Swarm plot by having all of the cells also ranked high (the higher the rank, the bigger the “value” of the feature to rank, in this case, the PC_1 value). In the case of PC_4, the Bee Swarm plot nicely shows which clusters lay on the upper, lower or middle part of the PC_4.\nA very important thing to note in these kind of plots is that no cells will have the same rank. This is, imagine a scenario like PC_4, but we artificially remove clusters 0, 3, 5, 7, 8, 9, leaving only those forming a “straight line” in PC_4. The nature of this plot will also separate the remaining clusters:\n\n# Clusters to exclude.\nclusters_exclude <- c(\"0\", \"3\", \"5\", \"7\", \"8\", \"9\")\n\n# Keep the original coloring.\ncols.use <- colorspace::qualitative_hcl(length(levels(sample)), \n                                        palette = \"Dark 3\")\nnames(cols.use) <- levels(sample)\n\n# Only provide the needed colors. If more are provided, an error is thrown.\ncols.use <- cols.use[!(names(cols.use) %in% clusters_exclude)]\n\np1 <- SCpubr::do_DimPlot(sample = sample[, !(sample$seurat_clusters %in% clusters_exclude)], \n                         reduction = \"pca\", \n                         label = TRUE, \n                         legend.position = \"none\",\n                         dims = c(3, 4), \n                         colors.use = cols.use) \n\np2 <- SCpubr::do_BeeSwarmPlot(sample = sample[, !(sample$seurat_clusters %in% clusters_exclude)], \n                              feature_to_rank = \"PC_4\", \n                              group.by = \"seurat_clusters\", \n                              continuous_feature = FALSE, \n                              colors.use = cols.use)\n\np <- p1 | p2\np\n\n\n\nBee Swarm plots with similar values.\n\n\n\n\nSee, we still clearly see two groups, formed by clusters 1 and 2, and clusters 4 and 6. We could even remove clusters 1 and 2 and still see a similar effect.\n\n# Clusters to exclude.\nclusters_exclude <- c(\"0\", \"1\", \"2\", \"3\", \"5\", \"7\", \"8\", \"9\")\n\n# Keep the original coloring.\ncols.use <- colorspace::qualitative_hcl(length(levels(sample)), \n                                        palette = \"Dark 3\")\nnames(cols.use) <- levels(sample)\n\n# Only provide the needed colors. If more are provided, an error is thrown.\ncols.use <- cols.use[!(names(cols.use) %in% clusters_exclude)]\n\n\np1 <- SCpubr::do_DimPlot(sample = sample[, !(sample$seurat_clusters %in% clusters_exclude)], \n                         reduction = \"pca\", \n                         label = TRUE, \n                         legend.position = \"none\", \n                         dims = c(3, 4), \n                         colors.use = cols.use)\n\np2 <- SCpubr::do_BeeSwarmPlot(sample = sample[, !(sample$seurat_clusters %in% clusters_exclude)], \n                              feature_to_rank = \"PC_4\", \n                              group.by = \"seurat_clusters\", \n                              continuous_feature = FALSE, \n                              colors.use = cols.use)\n\np <- p1 | p2\np\n\n\n\nBee Swarm plots with almost identical values.\n\n\n\n\nAs can be seen here, both clusters now span all X axis. The cells have still ranked, therefore showing a cloud of dots. With this, we would just want that, as with any data visualization technique, each plot comes with a set of benefits and caveats. This visualization suffers from trying to plot highly similar values. Therefore, it is key to understand the nature of the variable you want to rank beforehand."
  },
  {
    "objectID": "06-BeeSwarmPlots.html#using-continuous-variables",
    "href": "06-BeeSwarmPlots.html#using-continuous-variables",
    "title": "\n4  Bee Swarm plots\n",
    "section": "\n4.2 Using continuous variables",
    "text": "4.2 Using continuous variables\nThere are also scenarios in which we want to rank the cells to a continuous variable, but instead of showing colors for each group (which is anyway depicted in the Y axis), we want to introduce a continuous color scale. This is specially interesting to assess enrichment of clusters towards a given set of features.\n\n# Set up list of a genes to compute enrichment. Let's use a monocyte signature.\ngenes.use <- c(\"CD14\", \"LYZ\")\n\n# Compute enrichment and rename the output.\nsample <- Seurat::AddModuleScore(sample, \n                                 features = genes.use, \n                                 name = \"Monocyte_signature\")\nsample$Monocyte_signature <- sample$Monocyte_signature1\nsample$Monocyte_signature1 <- NULL\n\np1 <- SCpubr::do_DimPlot(sample = sample, \n                         label = TRUE, \n                         legend.position = \"none\")\n\np2 <- SCpubr::do_FeaturePlot(sample = sample, \n                             features = \"Monocyte_signature\",\n                             legend.title = \"Monocyte signature\") \n\np3 <- SCpubr::do_BeeSwarmPlot(sample = sample, \n                              feature_to_rank = \"Monocyte_signature\", \n                              group.by = \"seurat_clusters\", \n                              continuous_feature = TRUE,\n                              legend.title = \"Monocyte signature\")\np <- p1 | p2 | p3\np\n\n\n\nBee Swarm plot - Continuous variable.\n\n\n\n\nBy using this combination of figures, we can also assess that the monocyte signature seems to be predominantly enriched in clusters 0 and 7."
  },
  {
    "objectID": "07-ViolinPlots.html#basic-usage",
    "href": "07-ViolinPlots.html#basic-usage",
    "title": "\n5  Violin plots\n",
    "section": "\n5.1 Basic usage",
    "text": "5.1 Basic usage\n\np <- Seurat::VlnPlot(sample, \n                     features = \"nCount_RNA\")\np\n\n\n\nViolin plots in Seurat.\n\n\n\n\nThe one thing that really stands out here is, indeed, the extra dots that are being plotted alongside the violin plot. Since each dot represent a cell, it quickly becomes the dominant feature of the figure. One can play with the alpha of the dots to reduce their presence:\n\np <- Seurat::VlnPlot(sample, \n                     features = \"nCount_RNA\")\n\n# \"Surgically\" add the alpha parameter in the ggplot2 object.\np$layers[[2]]$aes_params$alpha <- 0.05\np\n\n\n\nRemove the dots.\n\n\n\n\nBut still, by making the dots almost invisible, we still observe their dominance on the bigger clusters. Therefore, it’s better to remove it. This, together with other modifications are the basis of SCpubr::do_ViolinPlot(). This is how the default plot looks like:\n\n# Basic violin plot.\np <- SCpubr::do_ViolinPlot(sample = sample, \n                           features = \"nCount_RNA\")\np\n\n\n\nViolin plots in SCpubr.\n\n\n\n\nIn addition to removing the dots, a boxplot is added to each violin shape, to get a better sense of the quantiles of the distribution. This effect can be removed by using plot_boxplot = FALSE. Also, legend is by default removed, as the groups are being displayed already in the X axis.\n\n# Remove the box plots.\np <- SCpubr::do_ViolinPlot(sample = sample, \n                           features = \"nCount_RNA\",\n                           plot_boxplot = FALSE)\np\n\n\n\nRemove the boxplots.\n\n\n\n\nIf we want to rotate the X axis labels, we can also do that providing rotate_x_axis_labels with either 0, 45 or 90:\n\n# Rotate x axis labels.\np <- SCpubr::do_ViolinPlot(sample = sample, \n                        features = c(\"nCount_RNA\"),\n                        rotate_x_axis_labels = 45)\np\n\n\n\nRotate X axis labels."
  },
  {
    "objectID": "07-ViolinPlots.html#violin-plots-as-a-means-of-qc",
    "href": "07-ViolinPlots.html#violin-plots-as-a-means-of-qc",
    "title": "\n5  Violin plots\n",
    "section": "\n5.2 Violin plots as a means of QC",
    "text": "5.2 Violin plots as a means of QC\nFor QC analyses, users might want to also add some other features such as a line indicating where to put the cutoff. This can be achieved by using y_cut parameter. Currently, only one value per plot for y_cut can be used.\n\n# Add horizontal lines.\np <- SCpubr::do_ViolinPlot(sample = sample, \n                           features = \"nCount_RNA\", \n                           y_cut = 25000)\np\n\n\n\nAdd horizontal lines."
  },
  {
    "objectID": "07-ViolinPlots.html#modifying-aesthetics",
    "href": "07-ViolinPlots.html#modifying-aesthetics",
    "title": "\n5  Violin plots\n",
    "section": "\n5.3 Modifying aesthetics",
    "text": "5.3 Modifying aesthetics\nSometimes we might want to modify the overall look of the violin plots. For instance, the line width of both the violin shape and the box plot can be modified with line_width parameter, which defaults to 1.\n\n# Increase line width.\np1 <- SCpubr::do_ViolinPlot(sample = sample,\n                         features = \"nCount_RNA\")\n\np2 <- SCpubr::do_ViolinPlot(sample = sample,\n                         features = \"nCount_RNA\",\n                         line_width = 2)\n\np <- p1 / p2\np\n\n\n\nModify the line width.\n\n\n\n\nAlso, the width of the box plots can be modified with boxplot_width parameter, which defaults to 0.2. Be aware that this parameter scales the width of the boxplot. This is, if a value of 1 is provided, the box plot will take as much space as the violin shape. It is recommended to deviate from 0.2 by a small amount.\n\n# Decrease boxplot width.\np1 <- SCpubr::do_ViolinPlot(sample = sample,\n                            features = \"nCount_RNA\")\n\np2 <- SCpubr::do_ViolinPlot(sample = sample,\n                            features = \"nCount_RNA\",\n                            boxplot_width = 0.1)\n\np <- p1 / p2\np\n\n\n\nModify boxplot width."
  },
  {
    "objectID": "07-ViolinPlots.html#force-the-same-limits-on-different-violin-plots.",
    "href": "07-ViolinPlots.html#force-the-same-limits-on-different-violin-plots.",
    "title": "\n5  Violin plots\n",
    "section": "\n5.4 Force the same limits on different violin plots.",
    "text": "5.4 Force the same limits on different violin plots.\nFinally, we can also set the same range of values for the Y axis using share.y.lims = TRUE. For this, we need to provide multiple features to features parameter. The maximum and minimum values will be the absolute maximum and minimum across the features.\n\n# Share the same Y axis.\np <- SCpubr::do_ViolinPlot(sample = sample,\n                           features = c(\"nCount_RNA\", \"nFeature_RNA\"),\n                           ncol = 1,\n                           share.y.lims = TRUE)\np\n\n\n\nEnforce the same Y axis over multiple violin plots."
  },
  {
    "objectID": "07-ViolinPlots.html#split-by-another-variable",
    "href": "07-ViolinPlots.html#split-by-another-variable",
    "title": "\n5  Violin plots\n",
    "section": "\n5.5 Split by another variable",
    "text": "5.5 Split by another variable\nFinally, we can also generate split violin plots using the split.by parameter. However, plot_boxplot has to be set to FALSE:\n\n# Split violin plots.\nsample$orig.ident <- sample(c(\"A\", \"B\"),\n                            ncol(sample),\n                            replace = TRUE)\n\np<- SCpubr::do_ViolinPlot(sample = sample,\n                         features = \"nCount_RNA\",\n                         split.by = \"orig.ident\",\n                         plot_boxplot = FALSE,\n                         legend.position = \"bottom\")\n\np\n\n\n\nGenerate split violin plots."
  },
  {
    "objectID": "08-RidgePlots.html#basic-usage",
    "href": "08-RidgePlots.html#basic-usage",
    "title": "\n6  Ridge plots\n",
    "section": "\n6.1 Basic usage",
    "text": "6.1 Basic usage\nThe most basic ridge plot can be computed as:\n\n# Compute the most basic ridge plot.\np <- SCpubr::do_RidgePlot(sample = sample,\n                          feature = \"nFeature_RNA\")\np\n\n\n\nA basic Ridge Plot."
  },
  {
    "objectID": "08-RidgePlots.html#use-continuous-color-scales",
    "href": "08-RidgePlots.html#use-continuous-color-scales",
    "title": "\n6  Ridge plots\n",
    "section": "\n6.2 Use continuous color scales",
    "text": "6.2 Use continuous color scales\nBy default, the groups plotted are the current identities in the sample, but this can be changed by using group.by. One can also color the ridges based on the continuous values being represented, using continuous_scale = TRUE. The direction of the color scale can be controlled using viridis_direction :\n\n# Use continuous color scale.\np1 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           viridis_direction = 1)\n\np2 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           viridis_direction = -1)\n\np <- p1 / p2\np\n\n\n\nUse a continuous color scale."
  },
  {
    "objectID": "08-RidgePlots.html#plot-quantiles-of-the-distribution",
    "href": "08-RidgePlots.html#plot-quantiles-of-the-distribution",
    "title": "\n6  Ridge plots\n",
    "section": "\n6.3 Plot quantiles of the distribution",
    "text": "6.3 Plot quantiles of the distribution\nOne can also draw quantiles of the distribution for each of the groups. For this, we need to set up the scale to continuous. Also, we can modify the quantiles by using quantiles parameter:\n\n# Draw quantiles of the distribution.\np1 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           compute_quantiles = TRUE,\n                           compute_custom_quantiles = TRUE)\n\np2 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           compute_quantiles = TRUE,\n                           compute_custom_quantiles = TRUE,\n                           quantiles = c(0.1, 0.5, 0.75))\n\np <- p1 / p2\np\n\n\n\nPlot distribution quantiles."
  },
  {
    "objectID": "08-RidgePlots.html#compute-probability-tails",
    "href": "08-RidgePlots.html#compute-probability-tails",
    "title": "\n6  Ridge plots\n",
    "section": "\n6.4 Compute probability tails",
    "text": "6.4 Compute probability tails\nOne can draw probability tails of the distribution by using compute_distribution_tails and prob_tails.\n\n# Draw probability tails.\np1 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           compute_quantiles = TRUE,\n                           compute_distribution_tails = TRUE)\n\np2 <- SCpubr::do_RidgePlot(sample = sample,\n                           feature = \"nFeature_RNA\",\n                           continuous_scale = TRUE,\n                           compute_quantiles = TRUE,\n                           compute_distribution_tails = TRUE,\n                           prob_tails = 0.3)\n\np <- p1 / p2\np\n\n\n\nPlot probability tails."
  },
  {
    "objectID": "08-RidgePlots.html#compute-probability-densities",
    "href": "08-RidgePlots.html#compute-probability-densities",
    "title": "\n6  Ridge plots\n",
    "section": "\n6.5 Compute probability densities",
    "text": "6.5 Compute probability densities\nOne can also display the probability densities of the distributions by using :\n\n# Draw probability tails.\np <- SCpubr::do_RidgePlot(sample = sample,\n                          feature = \"nFeature_RNA\",\n                          continuous_scale = TRUE,\n                          compute_quantiles = TRUE,\n                          color_by_probabilities = TRUE)\np\n\n\n\nPlot probability densities."
  },
  {
    "objectID": "09-DotPlots.html#basic-usage",
    "href": "09-DotPlots.html#basic-usage",
    "title": "\n7  Dot plots\n",
    "section": "\n7.1 Basic usage",
    "text": "7.1 Basic usage\n\n\n\n\n# Seurat's dot plot.\np <- Seurat::DotPlot(sample, \n                     features = \"CD14\")\np\n\n\n\nSeurat DotPlot.\n\n\n\n\nAs can be seen, if we try to plot other type of variables, the resulting plot will not contain a color scale. SCpubr::do_DimPlot() focuses on enhancing the overall appearance of the plots. Implementation using other types of features is not currently supported. This is how it looks using SCpubr::do_DimPlot():\n\n# SCpubr's dot plot.\np <- SCpubr::do_DotPlot(sample = sample, \n                        features = \"CD14\")\np\n\n\n\nSCpubr DotPlot."
  },
  {
    "objectID": "09-DotPlots.html#querying-multiple-features-at-once",
    "href": "09-DotPlots.html#querying-multiple-features-at-once",
    "title": "\n7  Dot plots\n",
    "section": "\n7.2 Querying multiple features at once",
    "text": "7.2 Querying multiple features at once\nThe true power of this data visualization relies on querying multiple genes at once. Let’s query the ones described in this Seurat vignette:\n\ngenes <- c(\"IL7R\", \"CCR7\", \"CD14\", \"LYZ\", \n           \"S100A4\", \"MS4A1\", \"CD8A\", \"FCGR3A\", \n           \"MS4A7\", \"GNLY\", \"NKG7\", \"FCER1A\", \n           \"CST3\", \"PPBP\")\n\np <- SCpubr::do_DotPlot(sample = sample, \n                        features = genes)\np\n\n\n\nQuery multiple genes at once.\n\n\n\n\nHere, we can clearly distinguish which clusters are highly enriched in which given genes. This proves to be a very interesting way to query for cluster identities. It is highly dependent, though, on the accuracy of the selected genes for the queried dataset. If we actually provide the list of genes as a named list, we can facet the plot in the different list of genes provided:\n\ngenes <- list(\"Naive CD4+ T\" = c(\"IL7R\", \"CCR7\"),\n              \"CD14+ Mono\" = c(\"CD14\", \"LYZ\"),\n              \"Memory CD4+\" = c(\"S100A4\"),\n              \"B\" = c(\"MS4A1\"),\n              \"CD8+ T\" = c(\"CD8A\"),\n              \"FCGR3A+ Mono\" = c(\"FCGR3A\", \"MS4A7\"),\n              \"NK\" = c(\"GNLY\", \"NKG7\"),\n              \"DC\" = c(\"FCER1A\", \"CST3\"),\n              \"Platelet\" = c(\"PPBP\"))\n\np <- SCpubr::do_DotPlot(sample = sample, \n                        features = genes)\np\n\n\n\nQuery multiple genes as a named list."
  },
  {
    "objectID": "09-DotPlots.html#clustering-the-identities",
    "href": "09-DotPlots.html#clustering-the-identities",
    "title": "\n7  Dot plots\n",
    "section": "\n7.3 Clustering the identities",
    "text": "7.3 Clustering the identities\nOne really cool feature from Seurat::DotPlot() is that it lets you cluster the identities in the Y axis depending on how similar they are between them across the values on the X axis. This is achieved by using cluster.idents = TRUE, parameter also implemented in SCpubr::do_DotPlot():\n\np1 <- SCpubr::do_DotPlot(sample = sample, \n                         features = genes,\n                         plot.title = \"Not clustered\")\n\np2 <- SCpubr::do_DotPlot(sample = sample, \n                         features = genes, \n                         cluster.idents = TRUE, \n                         plot.title = \"Clustered\")\n\np <- p1 / p2\np\n\n\n\nCluster the identities."
  },
  {
    "objectID": "09-DotPlots.html#inverting-the-axes",
    "href": "09-DotPlots.html#inverting-the-axes",
    "title": "\n7  Dot plots\n",
    "section": "\n7.4 Inverting the axes",
    "text": "7.4 Inverting the axes\nIn SCpubr::do_DotPlot(), we can also invert the axes, so that the groups are in the X axis and the genes in the Y axis. This is achieved by using flip = TRUE. Note, however, that this does not work when using a named list of genes as input, as it completely distort the way facets are computed. Given this, this combination of parameters is currently blocked by SCpubr.\n\ngenes <- c(\"IL7R\", \"CCR7\", \"CD14\", \"LYZ\", \n           \"S100A4\", \"MS4A1\", \"CD8A\", \"FCGR3A\", \n           \"MS4A7\", \"GNLY\", \"NKG7\", \"FCER1A\", \n           \"CST3\", \"PPBP\")\n\np1 <- SCpubr::do_DotPlot(sample = sample, \n                         features = genes, \n                         plot.title = \"Not clustered\", \n                         flip = TRUE)\n\np2 <- SCpubr::do_DotPlot(sample = sample, \n                         features = genes, \n                         cluster.idents = TRUE, \n                         plot.title = \"Clustered\", \n                         flip = TRUE,\n                         rotate_x_axis_labels = 45)\np <- p1 | p2\np\n\n\n\nFlip the axes."
  },
  {
    "objectID": "10-BarPlots.html#basic-usage",
    "href": "10-BarPlots.html#basic-usage",
    "title": "\n8  Bar plots\n",
    "section": "\n8.1 Basic usage",
    "text": "8.1 Basic usage\n\n# Basic bar plot, horizontal.\np1 <- SCpubr::do_BarPlot(sample = sample, \n                         group.by = \"seurat_clusters\", \n                         legend.position = \"none\", \n                         plot.title = \"Number of cells per cluster\")\n\n# Basic bar plot, vertical.\np2 <- SCpubr::do_BarPlot(sample = sample, \n                         group.by = \"seurat_clusters\", \n                         legend.position = \"none\",\n                         plot.title = \"Number of cells per cluster\", \n                         flip = TRUE)\np <- p1 | p2\np\n\n\n\nBasic bar plot.\n\n\n\n\nUsing SCpubr::do_BarPlot() with only group.by yields a simple bar plot which is ordered by descending value. We can also set up the direction of the bars with flip = TRUE/FALSE, which by default is set to be vertical. There is an underlying assumption that is being taken to generate these plots:\n\nThe values in group.by need to be metadata variables, stored in object@meta.data. They have to be either a character or factor columns."
  },
  {
    "objectID": "10-BarPlots.html#grouping-by-a-second-variable",
    "href": "10-BarPlots.html#grouping-by-a-second-variable",
    "title": "\n8  Bar plots\n",
    "section": "\n8.2 Grouping by a second variable",
    "text": "8.2 Grouping by a second variable\nLet’s expand on the previous example on the number of cells per cluster. What if we were interested not only on that, but we would like to profile how many cells from each cluster are present in each of the unique samples present in the Seurat object? For this, we need to provide SCpubr::do_BarPlot() with a second parameter, split.by, that tackles how we want the feature to be grouped:\n\nsample$modified_orig.ident <- sample(x = c(\"Sample_A\", \"Sample_B\", \"Sample_C\"), \n                                     size = ncol(sample), \n                                     replace = TRUE, \n                                     prob = c(0.2, 0.7, 0.1))\n\n# Split by a second variable.\np1 <- SCpubr::do_BarPlot(sample,\n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         plot.title = \"Number of cells per cluster in each sample\",\n                         position = \"stack\")\n\np2 <- SCpubr::do_BarPlot(sample, \n                         group.by = \"modified_orig.ident\", \n                         split.by = \"seurat_clusters\",\n                         plot.title = \"Number of cells per sample in each cluster\",\n                         position = \"stack\")\np <- p1 | p2\np\n\n\n\nSplit the bars by another variable.\n\n\n\n\nAs we can see, this nicely yields as many number of bars as unique values in the group.by, and this bars are segmented by as many times as unique values in split.by. At first, this is hard to grasp, but it helps thinking of these two parameters, when used together, as:\n\n\ngroup.by: What I want to show as different bars, the total number of counts.\n\nsplit.by: Secondary variable on which the bars generated by group.by can be further subdivided.\n\nAnother interesting parameter introduced in the last example is position. Position can be either stack or fill. The difference between them is that position = \"stack\" will yield the total number of cells for each of the unique values in feature, while position = \"fill\" will bring all bars to the same height and will split each bar into the proportions within each bar of the different groups (only one if group.by = NULL and as many groups if group.by is used). Therefore, it becomes highly recommended to use position = \"stack\" when group.by is not used and position = \"fill\" otherwise. This is also warned by the package. If you want to silence the warnings, use verbose = FALSE.\n\n# Position stack and fill with and without split.by.\np1 <- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         plot.title = \"Without split.by - position = stack\",\n                         position = \"stack\",\n                         flip = FALSE)\n\np2 <- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         plot.title = \"Without split.by - position = fill\",\n                         position = \"fill\",\n                         flip = FALSE)\n\np3 <- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         plot.title = \"With split.by - position = stack\",\n                         position = \"stack\",\n                         flip = FALSE)\n\np4 <- SCpubr::do_BarPlot(sample, \n                         group.by = \"seurat_clusters\",\n                         split.by = \"modified_orig.ident\",\n                         plot.title = \"With split.by - position = fill\",\n                         position = \"fill\",\n                         flip = FALSE)\np <- (p1 | p2) / (p3 | p4)\np\n\n\n\nUse position stack or position fill."
  },
  {
    "objectID": "11-BoxPlots.html#basic-usage",
    "href": "11-BoxPlots.html#basic-usage",
    "title": "\n9  Box plots\n",
    "section": "\n9.1 Basic usage",
    "text": "9.1 Basic usage\nTo generate a basic box plot you need to provide the seurat object and a feature to plot:\n\n# Basic box plot.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\")\np\n\n\n\nBasic box plot."
  },
  {
    "objectID": "11-BoxPlots.html#use-custom-grouping",
    "href": "11-BoxPlots.html#use-custom-grouping",
    "title": "\n9  Box plots\n",
    "section": "\n9.2 Use custom grouping",
    "text": "9.2 Use custom grouping\nBy default, the groups are the identities in the seurat object, but this can be controlled using group.by parameter.\n\n# Generate a custom group.\nsample$custom_group = ifelse(colnames(sample) %in% sample(colnames(sample), 4000), \"A\", \"B\")\n\n# Use custom grouping.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        group.by = \"custom_group\")\np\n\n\n\nGroup by another variable.\n\n\n\n\nWe can flip the plot if needed with flip = TRUE:\n\n# Flip the box plot.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        flip = TRUE)\np\n\n\n\nFlip the axes."
  },
  {
    "objectID": "11-BoxPlots.html#modify-aesthetic-style",
    "href": "11-BoxPlots.html#modify-aesthetic-style",
    "title": "\n9  Box plots\n",
    "section": "\n9.3 Modify aesthetic style",
    "text": "9.3 Modify aesthetic style\nWe can also apply another aesthetic style, which just colors the lines of the boxplots and leave the rest white with use_silhouette = TRUE:\n\n# Use silhouette style.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        use_silhouette = TRUE)\np\n\n\n\nChange to silhouette style."
  },
  {
    "objectID": "11-BoxPlots.html#reorder-by-mean-values",
    "href": "11-BoxPlots.html#reorder-by-mean-values",
    "title": "\n9  Box plots\n",
    "section": "\n9.4 Reorder by mean values",
    "text": "9.4 Reorder by mean values\nWe can reorder the values by their average mean, from highest to lowest with order = TRUE:\n\n# Order by mean values.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        order = TRUE)\np\n\n\n\nOrder the boxplots by the mean values of the group."
  },
  {
    "objectID": "11-BoxPlots.html#split-by-a-second-variable",
    "href": "11-BoxPlots.html#split-by-a-second-variable",
    "title": "\n9  Box plots\n",
    "section": "\n9.5 Split by a second variable",
    "text": "9.5 Split by a second variable\nWe can further apply a second grouping by using split.by.\n\n# Apply second grouping.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        split.by = \"custom_group\")\np\n\n\n\nSplit by a second variable."
  },
  {
    "objectID": "11-BoxPlots.html#apply-statistical-tests-to-compare-groups",
    "href": "11-BoxPlots.html#apply-statistical-tests-to-compare-groups",
    "title": "\n9  Box plots\n",
    "section": "\n9.6 Apply statistical tests to compare groups",
    "text": "9.6 Apply statistical tests to compare groups\nFinally we can apply statistical tests to the groups, if we do not use split.by. We can do that by setting use_test = TRUE and providing the comparison as a list of pairs of items. The test, by default is wilcoxon test, but can be modified using test. The correct use of such tests and their interpretation relies on the user.\n\n# Apply statistical tests.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        use_test = TRUE,\n                        comparisons = list(c(\"0\", \"1\"),\n                                           c(\"3\", \"4\"),\n                                           c(\"5\", \"9\")))\np\n\n\n\nApply statistical tests.\n\n\n\n\nOne can display this on symbols, or with numbers with map_signif_level:\n\n# Apply statistical tests and show the p-value.\np <- SCpubr::do_BoxPlot(sample = sample,\n                        feature = \"nCount_RNA\",\n                        use_test = TRUE,\n                        comparisons = list(c(\"0\", \"1\"),\n                                           c(\"3\", \"4\"),\n                                           c(\"5\", \"9\")),\n                        map_signif_level = FALSE)\np\n\n\n\nShow the p-value of the statistical tests."
  },
  {
    "objectID": "12-GeyserPlots.html#basic-usage",
    "href": "12-GeyserPlots.html#basic-usage",
    "title": "\n10  Geyser plots\n",
    "section": "\n10.1 Basic usage",
    "text": "10.1 Basic usage\nThe most basic version of this plot uses only the X and Y variables, while the color of the cells is assigned to either of the two. We can achieve this by using SCpubr::do_GeyserPlot() and stating the kind of color scale we want with scale_type (either continuous or categorical).\n\n# Geyser plot with categorical color scale.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"nCount_RNA\",\n                            scale_type = \"categorical\")\n\n# Geyser plot with continuous color scale.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"nCount_RNA\",\n                            scale_type = \"continuous\")\n\n\np <- p1 / p2\np\n\n\n\nBasic Geyser plot."
  },
  {
    "objectID": "12-GeyserPlots.html#ordering-by-mean-values",
    "href": "12-GeyserPlots.html#ordering-by-mean-values",
    "title": "\n10  Geyser plots\n",
    "section": "\n10.2 Ordering by mean values",
    "text": "10.2 Ordering by mean values\nFirst thing that one notice, is that the geysers are ordered from highest to lowest mean values. This can be nullified by using order_by_mean = FALSE. In this case, the geysers will order based on alphabetical order or on the levels if the variable chosen is a factor.\n\n# Geyser plot with categorical color scale without ordering by mean.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"nCount_RNA\",\n                            scale_type = \"categorical\",\n                            order_by_mean = FALSE)\n\n# Geyser plot with continuous color scale without ordering by mean.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"nCount_RNA\",\n                            scale_type = \"continuous\",\n                            order_by_mean = FALSE)\n\n\np <- p1 / p2\np\n\n\n\nGeyser plot ordering by the mean."
  },
  {
    "objectID": "12-GeyserPlots.html#plotting-symmetrical-scales",
    "href": "12-GeyserPlots.html#plotting-symmetrical-scales",
    "title": "\n10  Geyser plots\n",
    "section": "\n10.3 Plotting symmetrical scales",
    "text": "10.3 Plotting symmetrical scales\nDepending on the case, it might be the case in which we want to plot a continuous variable that spans both in positive and negative values. Although not necessary, there are cases in which this binary nature of the values has a biological meaning and we, therefore, assign two gradient of colors (typically blue for negative values and red for positive values) to better visualize this nature of the data. We can achieve this by using enforce_symmetry = TRUE.\n\n# Geyser plot with continuous color scale.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = FALSE)\n\n# Geyser plot with continuous and symmetrical color scale.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE)\n\n\np <- p1 / p2\np\n\n\n\nGeyser plot with a symmetrical scale."
  },
  {
    "objectID": "12-GeyserPlots.html#select-the-groups-displayed-on-the-x-axis",
    "href": "12-GeyserPlots.html#select-the-groups-displayed-on-the-x-axis",
    "title": "\n10  Geyser plots\n",
    "section": "\n10.4 Select the groups displayed on the X axis",
    "text": "10.4 Select the groups displayed on the X axis\nFurhtermore, we can select the groups displayed on the X axis with group.by parameter. It defaults to the current identities in the sample if not provided. That is also the reason why the X axis title is called “Groups”. The titles can be modified by usind xlab and ylab, respectively.\n\n# Geyser plot with categorical color scale default X axis grouping.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"categorical\",\n                            group.by = NULL,\n                            xlab = \"Seurat clusters\")\n\n# Geyser plot with categorical color scale and custom grouping.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"categorical\",\n                            group.by = \"orig.ident\",\n                            xlab = \"Individual sample\")\n\n\np <- p1 / p2\np\n\n\n\nGroup by another variables."
  },
  {
    "objectID": "12-GeyserPlots.html#split-the-plot-by-groups",
    "href": "12-GeyserPlots.html#split-the-plot-by-groups",
    "title": "\n10  Geyser plots\n",
    "section": "\n10.5 Split the plot by groups",
    "text": "10.5 Split the plot by groups\nApart from selecting the grouping, we can effectively split the plot by another categorical variable. This can be achieved by using split.by.\n\n# We only have one value in orig.ident. Let's modify it so that it resembles a multi-sample Seurat object.\nsample$modified_orig.ident <- sample(x = c(\"Sample_A\", \"Sample_B\", \"Sample_C\"), \n                                     size = ncol(sample), \n                                     replace = TRUE, \n                                     prob = c(0.2, 0.7, 0.1))\n\n# Geyser plot with categorical color scale split by seurat clusters.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"categorical\",\n                            group.by = \"modified_orig.ident\",\n                            split.by = \"seurat_clusters\")\n\n# Geyser plot with continuous color scale split by seurat clusters.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            group.by = \"modified_orig.ident\",\n                            split.by = \"seurat_clusters\")\n\n\np <- p1 / p2\np\n\n\n\nSplit by another variables."
  },
  {
    "objectID": "12-GeyserPlots.html#rotating-x-axis-labels",
    "href": "12-GeyserPlots.html#rotating-x-axis-labels",
    "title": "\n10  Geyser plots\n",
    "section": "\n10.6 Rotating X axis labels",
    "text": "10.6 Rotating X axis labels\nAs with the example above, X axis labels might overlap one with another. This can be changed by using rotate_x_axis_labels with 0, 45 or 90,\n\n# Geyser plot with categorical color scale split by seurat clusters rotating labels.\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"categorical\",\n                            group.by = \"modified_orig.ident\",\n                            split.by = \"seurat_clusters\",\n                            rotate_x_axis_labels = 45)\n\n# Geyser plot with continuous color scale split by seurat clusters rotating labels.\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            group.by = \"modified_orig.ident\",\n                            split.by = \"seurat_clusters\",\n                            rotate_x_axis_labels = 45)\n\n\np <- p1 / p2\np\n\n\n\nRotate the X axis labels."
  },
  {
    "objectID": "12-GeyserPlots.html#control-the-jitter-of-the-dots",
    "href": "12-GeyserPlots.html#control-the-jitter-of-the-dots",
    "title": "\n10  Geyser plots\n",
    "section": "\n10.7 Control the jitter of the dots",
    "text": "10.7 Control the jitter of the dots\nIf one wants to increase or reduce the degree in which the dots disperse across the X axis, jitter parameter can be used, alongside a number in between 0 and 0.5.\n\n# Geyser plot with different jitter.\np0 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.01)\n\np1 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.1)\n\np2 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.2)\n\np3 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.3)\n\np4 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.4)\n\np5 <- SCpubr::do_GeyserPlot(sample = sample,\n                            features = \"UMAP_2\",\n                            scale_type = \"continuous\",\n                            enforce_symmetry = TRUE,\n                            jitter = 0.49)\n\n\np <- p0 / p1 / p2 / p3 / p4 / p5\np\n\n\n\nControl the jittering."
  },
  {
    "objectID": "13-AlluvialPlot.html#addd-more-groups",
    "href": "13-AlluvialPlot.html#addd-more-groups",
    "title": "\n11  Alluvial plots\n",
    "section": "\n11.1 Addd more groups",
    "text": "11.1 Addd more groups\nFurther groups can be added with the middle_groups parameter:\n\n# Generate a more fine-grained clustering.\nsample$extra_annotation <- ifelse(sample$seurat_clusters %in% c(\"1\", \"4\"), \"C\", \"D\")\n\n# Compute basic sankey plot.\np <- SCpubr::do_AlluvialPlot(sample = sample,\n                            first_group = \"annotation\",\n                            middle_groups = \"extra_annotation\",\n                            last_group = \"seurat_clusters\")\n\np\n\n\n\nAdd more groups."
  },
  {
    "objectID": "13-AlluvialPlot.html#change-the-label-type",
    "href": "13-AlluvialPlot.html#change-the-label-type",
    "title": "\n11  Alluvial plots\n",
    "section": "\n11.2 Change the label type",
    "text": "11.2 Change the label type\nTo better control the overplotting of the labels, the user can choose the geom to use for them with use_labels = TRUE/FALSE and whether to repel the labels using repel = TRUE/FALSE.\n\n# Control overplotting.\np1 <- SCpubr::do_AlluvialPlot(sample = sample,\n                              first_group = \"annotation\",\n                              last_group = \"seurat_clusters\",\n                              use_labels = FALSE)\n\np2 <- SCpubr::do_AlluvialPlot(sample = sample,\n                              first_group = \"annotation\",\n                              last_group = \"seurat_clusters\",\n                              use_labels = TRUE)\n\np3 <- SCpubr::do_AlluvialPlot(sample = sample,\n                              first_group = \"annotation\",\n                              last_group = \"seurat_clusters\",\n                              use_labels = FALSE,\n                              repel = TRUE)\n\np4 <- SCpubr::do_AlluvialPlot(sample = sample,\n                              first_group = \"annotation\",\n                              last_group = \"seurat_clusters\",\n                              use_labels = TRUE,\n                              repel = TRUE)\n\np <- (p1 | p2) / (p3 | p4)\np\n\n\n\nControl overplotting."
  },
  {
    "objectID": "13-AlluvialPlot.html#customisation",
    "href": "13-AlluvialPlot.html#customisation",
    "title": "\n11  Alluvial plots\n",
    "section": "\n11.3 Customisation",
    "text": "11.3 Customisation\nAs can be noted, the color of the connection between the nodes is determined by the variable provided to last_group. This is a limitation of the plot type only one column can be passed for the coloring. This can be customized by using fill.by.\n\n# Color by another column.\np <- SCpubr::do_AlluvialPlot(sample = sample,\n                            first_group = \"annotation\",\n                            middle_groups = \"extra_annotation\",\n                            last_group = \"seurat_clusters\",\n                            fill.by = \"annotation\")\n\np\n\n\n\nColor by another column.\n\n\n\n\nAlso, one can provide its own custom colors to the plot, as always, using color.by:\n\n# Use custom colors.\np <- SCpubr::do_AlluvialPlot(sample = sample,\n                            first_group = \"annotation\",\n                            middle_groups = \"extra_annotation\",\n                            last_group = \"seurat_clusters\",\n                            fill.by = \"extra_annotation\",\n                            colors.use = c(\"C\" = \"#684C41\",\n                                           \"D\" = \"#FDAE38\"))\n\np\n\n\n\nUse custom colors\n\n\n\n\nWe can modify the colors of the border of the connections (alluvium) and the nodes (stratum) with stratum.color and alluvium.color.\n\n# Use custom colors for borders.\np <- SCpubr::do_AlluvialPlot(sample = sample,\n                            first_group = \"annotation\",\n                            last_group = \"seurat_clusters\",\n                            stratum.color = \"white\",\n                            alluvium.color = \"black\")\n\np\n\n\n\nUse custom colors for borders.\n\n\n\n\nWe can also control the filling of both stratum by using alluvium.fill.\n\n# Use custom colors for fill\np <- SCpubr::do_AlluvialPlot(sample = sample,\n                            first_group = \"annotation\",\n                            last_group = \"seurat_clusters\",\n                            stratum.fill = \"grey75\")\n\np\n\n\n\nUse custom colors for fill.\n\n\n\n\nAlso, one can apply viridis scales, if wanted, by using use_viridis and viridis_color_map parameters:\n\n# Use viridis scales.\np <- SCpubr::do_AlluvialPlot(sample = sample,\n                            first_group = \"annotation\",\n                            last_group = \"seurat_clusters\",\n                            use_viridis = TRUE,\n                            viridis_color_map = \"G\")\n\np\n\n\n\nUse viridis scales."
  },
  {
    "objectID": "13-SankeyPlots.html#basic-usage",
    "href": "13-SankeyPlots.html#basic-usage",
    "title": "\n12  Sankey plots\n",
    "section": "\n12.1 Basic usage",
    "text": "12.1 Basic usage\nDue to an internal bug in ggsankey, the package dplyr has to be loaded with library(dplyr) before running this function.\nThis is how we can achieve basic Sankey or alluvial plots (using package):\n\n# Generate a more fine-grained clustering.\nsample <- Seurat::FindSubCluster(sample, cluster = c(\"0\", \"5\"), graph.name = \"SCT_snn\")\n#> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n#> \n#> Number of nodes: 4428\n#> Number of edges: 146366\n#> \n#> Running Louvain algorithm...\n#> Maximum modularity in 10 random starts: 0.7966\n#> Number of communities: 6\n#> Elapsed time: 0 seconds\nsample$sub.cluster <- paste0(\"sub_\", sample$sub.cluster)\n\n# Compute basic sankey plot.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            last_group = \"seurat_clusters\",\n                            type = \"sankey\")\n\n# Compute basic alluvial plot.\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            last_group = \"seurat_clusters\",\n                            type = \"alluvial\")\n\np <- p1 / p2\np\n\n\n\nBasic Sankey and Alluvial plots.\n\n\n\n\nThe key aspects of this figure is that one has to provide the starting and end groups to first_group and last_group parameters, and the type of plot to type, making it either alluvial or sankey. The major difference between both is simply that the alluvial plot has not space between the groups. This allows for a more compact visualization, although it can get quite messy depending on the colors. We can keep adding as many groups as we want in between by using middle_groups parameter.\n\nsample$assignment <- ifelse(sample$seurat_clusters %in% c(\"0\", \"2\", \"4\"), \"A\", \"B\")\n\n# Add more groups.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\")\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"alluvial\")\n\np <- p1 / p2\np\n\n\n\nAdd more groups in the middle."
  },
  {
    "objectID": "13-SankeyPlots.html#modify-node-aesthetics",
    "href": "13-SankeyPlots.html#modify-node-aesthetics",
    "title": "\n12  Sankey plots\n",
    "section": "\n12.2 Modify node aesthetics",
    "text": "12.2 Modify node aesthetics\nBy default, the color of the nodes and the fill is white, so that they can not be seen. One Can modify this by using node.fill and node.color.\n\n# Control the color and fill of the nodes.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\")\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"alluvial\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\")\n\np <- p1 / p2\np\n\n\n\nModify the colors for the nodes.\n\n\n\n\nAs can be seen, the text labels, then, overlap the limits of the nodes. We can fix that using the width parameter:\n\n# Control the width of the nodes.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\")\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\",\n                            width = 0.5)\n\np <- p1 / p2\np\n\n\n\nModify the width of the nodes."
  },
  {
    "objectID": "13-SankeyPlots.html#control-alignment-of-the-labels",
    "href": "13-SankeyPlots.html#control-alignment-of-the-labels",
    "title": "\n12  Sankey plots\n",
    "section": "\n12.3 Control alignment of the labels",
    "text": "12.3 Control alignment of the labels\nWe can also control the alignment of the labels (goes different by the different groups by default) using the hjust parameter. This will modify it for all the nodes.\n\n# Control the alignment of the labels.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\",\n                            width = 0.5)\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            node.fill = \"grey95\",\n                            node.color = \"black\",\n                            width = 0.5,\n                            hjust = 0.5)\n\np <- p1 / p2\np\n\n\n\nControl the alignment of the labels.\n\n\n\n\nWe can also turn the text into labels, which will then be colored based on the end nodes. We can toggle it by using use_labels = TRUE.\n\n# Use text or labels for the nodes.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\")\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            use_labels = TRUE,\n                            text_color = \"white\")\n\np <- p1 / p2\np\n\n\n\nUse text or labels."
  },
  {
    "objectID": "13-SankeyPlots.html#increase-the-gap-between-the-nodes",
    "href": "13-SankeyPlots.html#increase-the-gap-between-the-nodes",
    "title": "\n12  Sankey plots\n",
    "section": "\n12.4 Increase the gap between the nodes",
    "text": "12.4 Increase the gap between the nodes\nOne can also increase the gaps between the nodes. This is done by providing a number to space. This number would act as “invisible” cells in between the nodes. So one needs to think in terms of how many cells do we have in our dataset. The bigger the dataset, the higher the number we need to notice a difference. It is set by default to 5% of the total number of cells in the dataset.\n\n# Modify the space between nodes.\np1 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            space =  1000)\n\np2 <- SCpubr::do_SankeyPlot(sample = sample,\n                            first_group = \"sub.cluster\",\n                            middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                            last_group = \"orig.ident\",\n                            type = \"sankey\",\n                            space = 5000)\n\np <- p1 / p2\np\n\n\n\nIncrease the gaps between the nodes."
  },
  {
    "objectID": "13-SankeyPlots.html#modify-default-colors",
    "href": "13-SankeyPlots.html#modify-default-colors",
    "title": "\n12  Sankey plots\n",
    "section": "\n12.5 Modify default colors",
    "text": "12.5 Modify default colors\nFinally, we can modify the default colors by providing our own to colors.first, colors.middle and colors.last. It has to be a named vector with\n\n# Modify default colors.\ncolors.first <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                                        n = length(unique(sample$sub.cluster)))\nnames(colors.first) <- unique(sample$sub.cluster)\n\np <- SCpubr::do_SankeyPlot(sample = sample,\n                           first_group = \"sub.cluster\",\n                           middle_groups = c(\"seurat_clusters\", \"assignment\"),\n                           last_group = \"orig.ident\",\n                           type = \"sankey\",\n                           colors.first = )\np\n\n\n\nChange default colors."
  },
  {
    "objectID": "14-ChordDiagramPlots.html#basic-usage",
    "href": "14-ChordDiagramPlots.html#basic-usage",
    "title": "\n13  Chord Diagram plots\n",
    "section": "\n13.1 Basic usage",
    "text": "13.1 Basic usage\nThis is how it looks:\n\n# Basic chord diagram.\nsample$assignment <- ifelse(sample$seurat_clusters %in% c(\"0\", \"4\", \"7\"), \"A\", \"B\")\nsample$assignment[sample$seurat_clusters %in% c(\"1\", \"2\")] <- \"C\"\nsample$assignment[sample$seurat_clusters %in% c(\"10\", \"5\")] <- \"D\"\nsample$assignment[sample$seurat_clusters %in% c(\"8\", \"9\")] <- \"E\"\n\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\")\n\np\n\n\n\n\nBasic Chord Diagram."
  },
  {
    "objectID": "14-ChordDiagramPlots.html#control-the-gaps-between-and-within-groups",
    "href": "14-ChordDiagramPlots.html#control-the-gaps-between-and-within-groups",
    "title": "\n13  Chord Diagram plots\n",
    "section": "\n13.2 Control the gaps between and within groups",
    "text": "13.2 Control the gaps between and within groups\nWe can modify the gaps between from and to, provided that there are not so many elements that this can not be accomplished. For this, we use big_gap:\n\n# Increase gap between from and to groups.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 big.gap = 40)\n\np\n\n\n\n\nChord Diagram with increased big gap.\n\n\nSimilarly, we can also modify the gaps between the groups inside from and to with small_gap:\n\n# Increase gap width groups in from and to.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 small.gap = 5)\n\np\n\n\n\n\nChord Diagram with increased small gap."
  },
  {
    "objectID": "14-ChordDiagramPlots.html#control-the-alignment-of-the-diagram",
    "href": "14-ChordDiagramPlots.html#control-the-alignment-of-the-diagram",
    "title": "\n13  Chord Diagram plots\n",
    "section": "\n13.3 Control the alignment of the diagram",
    "text": "13.3 Control the alignment of the diagram\nWe can force the alignment of the starting poing of the Chord diagram using the alignment parameter:\n\n# Control the alignment of the diagram.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 alignment = \"horizontal\")\n\np\n\n\n\n\nChord Diagram starting horizontally.\n\n\n\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 alignment = \"vertical\")\n\np\n\n\n\n\nChord Diagram starting vertically."
  },
  {
    "objectID": "14-ChordDiagramPlots.html#control-the-directions-of-the-links",
    "href": "14-ChordDiagramPlots.html#control-the-directions-of-the-links",
    "title": "\n13  Chord Diagram plots\n",
    "section": "\n13.4 Control the directions of the links",
    "text": "13.4 Control the directions of the links\nAlso, we can define the direction of the interaction by providing different values to directional: - 0: The links have no direction. - 1: The links go from from to to. - -1: The links go from to to from. - 2: The links are bidrectional.\n\n# We need to set direction.type to diffHeight only as arrows are, by nature, directional.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 directional = 0,\n                                 direction.type = \"diffHeight\")\n\np\n\n\n\n\nChord Diagram with links without any direction.\n\n\n\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 directional = 1)\n\np\n\n\n\n\nChord Diagram with links going from “from” to “to”.\n\n\n\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 directional = -1)\n\np\n\n\n\n\nChord Diagram with links going from “to” to “from”.\n\n\n\n# We need to set direction.type to diffHeight only as arrows are, by nature, directional.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 directional = 2,\n                                 direction.type = \"diffHeight\")\n\np\n\n\n\n\nChord Diagram with links going in both directions."
  },
  {
    "objectID": "14-ChordDiagramPlots.html#add-padding-to-the-labels",
    "href": "14-ChordDiagramPlots.html#add-padding-to-the-labels",
    "title": "\n13  Chord Diagram plots\n",
    "section": "\n13.5 Add padding to the labels",
    "text": "13.5 Add padding to the labels\nOne can add more padding to the labels by using padding_labels. The number provided is the amount of whitespaces padding the label.\n\n# Add more padding to the labels.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 padding_labels = 8)\n\np\n\n\n\n\nChord Diagram with extra padding."
  },
  {
    "objectID": "14-ChordDiagramPlots.html#scale-the-nodes",
    "href": "14-ChordDiagramPlots.html#scale-the-nodes",
    "title": "\n13  Chord Diagram plots\n",
    "section": "\n13.6 Scale the nodes",
    "text": "13.6 Scale the nodes\nIf we want to show the nodes with equal size, links reflecting a proportion instead, we can set scale = TRUE.\n\n# Scale the size of the nodes.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 scale = TRUE,\n                                 padding_labels = 8)\n\np\n\n\n\n\nChord Diagram with scaled nodes."
  },
  {
    "objectID": "14-ChordDiagramPlots.html#self-linking",
    "href": "14-ChordDiagramPlots.html#self-linking",
    "title": "\n13  Chord Diagram plots\n",
    "section": "\n13.7 Self linking",
    "text": "13.7 Self linking\nWe can also control whether we want to allow self linking between the nodes or not. For this, we can set self.link = 2 to allow them or self.link = 1 to prevent them.\n\n# Prevent self linking.\nsample$seurat_clusters2 <- sample$seurat_clusters\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"seurat_clusters2\",\n                                 self.link = 1,\n                                 scale = TRUE)\n\np\n\n\n\n\nChord Diagram with prevented self linking.\n\n\n\n# Allow self linking.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"seurat_clusters2\",\n                                 self.link = 2,\n                                 scale = TRUE)\n\np\n\n\n\n\nChord Diagram with allowed self linking."
  },
  {
    "objectID": "14-ChordDiagramPlots.html#control-the-appearance-of-the-arrows",
    "href": "14-ChordDiagramPlots.html#control-the-appearance-of-the-arrows",
    "title": "\n13  Chord Diagram plots\n",
    "section": "\n13.8 Control the appearance of the arrows",
    "text": "13.8 Control the appearance of the arrows\nThe arrows can be modified by using link.arr.type parameter:\n\n# Set triangle arrows.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 link.arr.type = \"triangle\")\n\np\n\n\n\n\nChord Diagram with triangle arrows.\n\n\n\n# Set big arrows.\np <- SCpubr::do_ChordDiagramPlot(sample = sample,\n                                 from = \"seurat_clusters\",\n                                 to = \"assignment\",\n                                 link.arr.type = \"big.arrow\")\n\np\n\n\n\n\nChord Diagram with big arrows."
  },
  {
    "objectID": "15-VolcanoPlots.html#basic-usage",
    "href": "15-VolcanoPlots.html#basic-usage",
    "title": "\n14  Volcano plots\n",
    "section": "\n14.1 Basic usage",
    "text": "14.1 Basic usage\nTo generate such a plot, one can use SCpubr::do_VolcanoPlot(), which needs as input the Seurat object and the result of running Seurat::FindMarkers() choosing two groups.\n\n\n\n\n# Generate a volcano plot.\np <- SCpubr::do_VolcanoPlot(sample = sample,\n                            de_genes = de_genes)\np\n\n\n\nBasic volcano plot.\n\n\n\n\nAs you can see, there are four major groups of genes: - Genes that surpass our p-value and logFC cutoffs (blue). - Genes that surpass the p-value cutoff but not the logFC cutoff (orange). - Genes that surpass the logFC cutoff but not the p-value cutoff (purple, not shown). - Genes that do not surpass any cutoff (green)."
  },
  {
    "objectID": "15-VolcanoPlots.html#modify-the-cutoffss",
    "href": "15-VolcanoPlots.html#modify-the-cutoffss",
    "title": "\n14  Volcano plots\n",
    "section": "\n14.2 Modify the cutoffss",
    "text": "14.2 Modify the cutoffss\nThe cutofss can be set up by the user using pval_cutoff (without -log10 transforming) and FC_cutoff (avg log2(FC)).\n\n# Modify cutoffs.\np <- SCpubr::do_VolcanoPlot(sample = sample,\n                            de_genes = de_genes,\n                            pval_cutoff = 1e-50,\n                            FC_cutoff = 0.2)\np\n\n\n\nModify cutoffs."
  },
  {
    "objectID": "15-VolcanoPlots.html#modify-the-gene-tags",
    "href": "15-VolcanoPlots.html#modify-the-gene-tags",
    "title": "\n14  Volcano plots\n",
    "section": "\n14.3 Modify the gene tags",
    "text": "14.3 Modify the gene tags\nBy default, the top 5 genes on each side, ordered by -log10(p-value adjusted) and average log2(FC) are reported. However, one can increase the number by using\n\n# Modify number of gene tags.\np <- SCpubr::do_VolcanoPlot(sample = sample,\n                            de_genes = de_genes,\n                            n_genes = 15)\np\n\n\n\nModify the number of gene tags to display."
  },
  {
    "objectID": "16-GroupwiseDEPlots.html#increase-the-number-of-genes",
    "href": "16-GroupwiseDEPlots.html#increase-the-number-of-genes",
    "title": "\n15  Group-wise DE analysis plots\n",
    "section": "\n15.1 Increase the number of genes",
    "text": "15.1 Increase the number of genes\nThe number of top DE genes by cluster can be increased or reduced by using top_genes.\n\n# Increase the number of top DE genes by cluster.\np <- SCpubr::do_GroupwiseDEPlot(sample = sample,\n                                de_genes = de_genes,\n                                top_genes = 10)\n\np\n\n\n\nIncrease the number of genes per group."
  },
  {
    "objectID": "16-GroupwiseDEPlots.html#modify-the-titles-of-the-rows-and-columns",
    "href": "16-GroupwiseDEPlots.html#modify-the-titles-of-the-rows-and-columns",
    "title": "\n15  Group-wise DE analysis plots\n",
    "section": "\n15.2 Modify the titles of the rows and columns",
    "text": "15.2 Modify the titles of the rows and columns\nWe can also modify the row titles of the other heatmap bodies with row_title_p_values, row_title_expression and row_title_logfc and the column titles with column_title and the angle of rotation of the row titles with\n\n# Modify the row and column titles and the rotation.\np <- SCpubr::do_GroupwiseDEPlot(sample = sample,\n                                de_genes = de_genes,\n                                column_title = \"Title A\",\n                                row_title_p_values = \"Title B\",\n                                row_title_logfc = \"Title C\",\n                                row_title_expression = \"Title D\",\n                                row_title_rot = 0)\n\np\n\n\n\nModify row and column titles and rotation."
  },
  {
    "objectID": "16-GroupwiseDEPlots.html#add-further-layers-of-mean-expression",
    "href": "16-GroupwiseDEPlots.html#add-further-layers-of-mean-expression",
    "title": "\n15  Group-wise DE analysis plots\n",
    "section": "\n15.3 Add further layers of mean expression",
    "text": "15.3 Add further layers of mean expression\nOne can add more groupings to the heatmap of mean expression values by making use of group.by parameter, that is set to seurat_clusters by default. As they will surely be other groups different than the ones the DE genes were computed to, we need to provide as many row titles for the new heatmaps as values in group.by, even if it is empty characters.\n\nsample$modified_orig.ident <- sample(x = c(\"Sample_A\", \"Sample_B\", \"Sample_C\"), \n                                     size = ncol(sample), \n                                     replace = TRUE, \n                                     prob = c(0.2, 0.7, 0.1))\n\n# Add more layers of mean expression with group.by.\np <- SCpubr::do_GroupwiseDEPlot(sample = sample,\n                                de_genes = de_genes,\n                                group.by = c(\"seurat_clusters\", \n                                             \"modified_orig.ident\", \n                                             \"orig.ident\"),\n                                row_title_expression = c(\"\",\n                                                         \"Title A\",\n                                                         \"Title B\"))\n\np\n\n\n\nAdd more expression heatmaps.\n\n\n\n\nThis can be useful if we have different groupings we want to inspect at the same time. Also, the color scale is shared by all expression heatmaps."
  },
  {
    "objectID": "16-GroupwiseDEPlots.html#modify-color-scales",
    "href": "16-GroupwiseDEPlots.html#modify-color-scales",
    "title": "\n15  Group-wise DE analysis plots\n",
    "section": "\n15.4 Modify color scales",
    "text": "15.4 Modify color scales\nWe can modify the color scales for each of the three main types of heatmaps with viridis_map_pvalues, viridis_map_logfc and viridis_map_expression, and providing a letter corresponding to a color scale.\n\n# Change the viridis scales.\np <- SCpubr::do_GroupwiseDEPlot(sample = sample,\n                                de_genes = de_genes,\n                                viridis_map_pvalues = \"C\",\n                                viridis_map_logfc = \"E\",\n                                viridis_map_expression = \"D\")\n\np\n\n\n\nModify color scales."
  },
  {
    "objectID": "17-GroupedGOPlots.html#basic-usage",
    "href": "17-GroupedGOPlots.html#basic-usage",
    "title": "\n16  Grouped GO Term analysis plots\n",
    "section": "\n16.1 Basic usage",
    "text": "16.1 Basic usage\nThe basic usage of this function will compute all the GO terms associated with the genes for the Biological Process ontology, and return all the matrices for all the levels as well as the individual heatmaps for each level plus a combined one with all of them. All of this is returned as a list object, that we can then navigate to obtain the plot/matrix that we want. We will also need a database object, such as the one provided by the org.Hs.eg.db package.\n\ngenes.use <- c(\"CENPK\", \"CENPE\", \"BRCA1\", \"VWF\", \"CD8A\")\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_GroupedGOTermPlot(genes = genes.use,\n                                    org.db = org.Hs.eg.db)\n\nHere is how the one of the output matrices looks like:\n\n# Retrieve one of the output matrices.\nhead(out$Matrices$BP$`Lv. 3`)\n#>                    ID\n#> GO:0050794 GO:0050794\n#> GO:0048518 GO:0048518\n#> GO:0050789 GO:0050789\n#> GO:0007049 GO:0007049\n#> GO:0007059 GO:0007059\n#> GO:0007154 GO:0007154\n#>                                          Description Count\n#> GO:0050794            Regulation of cellular process     4\n#> GO:0048518 Positive regulation of biological process     4\n#> GO:0050789          Regulation of biological process     4\n#> GO:0007049                                Cell cycle     3\n#> GO:0007059                    Chromosome segregation     3\n#> GO:0007154                        Cell communication     3\n#>            GeneRatio               geneID\n#> GO:0050794       4/5 CENPE/BRCA1/VWF/CD8A\n#> GO:0048518       4/5 CENPE/BRCA1/VWF/CD8A\n#> GO:0050789       4/5 CENPE/BRCA1/VWF/CD8A\n#> GO:0007049       3/5    CENPK/CENPE/BRCA1\n#> GO:0007059       3/5    CENPK/CENPE/BRCA1\n#> GO:0007154       3/5       BRCA1/VWF/CD8A\n\nAnd this is the output combined heatmap:\n\n# Plot the output combined heatmap.\nout$Plots$BP$Combined\n\n\n\nCombined heatmap.\n\n\n\n\n\n\n\n\n\n\nPlease note:\n\n\n\nThis function might take a while to compute, specially for the Biological Process ontology. If you are running it interactively, consider passing verbose = TRUE to see the process."
  },
  {
    "objectID": "17-GroupedGOPlots.html#control-the-clustering-of-the-rows-and-columns",
    "href": "17-GroupedGOPlots.html#control-the-clustering-of-the-rows-and-columns",
    "title": "\n16  Grouped GO Term analysis plots\n",
    "section": "\n16.2 Control the clustering of the rows and columns",
    "text": "16.2 Control the clustering of the rows and columns\nBy default, both rows and columns are clustered to group the terms together. If one wants to customize this behaviour, we just need to pass cluster_cols = FALSE or cluster_rows = FALSE to the function:\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_GroupedGOTermPlot(genes = genes.use,\n                                    org.db = org.Hs.eg.db,\n                                    cluster_rows = FALSE,\n                                    cluster_cols = FALSE)\n\n# Plot the output combined heatmap.\nout$Plots$BP$Combined\n\n\n\nControl the clustering of rows and columns."
  },
  {
    "objectID": "17-GroupedGOPlots.html#limit-the-number-of-terms-reported",
    "href": "17-GroupedGOPlots.html#limit-the-number-of-terms-reported",
    "title": "\n16  Grouped GO Term analysis plots\n",
    "section": "\n16.3 Limit the number of terms reported",
    "text": "16.3 Limit the number of terms reported\nBy default, the terms displays have to be shared in between three of the genes if the provided list of genes has more than four genes. However, we can control this behavior using min.overlap:\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_GroupedGOTermPlot(genes = genes.use,\n                                    org.db = org.Hs.eg.db,\n                                    min.overlap = 4)\n\n# Plot the output combined heatmap.\nout$Plots$BP$Combined\n\n\n\nLimit the number of terms reported."
  },
  {
    "objectID": "17-GroupedGOPlots.html#flip-the-output-heatmap",
    "href": "17-GroupedGOPlots.html#flip-the-output-heatmap",
    "title": "\n16  Grouped GO Term analysis plots\n",
    "section": "\n16.4 Flip the output heatmap",
    "text": "16.4 Flip the output heatmap\nWe might as well be interested in having a vertically-aligned heatmap instead. This can be achieved by using flip = FALSE (as the default version is already flipped).\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_GroupedGOTermPlot(genes = genes.use,\n                                    org.db = org.Hs.eg.db,\n                                    min.overlap = 4,\n                                    flip = FALSE)\n\n# Plot the output combined heatmap.\nout$Plots$BP$Combined\n\n\n\nFlip the output heatmap."
  },
  {
    "objectID": "17-GroupedGOPlots.html#restrict-the-ontology-levels",
    "href": "17-GroupedGOPlots.html#restrict-the-ontology-levels",
    "title": "\n16  Grouped GO Term analysis plots\n",
    "section": "\n16.5 Restrict the ontology levels",
    "text": "16.5 Restrict the ontology levels\nIf we are sure of which ontology levels we want to display the terms, we can restrict the output to those by using levels.use. This works in combination with min.overlap.\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_GroupedGOTermPlot(genes = genes.use,\n                                    org.db = org.Hs.eg.db,\n                                    min.overlap = 4,\n                                    levels.use = c(1, 2, 3, 4))\n\n# Plot the output combined heatmap.\nout$Plots$BP$Combined\n\n\n\nRestrict the ontology levels."
  },
  {
    "objectID": "17-GroupedGOPlots.html#select-other-go-ontologies",
    "href": "17-GroupedGOPlots.html#select-other-go-ontologies",
    "title": "\n16  Grouped GO Term analysis plots\n",
    "section": "\n16.6 Select other GO ontologies",
    "text": "16.6 Select other GO ontologies\nWe can retrieve terms for other GO ontologies by using GO_ontology parameter with either:\n\n\nBP: For Biological Process.\n\nMF: For Molecular Function.\n\nCC: For Cellular Component.\n\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_GroupedGOTermPlot(genes = genes.use,\n                                    org.db = org.Hs.eg.db,\n                                    min.overlap = 2,\n                                    GO_ontology = \"MF\")\n\n# Plot the output combined heatmap.\nout$Plots$MF$Combined\n\n\n\nUse other GO ontologies."
  },
  {
    "objectID": "17-GroupedGOPlots.html#reverse-the-order-of-the-heatmaps",
    "href": "17-GroupedGOPlots.html#reverse-the-order-of-the-heatmaps",
    "title": "\n16  Grouped GO Term analysis plots\n",
    "section": "\n16.7 Reverse the order of the heatmaps",
    "text": "16.7 Reverse the order of the heatmaps\nAs can be noticed, the heatmaps are ordered in inverse order. This is due to the fact that ComplexHeatmap arranges the alignment of heatmaps using one as a principal heatmap. By using the normal ordering, the rows are columns, that are clustered, will be done based on the low-level terms instead of the most specific ones. However, this behaviour can be reverted using reverse.levels = FALSE.\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_GroupedGOTermPlot(genes = genes.use,\n                                    org.db = org.Hs.eg.db,\n                                    min.overlap = 4,\n                                    levels.use = c(1, 2, 3, 4),\n                                    reverse.levels = FALSE)\n\n# Plot the output combined heatmap.\nout$Plots$BP$Combined\n\n\n\nReverse the order of the heatmaps."
  },
  {
    "objectID": "17-GroupedGOPlots.html#increase-the-gap-between-heatmaps",
    "href": "17-GroupedGOPlots.html#increase-the-gap-between-heatmaps",
    "title": "\n16  Grouped GO Term analysis plots\n",
    "section": "\n16.8 Increase the gap between heatmaps",
    "text": "16.8 Increase the gap between heatmaps\nBy default, this is set to 0.5 cm by the heatmap_gap parameter.\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_GroupedGOTermPlot(genes = genes.use,\n                                    org.db = org.Hs.eg.db,\n                                    min.overlap = 4,\n                                    levels.use = c(1, 2, 3, 4),\n                                    heatmap_gap = 1)\n\n# Plot the output combined heatmap.\nout$Plots$BP$Combined\n\n\n\nIncrease the gap between heatmaps."
  },
  {
    "objectID": "17-GroupedGOPlots.html#increase-the-cell-size-of-the-heatmap",
    "href": "17-GroupedGOPlots.html#increase-the-cell-size-of-the-heatmap",
    "title": "\n16  Grouped GO Term analysis plots\n",
    "section": "\n16.9 Increase the cell size of the heatmap",
    "text": "16.9 Increase the cell size of the heatmap\nWe can modify the tile size of the heatamaps by using cell_size paramter:\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_GroupedGOTermPlot(genes = genes.use,\n                                    org.db = org.Hs.eg.db,\n                                    min.overlap = 4,\n                                    levels.use = c(1, 2, 3, 4),\n                                    cell_size = 7)\n\n# Plot the output combined heatmap.\nout$Plots$BP$Combined\n\n\n\nModify the tile size."
  },
  {
    "objectID": "17-GroupedGOPlots.html#modify-default-colors",
    "href": "17-GroupedGOPlots.html#modify-default-colors",
    "title": "\n16  Grouped GO Term analysis plots\n",
    "section": "\n16.10 Modify default colors",
    "text": "16.10 Modify default colors\nFinally, we can modify the default colors of the heatmap by using colors.use and provide two colors. The first will map to the absent values and the second to the present values.\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_GroupedGOTermPlot(genes = genes.use,\n                                    org.db = org.Hs.eg.db,\n                                    min.overlap = 4,\n                                    levels.use = c(1, 2, 3, 4),\n                                    colors.use = c(\"lightblue\", \"navyblue\"))\n\n# Plot the output combined heatmap.\nout$Plots$BP$Combined\n\n\n\nModify the colors."
  },
  {
    "objectID": "17-FunctionalEnrichmentPlots.html#basic-output",
    "href": "17-FunctionalEnrichmentPlots.html#basic-output",
    "title": "\n17  Functional Annotation Analysis plots\n",
    "section": "\n17.1 Basic output",
    "text": "17.1 Basic output\nThe basic output of SCpubr::do_FunctionalAnnotationPlot()contains a list with several plots, and can be computed by providing the function with a list of genes and a database object, such as the one provided by the org.Hs.eg.db package:\n\ngenes.use <- c(\"CCR7\", \"CD14\", \"LYZ\", \n           \"S100A4\", \"MS4A1\", \n           \"MS4A7\", \"GNLY\", \"NKG7\", \"FCER1A\", \n           \"CST3\", \"PPBP\")\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_FunctionalAnnotationPlot(genes = genes.use,\n                                           org.db = org.Hs.eg.db)\n\nThis reports a list containing four complementary plots. The first, is a heatmap that contains the overlap between the genes and the term, the gene count and their corresponding adjusted p-value:\n\n# Retrieve the heatmap.\nout$Heatmap\n\n\n\nHeatmap of reported terms.\n\n\n\n\nSecond, is a bar plot showing the enriched terms with the height of the bars corresponding to the gene count per term, and the color or the bars corresponding to the adjusted p-value associated to the terms:\n\n# Retrieve the Bar plot.\nout$BarPlot\n\n\n\nBar plot of reported terms.\n\n\n\n\nAlmost identical, we can also retrieve a Dot plot in which the size of the dots correspond to the number of genes supporting the term and the color to the adjusted p-value:\n\n# Retrieve the Dot plot.\nout$DotPlot\n\n\n\nDot plot of reported terms.\n\n\n\n\nFinally, and thanks to enrichplot package, we can also obtain a customized hierarchical visualization of the enriched terms called Tree plot:\n\n# Retrieve the Tree plot.\nout$TreePlot\n\n\n\nTree plot of reported terms.\n\n\n\n\nWe can control the number of clusters and the number of high-frequency words with nClusters and nWords parameters. Similarly, the total number of terms to display (if available), can be controlled using showCategory parameter.\n\n\n\n\n\n\nPlease note:\n\n\n\nThe right-most labels refer to high frequency words, not to the GO terms on a level above. For more information please consult the official documentation for enrichplot package\nIt can also be the case that the high frequency words and the clusters behave a bit wonky. This has been observed already but is also related entirely to enrichplot package and the number of clusters selected by nClusters. If you are experiencing problems with this, consider reducing the number of nClusters."
  },
  {
    "objectID": "17-FunctionalEnrichmentPlots.html#limit-the-number-of-terms-reported",
    "href": "17-FunctionalEnrichmentPlots.html#limit-the-number-of-terms-reported",
    "title": "\n17  Functional Annotation Analysis plots\n",
    "section": "\n17.2 Limit the number of terms reported",
    "text": "17.2 Limit the number of terms reported\nSimilar to the previous chapter, we can decide whether we want more or less overlap between the genes for the reported terms using min.overlap:\n\n# Compute the grouped GO terms.\nout <- SCpubr::do_FunctionalAnnotationPlot(genes = genes.use,\n                                           org.db = org.Hs.eg.db,\n                                           min.overlap = 2)\n\n\n# Retrieve the heatmap.\nout$Heatmap\n\n\n\nHeatmap of reported terms.\n\n\n\n\n\n# Retrieve the Bar and Dot plot.\nout$BarPlot | out$DotPlot\n\n\n\nBar plot of reported terms.\n\n\n\n\n\n# Retrieve the Tree plot.\nout$TreePlot\n\n\n\nTree plot of reported terms."
  },
  {
    "objectID": "17-FunctionalEnrichmentPlots.html#compute-the-results-for-different-databases",
    "href": "17-FunctionalEnrichmentPlots.html#compute-the-results-for-different-databases",
    "title": "\n17  Functional Annotation Analysis plots\n",
    "section": "\n17.3 Compute the results for different databases",
    "text": "17.3 Compute the results for different databases\nWe can also query other database apart from GO. KEGG and MKEGG are also available, and can be selected using database parameter:\n\ngenes.use <- c(\"IL7R\", \"CCR7\", \"CD14\", \"LYZ\", \n           \"S100A4\", \"MS4A1\", \"CD8A\", \"FCGR3A\", \n           \"MS4A7\", \"GNLY\", \"NKG7\", \"FCER1A\", \n           \"CST3\", \"PPBP\")\n\n# Compute the grouped KEGG terms.\nout1 <- SCpubr::do_FunctionalAnnotationPlot(genes = genes.use,\n                                            org.db = org.Hs.eg.db,\n                                            database = \"KEGG\")\n\n\n# Retrieve the Bar and Dot plot.\nout1$DotPlot\n\n\n\nDot plot of reported KEGG terms."
  },
  {
    "objectID": "17-TermEnrichmentPlots.html#modifying-the-number-of-terms-to-retrieve.",
    "href": "17-TermEnrichmentPlots.html#modifying-the-number-of-terms-to-retrieve.",
    "title": "\n18  Term Enrichment Plots\n",
    "section": "\n18.1 Modifying the number of terms to retrieve.",
    "text": "18.1 Modifying the number of terms to retrieve.\nDepending on the focus of the analysis, we might want to only focus on one database but retrieve more terms from it. This can be achieved by using nterms parameter.\n\n# Increased number of terms.\np <- SCpubr::do_TermEnrichmentPlot(enriched_terms = enriched_terms,\n                                   nterms = 15)\np\n\n\n\nIncrease the number of terms."
  },
  {
    "objectID": "17-TermEnrichmentPlots.html#modifying-the-length-of-the-terms",
    "href": "17-TermEnrichmentPlots.html#modifying-the-length-of-the-terms",
    "title": "\n18  Term Enrichment Plots\n",
    "section": "\n18.2 Modifying the length of the terms",
    "text": "18.2 Modifying the length of the terms\nAnother issue with these plots is that, normally, the term itself takes too much space. For this, terms are wrapped according to a cutoff defined in nchar_wrap parameter. If the term has more characters than the value provided, it will be split more or less in half, always preserving whole words.\n\n# Control the length of the terms.\np1 <- SCpubr::do_TermEnrichmentPlot(enriched_terms = enriched_terms,\n                                    nterms = 15)\np2 <- SCpubr::do_TermEnrichmentPlot(enriched_terms = enriched_terms,\n                                    nterms = 15,\n                                    nchar_wrap = 30)\np <- p1 / p2\np\n\n\n\nControl the length of the terms.\n\n\n\n\nIn the same way, one can further enhance the limit in order to have each term in just one row."
  },
  {
    "objectID": "17-TermEnrichmentPlots.html#increase-the-font-size-of-the-labels",
    "href": "17-TermEnrichmentPlots.html#increase-the-font-size-of-the-labels",
    "title": "\n18  Term Enrichment Plots\n",
    "section": "\n18.3 Increase the font size of the labels",
    "text": "18.3 Increase the font size of the labels\nIf you want to increase the font size of the labels - this is, anything that is not part of the legend or the titles, use text_labels_size parameter:\n\n# Modify font size of the terms.\np1 <- SCpubr::do_TermEnrichmentPlot(enriched_terms = enriched_terms)\np2 <- SCpubr::do_TermEnrichmentPlot(enriched_terms = enriched_terms,\n                                    text_labels_size = 6)\n\np <- p1 / p2\np\n\n\n\nModify the font size of the terms."
  },
  {
    "objectID": "18-ExpressionHeatmaps.html#single-grouping-variable",
    "href": "18-ExpressionHeatmaps.html#single-grouping-variable",
    "title": "\n19  Expression heatmaps\n",
    "section": "\n19.1 Single grouping variable",
    "text": "19.1 Single grouping variable\n\n# Define list of genes.\ngenes <- c(\"IL7R\", \n           \"CCR7\", \n           \"CD14\", \n           \"LYZ\", \n           \"S100A4\", \n           \"MS4A1\", \n           \"CD8A\", \n           \"FCGR3A\", \n           \"MS4A7\", \n           \"GNLY\", \n           \"NKG7\", \n           \"FCER1A\", \n           \"CST3\", \n           \"PPBP\")\n\n# Default parameters.\np <- SCpubr::do_ExpressionHeatmap(sample = sample,\n                                  features = genes,\n                                  viridis_direction = -1)\np\n\n\n\nBasic output.\n\n\n\n\n\n\n\n\n\n\nPlease note:\n\n\n\nIn these cases, inverting the color scale with viridis_direction = -1 is the best choice as makes it easir to identify dark colors in the heatmap and they stand out more than it would do when it comes to using light colors on dark background.\n\n\nBy default, SCpubr::do_ExpressionHeatmap aggregates the values by the current identity. However, other metadata variables can be used to aggregate for. For this, provide the name to group.by parameter.\n\n# Custom aggregated values.\np <- SCpubr::do_ExpressionHeatmap(sample = sample,\n                                  features = genes,\n                                  group.by = \"annotation\",\n                                  viridis_direction = -1)\np\n\n\n\nGroup by a custom variable."
  },
  {
    "objectID": "18-ExpressionHeatmaps.html#several-groupoing-variables",
    "href": "18-ExpressionHeatmaps.html#several-groupoing-variables",
    "title": "\n19  Expression heatmaps\n",
    "section": "\n19.2 Several groupoing variables",
    "text": "19.2 Several groupoing variables\nHowever, more than one variable can be passsed at the same time to group.by:\n\n# Group by several variables.\np <- SCpubr::do_ExpressionHeatmap(sample = sample,\n                                  features = genes,\n                                  group.by = c(\"seurat_clusters\", \"orig.ident\", \"annotation\"),\n                                  viridis_direction = -1)\np\n\n\n\nGroup by several variables.\n\n\n\n\nOne can also customize the group titles by providing as many characters as variables in group.by to row_title:\n\n# Custom aggregated values.\np <- SCpubr::do_ExpressionHeatmap(sample = sample,\n                                  features = genes,\n                                  group.by = c(\"seurat_clusters\", \"orig.ident\", \"annotation\"),\n                                  row_title = c(\"A\", \"B\", \"C\"),\n                                  viridis_direction = -1)\np\n\n\n\nGroup by a custom variable."
  },
  {
    "objectID": "18-ExpressionHeatmaps.html#transpose-the-heatmaps",
    "href": "18-ExpressionHeatmaps.html#transpose-the-heatmaps",
    "title": "\n19  Expression heatmaps\n",
    "section": "\n19.3 Transpose the heatmaps",
    "text": "19.3 Transpose the heatmaps\nThe heatmaps can be transposed using flip = TRUE.\n\n# Transposing the matrix.\np <- SCpubr::do_ExpressionHeatmap(sample = sample,\n                                  features = genes,\n                                  flip = TRUE,\n                                  viridis_direction = -1)\np\n\n\n\nTranspose the matrix."
  },
  {
    "objectID": "18-ExpressionHeatmaps.html#modify-the-rotation-of-row-and-column-titles",
    "href": "18-ExpressionHeatmaps.html#modify-the-rotation-of-row-and-column-titles",
    "title": "\n19  Expression heatmaps\n",
    "section": "\n19.4 Modify the rotation of row and column titles",
    "text": "19.4 Modify the rotation of row and column titles\nBoth rows and column names can be rotated using column_names_rot and row_names_rot parameters, providing the desired angle.\n\n# Rotating the labels.\np <- SCpubr::do_ExpressionHeatmap(sample = sample,\n                                  features = genes,\n                                  flip = TRUE,\n                                  column_names_rot = 0,\n                                  viridis_direction = -1)\np\n\n\n\nRotate the labels."
  },
  {
    "objectID": "18-ExpressionHeatmaps.html#changing-the-cell-size-in-the-heatmap.",
    "href": "18-ExpressionHeatmaps.html#changing-the-cell-size-in-the-heatmap.",
    "title": "\n19  Expression heatmaps\n",
    "section": "\n19.5 Changing the cell size in the heatmap.",
    "text": "19.5 Changing the cell size in the heatmap.\nBy design, the aspect ratio of the tiles in the heatmap is fixed so that cells are squares, and not rectangles. However, the user has the possibility to increase/decrease the cell size of each tile by modifying cell_size parameter. This is set to 5 by default.\n\n# Modifying the tile size.\np <- SCpubr::do_ExpressionHeatmap(sample = sample,\n                                  features = genes,\n                                  flip = TRUE,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  cell_size = 10,\n                                  viridis_direction = -1)\np\n\n\n\nChange the size of the cells."
  },
  {
    "objectID": "18-ExpressionHeatmaps.html#symmetrical-scales",
    "href": "18-ExpressionHeatmaps.html#symmetrical-scales",
    "title": "\n19  Expression heatmaps\n",
    "section": "\n19.6 Symmetrical scales",
    "text": "19.6 Symmetrical scales\nIf one wants a symmetrical scale,\n\n# Symmetrical scale viriis.\np <- SCpubr::do_ExpressionHeatmap(sample = sample,\n                                  features = genes,\n                                  flip = TRUE,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  enforce_symmetry = TRUE)\np\n\n\n\nUse a symmetrical color scale.\n\n\n\n\nFor such cases, it is best to set use_viridis = FALSE.\n\n# Modifying the symmetrical scale non viridis.\np <- SCpubr::do_ExpressionHeatmap(sample = sample,\n                                  features = genes,\n                                  flip = TRUE,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  enforce_symmetry = TRUE,\n                                  use_viridis = FALSE)\np\n\n\n\nUse a symmetrical color scale that is not viridis."
  },
  {
    "objectID": "18-ExpressionHeatmaps.html#subset-the-color-scale.",
    "href": "18-ExpressionHeatmaps.html#subset-the-color-scale.",
    "title": "\n19  Expression heatmaps\n",
    "section": "\n19.7 Subset the color scale.",
    "text": "19.7 Subset the color scale.\nIt might be the case that a single gene set, for a single cluster, drives the color scale entirely. We can treat this as an outlier, so that we can subset the color scale to better represent the values in between. We can achieve that by using min.cutoff and/or max.cutoff.\n\n# Subset the color scale.\np <- SCpubr::do_ExpressionHeatmap(sample = sample,\n                                  features = genes,\n                                  flip = TRUE,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  min.cutoff = 0.2,\n                                  max.cutoff = 0.7,\n                                  viridis_direction = -1)\np\n\n\n\nSubset the color scale."
  },
  {
    "objectID": "18-ExpressionHeatmaps.html#use-of-metadata-variables",
    "href": "18-ExpressionHeatmaps.html#use-of-metadata-variables",
    "title": "\n19  Expression heatmaps\n",
    "section": "\n19.8 Use of metadata variables",
    "text": "19.8 Use of metadata variables\nBy design, this function expects to work with expression values, as the overall idea of the plot is to assess similarities/differences between averaged expression levels. However, it might be the case that you might have some metadata values that you would also like to plot in a similar way.\nHere is a workaround to make that possible:\n\n# Vector of features stored in the metadata.\nmy_features <- c(\"A\", \"B\", \"C\")\n\n# Retrieve your scores.\nscores <- sample@meta.data[, my_features]\n\n# Turn it into a matrix (metadata columns become the features - rows, cells remain as columns).\nscores <- t(as.matrix(scores))\n\n# Create an assay object.\nscores_assay <- Seurat::CreateAssayObject(counts = scores)\n\n# Add it to your Seurat object.\nsample@assays$my_new_assay <- scores_assay\n\n# Plot the features.\np <- SCpubr::do_ExpressionHeatmap(sample = sample, \n                                  features = my_features, \n                                  assay = \"my_new_assay\")\np"
  },
  {
    "objectID": "18-EnrichmentHeatmaps.html#single-grouping-variable",
    "href": "18-EnrichmentHeatmaps.html#single-grouping-variable",
    "title": "\n20  Enrichment score heatmaps\n",
    "section": "\n20.1 Single grouping variable",
    "text": "20.1 Single grouping variable\n\n# Define list of genes.\ngenes <- list(\"Naive CD4+ T\" = c(\"IL7R\", \"CCR7\"),\n              \"CD14+ Mono\" = c(\"CD14\", \"LYZ\"),\n              \"Memory CD4+\" = c(\"S100A4\"),\n              \"B\" = c(\"MS4A1\"),\n              \"CD8+ T\" = c(\"CD8A\"),\n              \"FCGR3A+ Mono\" = c(\"FCGR3A\", \"MS4A7\"),\n              \"NK\" = c(\"GNLY\", \"NKG7\"),\n              \"DC\" = c(\"FCER1A\", \"CST3\"),\n              \"Platelet\" = c(\"PPBP\"))\n\n# Default parameters.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  viridis_direction = -1)\np\n\n\n\nBasic output.\n\n\n\n\n\n\n\n\n\n\nPlease note:\n\n\n\nIn these cases, inverting the color scale with viridis_direction = -1 is the best choice as makes it easir to identify dark colors in the heatmap and they stand out more than it would do when it comes to using light colors on dark background.\n\n\nBy default, SCpubr::do_EnrichmentHeatmap aggregates the values by the current identity. However, other metadata variables can be used to aggregate for. For this, provide the name to group.by parameter.\n\n# Custom aggregated values.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  group.by = \"orig.ident\",\n                                  viridis_direction = -1)\np\n\n\n\nGroup by a custom variable."
  },
  {
    "objectID": "18-EnrichmentHeatmaps.html#several-groupoing-variables",
    "href": "18-EnrichmentHeatmaps.html#several-groupoing-variables",
    "title": "\n20  Enrichment score heatmaps\n",
    "section": "\n20.2 Several groupoing variables",
    "text": "20.2 Several groupoing variables\nHowever, more than one variable can be passsed at the same time to group.by:\n\n# Group by several variables.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  group.by = c(\"seurat_clusters\", \"orig.ident\", \"annotation\"),\n                                  viridis_direction = -1)\np\n\n\n\nGroup by several variables.\n\n\n\n\nOne can also customize the group titles by providing as many characters as variables in group.by to row_title:\n\n# Custom aggregated values.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  group.by = c(\"seurat_clusters\", \"orig.ident\", \"annotation\"),\n                                  row_title = c(\"A\", \"B\", \"C\"),\n                                  viridis_direction = -1)\np\n\n\n\nGroup by a custom variable."
  },
  {
    "objectID": "18-EnrichmentHeatmaps.html#transpose-the-heatmaps",
    "href": "18-EnrichmentHeatmaps.html#transpose-the-heatmaps",
    "title": "\n20  Enrichment score heatmaps\n",
    "section": "\n20.3 Transpose the heatmaps",
    "text": "20.3 Transpose the heatmaps\nThe heatmaps can be transposed using flip = TRUE.\n\n# Transposing the matrix.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  flip = TRUE,\n                                  viridis_direction = -1)\np\n\n\n\nTranspose the matrix."
  },
  {
    "objectID": "18-EnrichmentHeatmaps.html#modify-the-rotation-of-row-and-column-titles",
    "href": "18-EnrichmentHeatmaps.html#modify-the-rotation-of-row-and-column-titles",
    "title": "\n20  Enrichment score heatmaps\n",
    "section": "\n20.4 Modify the rotation of row and column titles",
    "text": "20.4 Modify the rotation of row and column titles\nBoth rows and column names can be rotated using column_names_rot and row_names_rot parameters, providing the desired angle.\n\n# Rotating the labels.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  flip = TRUE,\n                                  column_names_rot = 0,\n                                  viridis_direction = -1)\np\n\n\n\nRotate the labels."
  },
  {
    "objectID": "18-EnrichmentHeatmaps.html#changing-the-cell-size-in-the-heatmap.",
    "href": "18-EnrichmentHeatmaps.html#changing-the-cell-size-in-the-heatmap.",
    "title": "\n20  Enrichment score heatmaps\n",
    "section": "\n20.5 Changing the cell size in the heatmap.",
    "text": "20.5 Changing the cell size in the heatmap.\nBy design, the aspect ratio of the tiles in the heatmap is fixed so that cells are squares, and not rectangles. However, the user has the possibility to increase/decrease the cell size of each tile by modifying cell_size parameter. This is set to 5 by default.\n\n# Modifying the tile size.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  flip = TRUE,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  cell_size = 7,\n                                  viridis_direction = -1)\np\n\n\n\nChange the size of the cells."
  },
  {
    "objectID": "18-EnrichmentHeatmaps.html#symmetrical-scales",
    "href": "18-EnrichmentHeatmaps.html#symmetrical-scales",
    "title": "\n20  Enrichment score heatmaps\n",
    "section": "\n20.6 Symmetrical scales",
    "text": "20.6 Symmetrical scales\nIf one wants a symmetrical scale,\n\n# Symmetrical scale viriis.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  flip = TRUE,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  enforce_symmetry = TRUE)\np\n\n\n\nUse a symmetrical color scale.\n\n\n\n\nFor such cases, it is best to set use_viridis = FALSE.\n\n# Modifying the symmetrical scale non viridis.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  flip = TRUE,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  enforce_symmetry = TRUE,\n                                  use_viridis = FALSE)\np\n\n\n\nUse a symmetrical color scale that is not viridis."
  },
  {
    "objectID": "18-EnrichmentHeatmaps.html#compute-other-type-of-scorings",
    "href": "18-EnrichmentHeatmaps.html#compute-other-type-of-scorings",
    "title": "\n20  Enrichment score heatmaps\n",
    "section": "\n20.7 Compute other type of scorings",
    "text": "20.7 Compute other type of scorings\nSimilar to Seurat::AddModuleScore(), other enrichment scoring methods have been developed. One of such is UCell. To use it as scoring method, simply pass flavor = \"UCell\":\n\n# Use UCell scoring.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  flip = TRUE,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  flavor = \"UCell\",\n                                  viridis_direction = -1)\np\n\n\n\nUse UCell Scoring.\n\n\n\n\nAlternatively, AUCell scoring is also available using flavor = \"AUCell\".\n\n# Use AUCell scoring.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  flip = TRUE,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  flavor = \"AUCell\",\n                                  viridis_direction = -1)\np\n\n\n\nUse AUCell Scoring."
  },
  {
    "objectID": "18-EnrichmentHeatmaps.html#subset-the-color-scale.",
    "href": "18-EnrichmentHeatmaps.html#subset-the-color-scale.",
    "title": "\n20  Enrichment score heatmaps\n",
    "section": "\n20.8 Subset the color scale.",
    "text": "20.8 Subset the color scale.\nIt might be the case that a single gene set, for a single cluster, drives the color scale entirely. We can treat this as an outlier, so that we can subset the color scale to better represent the values in between. We can achieve that by using min.cutoff and/or max.cutoff.\n\n# Subset the color scale.\np <- SCpubr::do_EnrichmentHeatmap(sample = sample,\n                                  input_gene_list = genes,\n                                  flip = TRUE,\n                                  cluster_cols = FALSE,\n                                  cluster_rows = TRUE,\n                                  flavor = \"UCell\",\n                                  min.cutoff = 0.2,\n                                  max.cutoff = 0.7,\n                                  viridis_direction = -1)\np\n\n\n\nSubset the color scale."
  },
  {
    "objectID": "19-CorrelationHeatmaps.html#using-highly-variable-genes",
    "href": "19-CorrelationHeatmaps.html#using-highly-variable-genes",
    "title": "\n21  Correlation matrix heatmaps\n",
    "section": "\n21.1 Using Highly Variable Genes",
    "text": "21.1 Using Highly Variable Genes\n\n# Default values.\np <- SCpubr::do_CorrelationPlot(sample = sample, \n                                cell_size = 10)\np\n\n\n\nBasic output.\n\n\n\n\nBy default, it computes the correlation over the current identities in the object. This can be changed by providing another metadata variable to group.by.\n\n# Custom grouping.\nsample$custom_group <- ifelse(sample$seurat_clusters %in% c(\"1\", \"3\", \"5\", \"7\", \"9\"), \"Group A\", \"Group B\")\np <- SCpubr::do_CorrelationPlot(sample = sample, \n                                group.by = \"custom_group\", \n                                cell_size = 10)\np\n\n\n\nApply a custom grouping.\n\n\n\n\nAxes labels can also be rotated.\n\n\n# Rotated axis labels.\np <- SCpubr::do_CorrelationPlot(sample = sample,\n                                column_names_rot = 90, \n                                cell_size = 10)\np\n\n\n\nRotate axis labels."
  },
  {
    "objectID": "19-CorrelationHeatmaps.html#changing-the-cell-size-in-the-heatmap",
    "href": "19-CorrelationHeatmaps.html#changing-the-cell-size-in-the-heatmap",
    "title": "\n21  Correlation matrix heatmaps\n",
    "section": "\n21.2 Changing the cell size in the heatmap",
    "text": "21.2 Changing the cell size in the heatmap\nSame as with Enrichment Heatmaps, the aspect ratio of the tiles in the heatmap is fixed so that cells are squares, and not rectangles. This can be changed modifying cell_size parameter. This is set to 5 by default.\n\n# Increase cell size.\np <- SCpubr::do_CorrelationPlot(sample = sample,\n                                column_names_rot = 0,\n                                cell_size = 12)\np\n\n\n\nModify the cell size of the heatmap."
  },
  {
    "objectID": "20-CellularStatesPlot.html#two-variable-plots",
    "href": "20-CellularStatesPlot.html#two-variable-plots",
    "title": "\n22  Cellular State Plots\n",
    "section": "\n22.1 Two variable plots",
    "text": "22.1 Two variable plots\n\nThis is the easiest case. For this, the user needs to provide the name of two gene signatures present in the list of genes provided to input_gene_list parameter: - x1: The enrichment scores computed for this list will be displayed on the X axis. - y1: The enrichment scores computed for this list will be displayed on the Y axis.\n\n# 2 Variables\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"B\")\np\n\n\n\nOutput using two lists of genes.\n\n\n\n\nThis way, we can see how much effect gene set A has with regards to gene set B. One can further enforce some symmetry in the plot with enforce_symmetry = TRUE.\n\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"B\",\n                                   enforce_symmetry = TRUE)\np\n\n\n\nOutput using two lists of genes and enforcing symmetry."
  },
  {
    "objectID": "20-CellularStatesPlot.html#three-variable-plots",
    "href": "20-CellularStatesPlot.html#three-variable-plots",
    "title": "\n22  Cellular State Plots\n",
    "section": "\n22.2 Three variable plots",
    "text": "22.2 Three variable plots\n\nThis plot is retrieved from Tirosh, et al, 2016 and plot requires the user to provide three gene sets, for which enrichment scores are computed using Seurat::AddModuleScore. For the X axis, two gene sets are assigned to it. Cells will be placed towards the right if they are enriched in x1 and towards the left if they are enriched in x2. This is decided by, first, retrieving the enrichment scores for both lists and keeping the highest out of the two. The score will turn positive or negative depending on the gene list for which the highest enrichment score belonged to: positive for x1 and negative for x2. For the Y axis. one gene set is provided. The value for the Y axis is computed by subtracting to the enrichment scores for y1 the value for the X axis.\nThis plot makes a lot of sense, as showcased by Tirosh, et al, 2016, when the Y axis shows a differentiation trajectory. This is, it contains enrichment scores for stemness genes. Therefore, the lower on the Y axis, the less stem a given cell is. On the X axis, cells will order depending on whether they are enriched more in x1 or x2. the more extreme the value on the X axis, the more differentiated towards the given list of genes the cell will be.\n\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"B\",\n                                   x2 = \"C\")\np\n\n\n\nOutput using three lists of genes.\n\n\n\n\nIf enforce_symmetry is set to true, the X axis will have 0 as middle point.\n\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"B\",\n                                   x2 = \"C\",\n                                   enforce_symmetry = TRUE)\np\n\n\n\nOutput using three lists of genes and enforcing symmetry."
  },
  {
    "objectID": "20-CellularStatesPlot.html#four-variable-plots",
    "href": "20-CellularStatesPlot.html#four-variable-plots",
    "title": "\n22  Cellular State Plots\n",
    "section": "\n22.3 Four variable plots",
    "text": "22.3 Four variable plots\n\nThis the most complicated variant of the plot, retrieved from Neftel, et al, 2019. This makes use of four gene sets: x1, x2, y1 and y2. As a general, brief description, enrichment scores are computed for all 4 gene sets and the cells will locate in the resulting figure according to the list they are most enriched on, towards a given corner, following the scheme shown above.\nThis is achieved by assuming: - x1 and x2 are connected, so are y1 and y2. The first step will be to decide which the highest score out of x1-x2 and y1-y2, which will locate the cells either on the upper or lower half (Y axis). - Then, for the X axis, and depending on whether the score for the Y axis is positive or negative, the values will be computed as the log2 logarithm of the absolute of the difference in enrichment scores plus 1: log2(abs((x1 or y1) - (x2 or y2)) + 1). The resulting value will be positive or negative depending on whether the score for x1 or y1 is higher or lower than the score for x2 or y2.\n\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"C\",\n                                   x2 = \"B\",\n                                   y2 = \"D\")\np\n\n\n\nOutput using four lists of genes.\n\n\n\n\nIf enforce_symmetry is set to true, then the plot is completely squared.\n\np <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                   input_gene_list = gene_set,\n                                   x1 = \"A\",\n                                   y1 = \"C\",\n                                   x2 = \"B\",\n                                   y2 = \"D\",\n                                   enforce_symmetry = TRUE)\np\n\n\n\nOutput using four lists of genes and enforcing symmetry."
  },
  {
    "objectID": "20-CellularStatesPlot.html#continuous-features",
    "href": "20-CellularStatesPlot.html#continuous-features",
    "title": "\n22  Cellular State Plots\n",
    "section": "\n22.4 Continuous features",
    "text": "22.4 Continuous features\nIn addition to all the above, one can also further query the resulting plot for any other feature that would be accepted in a regular SCpubr::do_FeaturePlot(). The plots are returned alongside the original one. This behavior is achieved by using plot_features = TRUE and providing the desired features to features parameter.\n\n# Plot continuous features.\nout <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                     input_gene_list = gene_set,\n                                     x1 = \"A\",\n                                     y1 = \"C\",\n                                     x2 = \"B\",\n                                     y2 = \"D\",\n                                     plot_cell_borders = TRUE,\n                                     enforce_symmetry = TRUE,\n                                     plot_features = TRUE,\n                                     features = c(\"PC_1\", \"nFeature_RNA\"))\np <- out$main | out$PC_1 | out$nFeature_RNA\np\n\n\n\nQuery extra features as a FeaturePlot.\n\n\n\n\nFurthermore, the original list of genes queried can be also plotted as enrichment scores. This can be achieved by plot_enrichment_scores = TRUE:\n\n# Plot enrichment scores for the input gene lists.\nout <- SCpubr::do_CellularStatesPlot(sample = sample,\n                                     input_gene_list = gene_set,\n                                     x1 = \"A\",\n                                     y1 = \"C\",\n                                     x2 = \"B\",\n                                     y2 = \"D\",\n                                     plot_cell_borders = TRUE,\n                                     enforce_symmetry = TRUE,\n                                     plot_enrichment_scores = TRUE)\nlayout <- \"AABC\n           AADE\"\np <- patchwork::wrap_plots(A = out$main,\n                           B = out$A,\n                           C = out$B,\n                           D = out$C,\n                           E = out$D,\n                           design = layout)\np\n\n\n\nPlot enrichment scores for the list of genes as well."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#basic-usage",
    "href": "21-LigandReceptorPlot.html#basic-usage",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.1 Basic usage",
    "text": "23.1 Basic usage\nBy default, the user has to run liana on their own and provide the resulting output as input for the function. The following code would produces the object that SCpubr::do_LigandReceptorPlot() expects as input:\n\nliana_output <- liana::liana_wrap(sce = sample,\n                                  method = c(\"natmi\", \"connectome\", \"logfc\", \"sca\", \"cellphonedb\"),\n                                  idents_col = NULL,\n                                  verbose = FALSE,\n                                  assay = \"SCT\")\n\nIt is very important to note that liana_output has to contain the five different methods. This is a design choice. The output looks like:\n\n# Ligand Receptor analysis plot.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output)\np\n\n\n\nDefault output."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#the-basis-of-the-analysis",
    "href": "21-LigandReceptorPlot.html#the-basis-of-the-analysis",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.2 The basis of the analysis",
    "text": "23.2 The basis of the analysis\nTo give a more complete overview of how the scores retrieved from liana are treated in SCpubr::do_LigandReceptorAnalysis(), here is a short summary:\nThe output of liana::liana_wrap() is fed to liana::liana_aggregate(), that computes a metric called “aggregate_rank”, which according to the authors, is the metric that can be used for significance.\n\nFor the ranks, it’s a bit different. rank_aggregate is simply a probability distribution saying how highly-ranked a given interaction is when aggregating all score vectors - i.e. it’s only indicative of what you have it aggregate.\n\nIn the GitHub issue, liana’s developer discuss how different metrics from different tools can be used to measure the significance and magnitude of the interactions. Then, he suggests how to approach the downstream analysis of the aggregated scores:\n\nReally then the user can pick how to best approach the results. 1) You can filter by CellPhoneDB p-value or the aggregate_rank probabilities, 2) Rank interactions by specificity /w NATMI’s edge weights, 3) Use LRscores for magnitude as they are easy to intepret and comparable across datasets.\n\nFollowing this line of thought, this is what is then implemented in SCpubr::do_LigandReceptorAnalysis():\n\nOriginally, interactions were filtered out using aggregate_rank <= 0.05, but now this is not applied as we also want to display the non-significant interactions in contrast with the significant ones. If we were to filter them out, the dotplot will only containing statistically significant interactions. This will render the dotplot completely blank. In order to populate it with plot with the rest of interactions, a design choice was made to also include non-significant interactions to get a better sense of the plot by comparing them to the significant ones.\nThen, interactions are sorted out by decresing significance (natmi.edge_specificity column) and decreasing magnitude (sca.LRscore column).\nFor plotting, the top N interactions (designated by the user) with the top_interactions parameter are displayed (thus including, if top_interactions is really large, potentially non-significant interactions).\n\nThis means that, depending on the number of top interactions retrieved, we might end up with non-significant interactions across any source-target combinations. However, this will be clearly evident in contrast with the top hits. One has also to understand the meaning behind the chosen specificity and magnitude columns used to sort the interactions. For this, individual inspection of the methods used by liana is advisable.\nFinally, for the chord diagram plots, different number of interactions are used: - To represent the total number of interactions between source and target, interactions are filtered out using aggregate_rank <= 0.05. The remaining ones are considered significant and therefore included in the diagram. - To represent the total number of interactions between ligand.complex and receptor.complex, the top interactions are used instead. Since this means retreaving the interactions across all possible source/target pairs, like in the output dotplots, they include potential non-significant interactions as well."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#control-how-interactions-are-arranged",
    "href": "21-LigandReceptorPlot.html#control-how-interactions-are-arranged",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.3 Control how interactions are arranged",
    "text": "23.3 Control how interactions are arranged\n\n\n\n\n\n\nPlease note:\n\n\n\nThis feature will be available in the next CRAN release! (v1.1.0)\n\n\nThe result of liana::liana_aggregate() can be processed in multiple ways:\n\nBy default, the output matrix is already arranged by ascending aggregate_rank, which acts as a kind of p-value.\nThe interactions can be arranged by descending magnitude (how strong is the interaction) or specificity (how significant is the interaction).\nOr both.\n\nIn this context, users can decide how the results are arranged in the final plot by providing arrange_interactions_by and one of: aggregate_rank, magnitude, specificity or both.\n\n# Arrange the interactions by aggregate_rank\n# Ligand Receptor analysis plot with extra interactions.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   arrange_interactions_by = \"aggregate_rank\",\n                                   top_interactions = 10)\np\n\n\n\nArrange the interactions by aggregate_rank.\n\n\n\n\n\n# Arrange the interactions by specificity\n# Ligand Receptor analysis plot with extra interactions.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   arrange_interactions_by = \"specificity\",\n                                   top_interactions = 10)\np\n\n\n\nArrange the interactions by specificity.\n\n\n\n\n\n# Arrange the interactions by magnitude\n# Ligand Receptor analysis plot with extra interactions.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   arrange_interactions_by = \"magnitude\",\n                                   top_interactions = 10)\np\n\n\n\nArrange the interactions by magnitude.\n\n\n\n\n\n# Arrange the interactions by both magnitude and specificity.\n# Ligand Receptor analysis plot with extra interactions.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   arrange_interactions_by = \"both\",\n                                   top_interactions = 10)\np\n\n\n\nArrange the interactions by both magnitude and specificity."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#order-interacting-pairs-alphabetically",
    "href": "21-LigandReceptorPlot.html#order-interacting-pairs-alphabetically",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.4 Order interacting pairs alphabetically",
    "text": "23.4 Order interacting pairs alphabetically\n\n\n\n\n\n\nPlease note:\n\n\n\nThis feature will be available in the next CRAN release! (v1.1.0)\n\n\nBy default, the interactions are shown as they are in the original matrix. However, we can also order them alphabetically by using sort_interactions_alphabetically = TRUE:\n\n# Arrange the interactions alphabetically.\n# Ligand Receptor analysis plot with extra interactions.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   sort_interactions_alphabetically = TRUE,\n                                   top_interactions = 10)\np\n\n\n\nArrange the interactions alphabetically."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#increase-the-top-significant-interactions-plotted",
    "href": "21-LigandReceptorPlot.html#increase-the-top-significant-interactions-plotted",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.5 Increase the top significant interactions plotted",
    "text": "23.5 Increase the top significant interactions plotted\nBy default, top 25 unique, most significant interactions are retrieved and plotted. However, this can be changed by using top_interactions. Also, clusters that have no interactions, both as source and target, will be removed.:\n\n# Ligand Receptor analysis plot with extra interactions.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   top_interactions = 50)\np\n\n\n\nIncrease the number of interactions."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#add-or-remove-missing-source-target-combinations",
    "href": "21-LigandReceptorPlot.html#add-or-remove-missing-source-target-combinations",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.6 Add or remove missing source-target combinations",
    "text": "23.6 Add or remove missing source-target combinations\nDepending on the value we select for top_interactions, we might find out that there are specific source-target combinations for which we have no interactions at all. These show up in the resulting dotplot as empty columns. This is a design choice, as SCpubr brings these combinations back as NA values, thus making the different panels in the dotplot easier to read. However, with a small number of interactions, this might result in a very empty dotplot. Also, if we have many different sources, the plot can also become very long.\nIn cases like these, we might rather go for only the relevant columns. We can toggle on/off this behaviour by using add_missing_LR_combinations = TRUE/FALSE:\n\n\n# Add missing LR combinations.\np1 <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                    add_missing_LR_combinations = TRUE)\n\n# Restrict the results to only the LR combinations that have a value.\np2 <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                    add_missing_LR_combinations = FALSE)\np <- p1 /p2\np\n\n\n\nAdd or remove the missing Ligand-Receptor interactions."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#modify-the-size-of-dots",
    "href": "21-LigandReceptorPlot.html#modify-the-size-of-dots",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.7 Modify the size of dots",
    "text": "23.7 Modify the size of dots\nSize of dots can be modified with dot.size:\n\n# Ligand Receptor analysis plot with increased dot size.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   dot.size = 2)\np\n\n\n\nIncrease the dot size."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#toggle-grid-lines",
    "href": "21-LigandReceptorPlot.html#toggle-grid-lines",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.8 Toggle grid lines",
    "text": "23.8 Toggle grid lines\nOne can also draw some grid lines. This is specially useful when the plot gets too big. This can be achieved by using plot.grid = TRUE/FALSE. The grid lines can be controlled using grid.type and the color with grid.color:\n\n# Ligand Receptor analysis plot with grid.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   grid.color = \"steelblue\")\np\n\n\n\nAdd grid lines."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#invert-axis",
    "href": "21-LigandReceptorPlot.html#invert-axis",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.9 Invert axis",
    "text": "23.9 Invert axis\nFor the cases in which one want to plot a lot of interactions, the plot can be flipped with flip = TRUE. X axis labels can be rotated with rotate_x_axis_labels, providing either 0, 45 or 90 degrees and strip text can be also rotated with rotate_strip_text = TRUE.\n\n# Ligand Receptor analysis plot with inverted axes.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   flip = TRUE, \n                                   rotate_x_axis_labels = 90,\n                                   rotate_strip_text = TRUE)\np\n\n\n\nFlip the plot."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#split-the-plot-by-ligand-or-receptor-complex",
    "href": "21-LigandReceptorPlot.html#split-the-plot-by-ligand-or-receptor-complex",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.10 Split the plot by ligand or receptor complex",
    "text": "23.10 Split the plot by ligand or receptor complex\nFurthermore, the plot can be also further divided by grouping the interactions by common ligand or receptor complex. This can be achieved using split.by parameter.:\n\n# Ligand Receptor analysis plot grouped by ligand.complex.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   plot.grid = TRUE,\n                                   grid.color = \"grey90\",\n                                   grid.type = \"dotted\",\n                                   rotate_x_axis_labels = 90,\n                                   rotate_strip_text = TRUE,\n                                   split.by = \"ligand.complex\")\np\n\n\n\nSplit by ligand complex.\n\n\n\n\n\n\n# Ligand Receptor analysis plot grouped by ligand.complex.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   split.by = \"receptor.complex\")\np\n\n\n\nSplit by receptor complex."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#restrict-the-plot-to-given-source-andor-targets",
    "href": "21-LigandReceptorPlot.html#restrict-the-plot-to-given-source-andor-targets",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.11 Restrict the plot to given source and/or targets",
    "text": "23.11 Restrict the plot to given source and/or targets\nFinally, one can also restrict the output to given source and target clusters. This can be achieved by provided the desired identities to keep_source and keep_target:\n\n\n# Ligand Receptor analysis plot with inverted axes with filtered source and targets.\np <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                   flip = FALSE, \n                                   keep_source = c(\"0\", \"3\", \"9\"),\n                                   keep_target = c(\"3\", \"4\", \"9\"))\np\n\n\n\nFilter ligand and/or recpetor complex."
  },
  {
    "objectID": "21-LigandReceptorPlot.html#compute-chord-diagrams-of-the-interactions",
    "href": "21-LigandReceptorPlot.html#compute-chord-diagrams-of-the-interactions",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.12 Compute chord diagrams of the interactions",
    "text": "23.12 Compute chord diagrams of the interactions\nAnother supplementary visualizations that one can do with the results of liana is to visualize: - The total number of significant interactions between each pair of clusters. - The number of interactions between the top_interactions ligand-receptor pairs.\nThis can be achieved by providing compute_ChordDiagrams = TRUE. This will return a list with the dot plot and chord diagrams.\n\n# Chord diagram of the total significant interactions from each cluster and all the rest.\nout <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                     top_interactions = 25,\n                                     compute_ChordDiagrams = TRUE)\nout$chord_total_interactions\n\n\n\n# Chord diagram of the total ligand-receptor interactions from each cluster and all the rest.\nout$chord_ligand_receptor\n\n\nHowever, the plot can become quite messy. For this, it becomes more interesting to use in combination of keep_source or keep_target parameters:\n\n# Chord diagram of the total significant interactions from each cluster and all the rest.\nout <- SCpubr::do_LigandReceptorPlot(liana_output = liana_output,\n                                     top_interactions = 25,\n                                     keep_source = c(\"0\", \"7\"),\n                                     compute_ChordDiagrams = TRUE)\nout$chord_total_interactions\n\n\n\n# Chord diagram of the total ligand-receptor interactions from each cluster and all the rest.\nout$chord_ligand_receptor"
  },
  {
    "objectID": "21-LigandReceptorPlot.html#avoid-generating-a-omnipath-log-folder",
    "href": "21-LigandReceptorPlot.html#avoid-generating-a-omnipath-log-folder",
    "title": "\n23  Ligand-Receptor analysis\n",
    "section": "\n23.13 Avoid generating a omnipath-log folder",
    "text": "23.13 Avoid generating a omnipath-log folder\nIf this folder appears in your tree structure, consider applying the hotfix stated here."
  },
  {
    "objectID": "22-CopyNumberVariantPlots.html#transferring-the-scores-to-a-featureplot",
    "href": "22-CopyNumberVariantPlots.html#transferring-the-scores-to-a-featureplot",
    "title": "\n24  Copy Number Variant analysis plots\n",
    "section": "\n24.1 Transferring the scores to a FeaturePlot",
    "text": "24.1 Transferring the scores to a FeaturePlot\nOne of the cool things we can do with this object, is to transfer the inferCNV scores back to our Seurat object and then plot them as a FeaturePlot. This can be achieved with the function SCpubr::do_CopyNumberVariantPlot(). For this function, one needs to provide the Seurat object and the final inferCNV object, together with the chromosome locations. If metacells were computed (not necessary, but used in this example), the mapping of cell-metacell has to be provided as well. Normally, you want to run it with chromosome_focus set to a given chromosome. If not, it computes the results in a chromosome-wise manner:\n\n# This loads \"human_chr_locations\" into the environment.\nutils::data(\"human_chr_locations\", package = \"SCpubr\")\n\nout <- SCpubr::do_CopyNumberVariantPlot(sample = sample,\n                                        infercnv_object = infercnv_object,\n                                        using_metacells = TRUE,\n                                        metacell_mapping = sample$metacell_mapping,\n                                        chromosome_locations = human_chr_locations,\n                                        chromosome_focus = \"11\")\np <- out$`11_umap` |out$`11p_umap` | out$`11q_umap`\np\n\n\n\nRetrieve a UMAP of the desired scores.\n\n\n\n\nScores close to 1 mean no chromosome gain or loss. Higher than one mean gain and lower mean loss. The function automatically computes the plots for all chromosome regions. If we want to restrict the output to a single chromosome, we can do so by stating it in chromosome_focus parameter.\n\nout <- SCpubr::do_CopyNumberVariantPlot(sample = sample,\n                                        infercnv_object = infercnv_object,\n                                        using_metacells = TRUE,\n                                        metacell_mapping = sample$metacell_mapping,\n                                        chromosome_locations = human_chr_locations,\n                                        chromosome_focus = \"11\")"
  },
  {
    "objectID": "22-CopyNumberVariantPlots.html#plotting-the-scores-grouped-by-a-group-of-interest",
    "href": "22-CopyNumberVariantPlots.html#plotting-the-scores-grouped-by-a-group-of-interest",
    "title": "\n24  Copy Number Variant analysis plots\n",
    "section": "\n24.2 Plotting the scores grouped by a group of interest",
    "text": "24.2 Plotting the scores grouped by a group of interest\nSometimes, however, the FeaturePlot is not sufficient to get the insights we want from these scores. For this, the output of SCpubr::do_CopyNumberVariantPlot() also contains another set of Geyser plots, that showcase the distribution of scores per cells, grouped by a variable of interest.\n\nout <- SCpubr::do_CopyNumberVariantPlot(sample = sample,\n                                        infercnv_object = infercnv_object,\n                                        using_metacells = TRUE,\n                                        metacell_mapping = sample$metacell_mapping,\n                                        chromosome_locations = human_chr_locations,\n                                        chromosome_focus = \"11\",\n                                        rotate_x_axis_labels = 45)\np <- out$`11p_geyser`\np\n\n\n\nRetrieve the geyser plot of the scores.\n\n\n\n\nHere, we can observe the scores for the different groups, being each dot a cells. Due to the overplotting, we also report the distribution of the data for each group in the center, being the dot the median of the distribution, the thicker lines representing the 66% of the data and the thinner lines the 95%. This way, one can also see where the majority of the cells reside in each group. We can also select other variables to group by.\n\n\n\n\n\n\nTip!\n\n\n\nWhen using enforce_symmetry = TRUE, it can be the case that, for a given chromosome, the Y axis scale is completely driven by a single outlier. This can be fixed by adding your own set of limits using p + ggplot2::ylim(c(y_min, y_max)) and providing the values you want to set the Y axis to.\n\n\n\nsample$modified_orig.ident <- sample(x = c(\"Sample_A\", \"Sample_B\", \"Sample_C\"), \n                                     size = ncol(sample), \n                                     replace = TRUE, \n                                     prob = c(0.2, 0.7, 0.1))\n\nout <- SCpubr::do_CopyNumberVariantPlot(sample = sample,\n                                        infercnv_object = infercnv_object,\n                                        using_metacells = TRUE,\n                                        group.by = \"modified_orig.ident\",\n                                        metacell_mapping = sample$metacell_mapping,\n                                        chromosome_locations = human_chr_locations,\n                                        chromosome_focus = \"11\",\n                                        rotate_x_axis_labels = 45)\np <- out$`11p_geyser`\np\n\n\n\nUse custom grouping."
  },
  {
    "objectID": "22-CopyNumberVariantPlots.html#joint-analysis",
    "href": "22-CopyNumberVariantPlots.html#joint-analysis",
    "title": "\n24  Copy Number Variant analysis plots\n",
    "section": "\n24.3 Joint analysis",
    "text": "24.3 Joint analysis\nThe ideal use case for such functions is to plot them side by side with a regular UMAP as well:\n\np1 <- SCpubr::do_DimPlot(sample = sample,\n                         plot_cell_borders = TRUE,\n                         border.size = 1.5,\n                         pt.size = 1)\nout <- SCpubr::do_CopyNumberVariantPlot(sample = sample,\n                                        infercnv_object = infercnv_object,\n                                        using_metacells = TRUE,\n                                        metacell_mapping = sample$metacell_mapping,\n                                        chromosome_locations = human_chr_locations,\n                                        chromosome_focus = \"11\",\n                                        rotate_x_axis_labels = 45)\np2 <- out$`11p_umap`\np3 <- out$`11p_geyser`\n\np <- (p1 | p2) / p3\np\n\n\n\nRetrieve all the plots.\n\n\n\n\nThis way, we can see which clusters are in the UMAP, see their scores and also visualize the distributions!"
  },
  {
    "objectID": "23-PathwayActivityPlots.html#heatmap-of-averaged-scores",
    "href": "23-PathwayActivityPlots.html#heatmap-of-averaged-scores",
    "title": "\n25  Pathway Activity inference analysis\n",
    "section": "\n25.1 Heatmap of averaged scores",
    "text": "25.1 Heatmap of averaged scores\nThe most informative and, perhaps, straightforward approach is to visualize the resulting scores averaged by the groups we have defined, as a heatmap. This is the default output of SCpubr::do_PathwayActivityPlot().\n\n# General heatmap.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities)\np <- out$heatmaps$average_scores\np\n\n\n\nRetrieve the heatmap output."
  },
  {
    "objectID": "23-PathwayActivityPlots.html#set-the-scale-limits.",
    "href": "23-PathwayActivityPlots.html#set-the-scale-limits.",
    "title": "\n25  Pathway Activity inference analysis\n",
    "section": "\n25.2 Set the scale limits.",
    "text": "25.2 Set the scale limits.\nWe can set the limits of the color scale by using min.cutoff and/or max.cutoff:\n\n# General heatmap.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      min.cutoff = -1,\n                                      max.cutoff = 1)\np <- out$heatmaps$average_scores\np\n\n\n\nSet scale limits\n\n\n\n\nHowever, be mindful that if enforce_symmetry = TRUE, this will override these settings, to achieve a symmetrical color scale:\n\n# Effect of enforce symmetry on the scale limits.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      min.cutoff = -1.25,\n                                      max.cutoff = 1,\n                                      enforce_symmetry = TRUE)\np <- out$heatmaps$average_scores\np\n\n\n\nEffect of enforce_symmetry in min.cutoff and max.cutoff\n\n\n\n\n\n\n\n\n\n\nTake-home message\n\n\n\nBe mindful when using min.cutoff and max.cutoff, as this behavior might be overriden by enforce_symmetry = TRUE. Consider setting it to FALSE."
  },
  {
    "objectID": "23-PathwayActivityPlots.html#feature-plots-of-the-scores",
    "href": "23-PathwayActivityPlots.html#feature-plots-of-the-scores",
    "title": "\n25  Pathway Activity inference analysis\n",
    "section": "\n25.3 Feature plots of the scores",
    "text": "25.3 Feature plots of the scores\nPerhaps we are interested into visualizing the scores as a Feature plot. This way we can observe trends of enrichment in the activities. This can be achieved by providing plot_FeaturePlots = TRUE.\n\n# Retrieve feature plots.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_FeaturePlots = TRUE)\np1 <- SCpubr::do_DimPlot(sample)\np2 <- out$feature_plots$EGFR\np <- p1 | p2\np\n\n\n\nRetrieve the FeaturePlot output.\n\n\n\n\nThis effect will also be seen if only min.cutoff or max.cutoff is set and the other end of the color scale has a higher absolute value."
  },
  {
    "objectID": "23-PathwayActivityPlots.html#geyser-plots-of-the-scores",
    "href": "23-PathwayActivityPlots.html#geyser-plots-of-the-scores",
    "title": "\n25  Pathway Activity inference analysis\n",
    "section": "\n25.4 Geyser plots of the scores",
    "text": "25.4 Geyser plots of the scores\nIn the same fashion as with the feature plots, we can also visualize the scores as Geyser plots, to get a sense of the distribution of the scores alongside the groups. This can be achieved by providing plot_GeyserPlots = TRUE.\n\n# Retrieve Geyser plots.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE)\np1 <- SCpubr::do_DimPlot(sample)\np2 <- out$geyser_plots$EGFR\np <- p1 | p2\np\n\n\n\nRetrieve the Geyser plot output."
  },
  {
    "objectID": "23-PathwayActivityPlots.html#use-non-symmetrical-color-scales",
    "href": "23-PathwayActivityPlots.html#use-non-symmetrical-color-scales",
    "title": "\n25  Pathway Activity inference analysis\n",
    "section": "\n25.5 Use non-symmetrical color scales",
    "text": "25.5 Use non-symmetrical color scales\nIf one wants to just plot a continuous color scale for the Feature plots and the Geyser plots, this can be achieved by using enforce_symmetry = FALSE.\n\n# Use non-symmetrical color scale.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE,\n                                      plot_FeaturePlots = TRUE,\n                                      enforce_symmetry = FALSE)\np1 <- out$feature_plots$EGFR\np2 <- out$geyser_plots$EGFR\n\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE,\n                                      plot_FeaturePlots = TRUE,\n                                      enforce_symmetry = TRUE)\np3 <- out$feature_plots$EGFR\np4 <- out$geyser_plots$EGFR\n\np <- (p1 | p2) / (p3 | p4)\np\n\n\n\nApply a non-symmetrical color scale."
  },
  {
    "objectID": "23-PathwayActivityPlots.html#order-geysers-by-the-mean",
    "href": "23-PathwayActivityPlots.html#order-geysers-by-the-mean",
    "title": "\n25  Pathway Activity inference analysis\n",
    "section": "\n25.6 Order geysers by the mean",
    "text": "25.6 Order geysers by the mean\nWe can also decide not to order the Geyser plots by the mean of the values. We can do that by providing geyser_order_by_mean = FALSE.\n\n# Not order Geyser plot by mean values.\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE,\n                                      enforce_symmetry = TRUE,\n                                      geyser_order_by_mean = FALSE)\np1 <- out$geyser_plots$EGFR\n\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      plot_GeyserPlots = TRUE,\n                                      enforce_symmetry = TRUE,\n                                      geyser_order_by_mean = TRUE)\np2 <- out$geyser_plots$EGFR\n\np <- p1 | p2\np\n\n\n\nOrder by mean values."
  },
  {
    "objectID": "23-PathwayActivityPlots.html#split-the-heatmap-into-different-groups",
    "href": "23-PathwayActivityPlots.html#split-the-heatmap-into-different-groups",
    "title": "\n25  Pathway Activity inference analysis\n",
    "section": "\n25.7 Split the heatmap into different groups",
    "text": "25.7 Split the heatmap into different groups\nWe can also further divide the heatmap into groups. This can be achieved using split.by parameter.\n\n# Split the heatmap by another variable.\nsample$split.me <- ifelse(sample$seurat_clusters %in% c(\"0\", \"3\", \"7\"), \"Group A\",\"Group B\")\n\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      split.by = \"split.me\")\np <- out$heatmaps$average_scores\np\n\n\n\nSplit the heatmap."
  },
  {
    "objectID": "23-PathwayActivityPlots.html#control-the-color-scale",
    "href": "23-PathwayActivityPlots.html#control-the-color-scale",
    "title": "\n25  Pathway Activity inference analysis\n",
    "section": "\n25.8 Control the color scale",
    "text": "25.8 Control the color scale\nAgain, we can control the color scale using min.cutoff and max.cutoff. This will apply to all plot types:\n\n# Control the color scale\nout <- SCpubr::do_PathwayActivityPlot(sample = sample,\n                                      activities = activities,\n                                      split.by = \"split.me\",\n                                      min.cutoff = 0.1,\n                                      max.cutoff = 0.7,\n                                      plot_FeaturePlots = TRUE,\n                                      plot_GeyserPlots = TRUE)\np <- out$heatmaps$average_scores\np\n\n\n\nControl the color scale - heatmap.\n\n\n\n\n\np1 <- out$feature_plots$PI3K\np2 <- out$geyser_plots$PI3K\np <- p1 | p2\np\n\n\n\nControl the color scale - FeaturePlot and GeyserPlot"
  },
  {
    "objectID": "24-TFActivityPlots.html#heatmap-of-averaged-scores",
    "href": "24-TFActivityPlots.html#heatmap-of-averaged-scores",
    "title": "\n26  TF Activity inference analysis\n",
    "section": "\n26.1 Heatmap of averaged scores",
    "text": "26.1 Heatmap of averaged scores\nThe most informative and, perhaps, straightforward approach is to visualize the resulting scores averaged by the groups we have defined, as a heatmap. This is the default output of SCpubr::do_TFActivityPlot().\n\n# General heatmap.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities)\np <- out$heatmaps$average_scores\np\n\n\n\nRetrieve the heatmap output."
  },
  {
    "objectID": "24-TFActivityPlots.html#set-the-scale-limits.",
    "href": "24-TFActivityPlots.html#set-the-scale-limits.",
    "title": "\n26  TF Activity inference analysis\n",
    "section": "\n26.2 Set the scale limits.",
    "text": "26.2 Set the scale limits.\nWe can set the limits of the color scale by using min.cutoff and/or max.cutoff:\n\n# Set the scale limits.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 min.cutoff = -2,\n                                 max.cutoff = 2)\np <- out$heatmaps$average_scores\np\n\n\n\nSet scale limits\n\n\n\n\nHowever, be mindful that if enforce_symmetry = TRUE, this will override these settings, to achieve a symmetrical color scale:\n\n# Effect of enforce symmetry on the scale limits.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 min.cutoff = -2,\n                                 max.cutoff = 1,\n                                 enforce_symmetry = TRUE)\np <- out$heatmaps$average_scores\np\n\n\n\nEffect of enforce_symmetry in min.cutoff and max.cutoff\n\n\n\n\nThis effect will also be seen if only min.cutoff or max.cutoff is set and the other end of the color scale has a higher absolute value.\n\n\n\n\n\n\nTake-home message\n\n\n\nBe mindful when using min.cutoff and max.cutoff, as this behavior might be overriden by enforce_symmetry = TRUE. Consider setting it to FALSE."
  },
  {
    "objectID": "24-TFActivityPlots.html#select-the-number-of-top-tfs-to-plot",
    "href": "24-TFActivityPlots.html#select-the-number-of-top-tfs-to-plot",
    "title": "\n26  TF Activity inference analysis\n",
    "section": "\n26.3 Select the number of top TFs to plot",
    "text": "26.3 Select the number of top TFs to plot\nWe can select the number of TFs to include in the analysis by using n_tfs variable.\n\n# Increase number of TFs included in the analysis.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 n_tfs = 40)\np <- out$heatmaps$average_scores\np\n\n\n\nIncrease the number of reported TFs."
  },
  {
    "objectID": "24-TFActivityPlots.html#feature-plots-of-the-scores",
    "href": "24-TFActivityPlots.html#feature-plots-of-the-scores",
    "title": "\n26  TF Activity inference analysis\n",
    "section": "\n26.4 Feature plots of the scores",
    "text": "26.4 Feature plots of the scores\nPerhaps we are interested into visualizing the scores as a Feature plot. This way we can observe trends of enrichment in the activities. This can be achieved by providing plot_FeaturePlots = TRUE.\n\n# Retrieve feature plots.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_FeaturePlots = TRUE)\np1 <- SCpubr::do_DimPlot(sample)\np2 <- out$feature_plots$GLI2\np <- p1 | p2\np\n\n\n\nRetrieve the feature plot output."
  },
  {
    "objectID": "24-TFActivityPlots.html#geyser-plots-of-the-scores",
    "href": "24-TFActivityPlots.html#geyser-plots-of-the-scores",
    "title": "\n26  TF Activity inference analysis\n",
    "section": "\n26.5 Geyser plots of the scores",
    "text": "26.5 Geyser plots of the scores\nIn the same fashion as with the feature plots, we can also visualize the scores as Geyser plots, to get a sense of the distribution of the scores alongside the groups. This can be achieved by providing plot_GeyserPlots = TRUE.\n\n# Retrieve Geyser plots.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE)\np1 <- SCpubr::do_DimPlot(sample)\np2 <- out$geyser_plots$GLI2\np <- p1 | p2\np\n\n\n\nRetrieve the geyser plot output."
  },
  {
    "objectID": "24-TFActivityPlots.html#use-non-symmetrical-color-scales",
    "href": "24-TFActivityPlots.html#use-non-symmetrical-color-scales",
    "title": "\n26  TF Activity inference analysis\n",
    "section": "\n26.6 Use non-symmetrical color scales",
    "text": "26.6 Use non-symmetrical color scales\nIf one wants to just plot a continuous color scale for the Feature plots and the Geyser plots, this can be achieved by using enforce_symmetry = FALSE.\n\n# Use non-symmetrical color scale.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE,\n                                 plot_FeaturePlots = TRUE,\n                                 enforce_symmetry = FALSE)\np1 <- out$feature_plots$GLI2\np2 <- out$geyser_plots$GLI2\n\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE,\n                                 plot_FeaturePlots = TRUE,\n                                 enforce_symmetry = TRUE)\np3 <- out$feature_plots$GLI2\np4 <- out$geyser_plots$GLI2\n\np <- (p1 | p2) / (p3 | p4)\np\n\n\n\nApply a non-symmetrical color scale."
  },
  {
    "objectID": "24-TFActivityPlots.html#order-geysers-by-the-mean",
    "href": "24-TFActivityPlots.html#order-geysers-by-the-mean",
    "title": "\n26  TF Activity inference analysis\n",
    "section": "\n26.7 Order geysers by the mean",
    "text": "26.7 Order geysers by the mean\nWe can also decide not to order the Geyser plots by the mean of the values. We can do that by providing geyser_order_by_mean = FALSE.\n\n# Not order Geyser plot by mean values.\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE,\n                                 enforce_symmetry = TRUE,\n                                 geyser_order_by_mean = FALSE)\np1 <- out$geyser_plots$GLI2\n\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 plot_GeyserPlots = TRUE,\n                                 enforce_symmetry = TRUE,\n                                 geyser_order_by_mean = TRUE)\np2 <- out$geyser_plots$GLI2\n\np <- p1 | p2\np\n\n\n\nOrder by mean values."
  },
  {
    "objectID": "24-TFActivityPlots.html#split-the-heatmap-into-different-groups",
    "href": "24-TFActivityPlots.html#split-the-heatmap-into-different-groups",
    "title": "\n26  TF Activity inference analysis\n",
    "section": "\n26.8 Split the heatmap into different groups",
    "text": "26.8 Split the heatmap into different groups\nWe can also further divide the heatmap into groups. This can be achieved using split.by parameter.\n\n# Split the heatmap by another variable.\nsample$split.me <- ifelse(sample$seurat_clusters %in% c(\"0\", \"3\", \"7\"), \"Group A\",\"Group B\")\n\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                 activities = activities,\n                                 split.by = \"split.me\")\np <- out$heatmaps$average_scores\np\n\n\n\nSplit the heatmap by another variable."
  },
  {
    "objectID": "24-TFActivityPlots.html#control-the-color-scale",
    "href": "24-TFActivityPlots.html#control-the-color-scale",
    "title": "\n26  TF Activity inference analysis\n",
    "section": "\n26.9 Control the color scale",
    "text": "26.9 Control the color scale\nAgain, we can control the color scale using min.cutoff and max.cutoff. This will apply to all plot types:\n\n# Control the color scale\nout <- SCpubr::do_TFActivityPlot(sample = sample,\n                                      activities = activities,\n                                      split.by = \"split.me\",\n                                      min.cutoff = 0.1,\n                                      max.cutoff = 0.7,\n                                      plot_FeaturePlots = TRUE,\n                                      plot_GeyserPlots = TRUE)\np <- out$heatmaps$average_scores\np\n\n\n\nControl the color scale - heatmap.\n\n\n\n\n```{r} #| fig-width: 14 #| fig-height: 8 #| fig-cap: “Control the color scale - FeaturePlot and GeyserPlot”\np1 <- out\\(feature_plots\\)PI3K p2 <- out\\(geyser_plots\\)PI3K p <- p1 | p2 p"
  },
  {
    "objectID": "25-AzimuthAnalysisPlots.html#basic-analysis",
    "href": "25-AzimuthAnalysisPlots.html#basic-analysis",
    "title": "\n27  Azimuth reference mapping reports\n",
    "section": "\n27.1 Basic analysis",
    "text": "27.1 Basic analysis\nThe basic analysis that can be carried out from Azimuth’s output goes as follows:\nAzimuth provides an annotation score as well as a mapping score. Both have a meaning and are perfectly explained in their website. From there:\n\nPrediction scores: Cell prediction scores range from 0 to 1 and reflect the confidence associated with each annotation. Cells with high-confidence annotations (for example, prediction scores > 0.75) reflect predictions that are supported by mulitple consistent anchors. Prediction scores can be visualized on the Feature Plots tab, or downloaded on the Download Results tab. The prediction depends on the specific annotation for each cell. Therefore, if you are mapping cells at multiple levels of resolution (for example level 1/2/3 annotations in the Human PBMC reference), each level will be associated with a different prediction score.\n\n\nMapping scores: This value from 0 to 1 reflects confidence that this cell is well represented by the reference. The “mapping.score” column is available to plot in the Feature Plots tab, and is provided in the download TSV file. The mapping score is independent of a specific annotation, is calculated using the MappingScore function in Seurat, and reflects how well the unique structure of a cell’s local neighborhood is preserved during reference mapping.\n\nThis means, that depending on how strict we want to be in our analyses, we can set a cutoff for either of the scores (or both). This is defined in SCpubr::do_AzimuthAnalysisPlot() by the parameters mapping.cutoff (for the mapping scores) and annotation.cutoff (for the annotation scores). The cells that do not surpass the cutoffs will turn into NA for the plotting, as Azimuth will always give a labelling to each of the cells regardless of the mapping and annotation scores.\nThen, in order to run SCpubr::do_AzimuthAnalysisPlot() one needs to provide:\n\nThe Seurat object that has undergone Azimuth::RunAzimuth().\nThe name of the metadata column that stores the annotation (to annotation.labels).\nThe name of the metadata column that stores the annotation scores (to annotation.scoring).\nThe name of the metadata column that stores the mapping scores (to mapping.scoring).\nThe cutoff for the annotation scores (0.75 by default).\nThe cutoff for the mapping scores (0 by default).\n\nAs follows:\n\n# Generate an Azimuth report.\nout <- SCpubr::do_AzimuthAnalysisPlot(sample = sample,\n                                      annotation.labels = \"predicted.celltype.l1\",\n                                      annotation.scoring = \"predicted.celltype.l1.score\",\n                                      font.size = 18)\n\nBy default, it will generate a list of objects, that contain:\n\nA vector of the resulting annotation (to use or store).\nA FeaturePlot of the mapping scores.\nA FeaturePlot of the annotation scores.\nA DimPlot of the current annotation (or whatever metadata annotaiton provided to group.by).\nA DimPlot of the inferred annotation.\nA DimPlot of our queried cells in the reference UMAP.\nA stacked BarPlot showing the proportion of the different datasets of origin (stored in orig.ident) across the current annotation. This is specially useful in merged tumor datasets in which the tumor microenvironment clustes will merge together in single clusters while the tumor cells from each individual datasets will form single clusters. Otherwise, this plot will be very little informative.\nA stacked BarPlot showing the proportion of the inferred annotation in each of our original clusters.\nA report containing all of the above plots in landscape and portrait formats.\n\nLet’s have a look at the report:\n\n# Azimuth report - portrait.\nout$report_portrait\n\n\n\nBasic Azimuth report - portrait\n\n\n\n\n\n# Azimuth report - landscape.\nout$report_landscape\n\n\n\nBasic Azimuth report - landscape"
  },
  {
    "objectID": "25-AzimuthAnalysisPlots.html#add-the-reference-dataset-to-the-report",
    "href": "25-AzimuthAnalysisPlots.html#add-the-reference-dataset-to-the-report",
    "title": "\n27  Azimuth reference mapping reports\n",
    "section": "\n27.2 Add the reference dataset to the report",
    "text": "27.2 Add the reference dataset to the report\nAs can be observed, there is an empty space in the report. This is meant to be filled by a UMAP of the original reference, if we happen to have the original object at hand. In the cases of the datasets installed using SeuratData, one can retrieve them as:\n\n# Retrieve reference.\nreference <- readRDS(system.file(\"azimuth/ref.Rds\", package = \"pbmcref.SeuratData\"))\n\n# Set the identities of the object to match our inferred identities.\nSeurat::Idents(reference) <- reference$celltype.l1 \n\n\n\n\n\n\n\nPlease note:\n\n\n\nThe path to this object varies from package to package and also depends on the user’s installation. It is highly recommendable to navigate through your installation folder where all R packages are installed and search for the object manually.\n\n\nThen, we can provide the reference object using ref.obj parameter and it is also highly recommended to provided the UMAP dimensional reduction name, which in this case is refUMAP, but also can vary from dataset to dataset. The names can be checked using Seurat::Reductions(sample) and the name has to be fed to ref.reduction parameter, as such:\n\n# Generate an Azimuth report with the reference object.\nout <- SCpubr::do_AzimuthAnalysisPlot(sample = sample,\n                                      annotation.labels = \"predicted.celltype.l1\",\n                                      annotation.scoring = \"predicted.celltype.l1.score\",\n                                      ref.obj = reference,\n                                      ref.reduction = \"refUMAP\",\n                                      font.size = 18)\n\n\n# Azimuth report - portrait with reference.\nout$report_portrait\n\n\n\nBasic Azimuth report - portrait with reference\n\n\n\n\n\n# Azimuth report - landscape with reference.\nout$report_landscape\n\n\n\nBasic Azimuth report - landscape with reference\n\n\n\n\nAs can be observed, a new DimPlot with the original UMAP is now displayed at the top left of the report. What is more interesting, since now we have the original UMAP coordinates, we can also project the UMAP silhouette onto the UMAP where our cells in the reference UMAP were shown, so we have a better understanding of where exactly in the UMAP they are actually located."
  },
  {
    "objectID": "25-AzimuthAnalysisPlots.html#use-custom-grouping",
    "href": "25-AzimuthAnalysisPlots.html#use-custom-grouping",
    "title": "\n27  Azimuth reference mapping reports\n",
    "section": "\n27.3 Use custom grouping",
    "text": "27.3 Use custom grouping\nAs usual, we can make use of group.by parameter to dictate which identities are being used for plotting:\n\n# Generate an Azimuth report with a custom grouping.\nsample$annotation <- ifelse(sample$seurat_clusters %in% c(\"0\", \"2\", \"7\"), \"A\", \"B\")\n\nout <- SCpubr::do_AzimuthAnalysisPlot(sample = sample,\n                                      group.by = \"annotation\",\n                                      annotation.labels = \"predicted.celltype.l1\",\n                                      annotation.scoring = \"predicted.celltype.l1.score\",\n                                      ref.obj = reference,\n                                      ref.reduction = \"refUMAP\",\n                                      font.size = 18)\n\n\n# Azimuth report - portrait with reference and custom grouping.\nout$report_portrait\n\n\n\nBasic Azimuth report - portrait with reference and custom grouping\n\n\n\n\n\n# Azimuth report - landscape with reference and custom grouping.\nout$report_landscape\n\n\n\nBasic Azimuth report - landscape with reference and custom grouping"
  },
  {
    "objectID": "25-AzimuthAnalysisPlots.html#use-custom-colors",
    "href": "25-AzimuthAnalysisPlots.html#use-custom-colors",
    "title": "\n27  Azimuth reference mapping reports\n",
    "section": "\n27.4 Use custom colors",
    "text": "27.4 Use custom colors\nFinally, as usual, we can provide our custom color scheme to the DimPlots using colors.use and to the FeaturePlots using viridis_color_map and viridis_direction:\n\n# Generate an Azimuth report with a custom grouping.\ncolors.use <- SCpubr::do_ColorPalette(\"steelblue\", opposite = TRUE)\nnames(colors.use) = c(\"A\", \"B\")\n\nout <- SCpubr::do_AzimuthAnalysisPlot(sample = sample,\n                                      group.by = \"annotation\",\n                                      annotation.labels = \"predicted.celltype.l1\",\n                                      annotation.scoring = \"predicted.celltype.l1.score\",\n                                      ref.obj = reference,\n                                      ref.reduction = \"refUMAP\",\n                                      colors.use = colors.use,\n                                      viridis_color_map = \"C\",\n                                      viridis_direction = 1,\n                                      font.size = 18)\n\n\n# Azimuth report - portrait with reference and custom colors.\nout$report_portrait\n\n\n\nBasic Azimuth report - portrait with reference and custom colors\n\n\n\n\n\n# Azimuth report - landscape with reference and custom colors.\nout$report_landscape\n\n\n\nBasic Azimuth report - landscape with reference and custom colors"
  },
  {
    "objectID": "25-PseudotimeAnalysisPlots.html#setting-up-partitions-and-clusters",
    "href": "25-PseudotimeAnalysisPlots.html#setting-up-partitions-and-clusters",
    "title": "\n28  Pseudotime analysis\n",
    "section": "\n28.1 Setting up partitions and clusters",
    "text": "28.1 Setting up partitions and clusters\nFor this function to work, we need a Seurat object together with a Cell Data Set (CDS) object, that needs to be generated by SeuratWrappers::as.cell_data_set().\nFirst thing to take into account is that monocle3 computes partitions and clusters. This is, when cells are too far away, the trajectory is disconnected, generating partitions with different start and end trajectories. We can tweak this process by forcing all of our data to be in a single partition or to keep as identities the group that we desire. This can be done by using compute_monocle_partitions and compute_monocle_clusters parameters.\n\n\n\nWe will use the following genes as a example, that depict CD14+ mono cells.\n\n# Genes to use.\npseudotime_genes <- c(\"CD14\", \"LYN\")\n\n\n# Define your sample.\nsample <- your_seurat_object\n# Transform into CDS.\ncds <- SeuratWrappers::as.cell_data_set(sample)\n\n# Compute monocle clusters and partitions.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = TRUE,\n                                 pseudotime_genes = pseudotime_genes)\n\n# Compute monocle clusters and keep a single partition.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = FALSE,\n                                 compute_monocle_clusters = TRUE,\n                                 pseudotime_genes = pseudotime_genes)\n\n# Compute monocle partitions but keep original identities as clusters.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes)\n\n# Keep original identities as clusters and a single partition.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = FALSE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes)\n\n# Set a metadata varible as clusters and a single partition.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = FALSE,\n                                 compute_monocle_clusters = FALSE,\n                                 group.by = \"orig.ident\")"
  },
  {
    "objectID": "25-PseudotimeAnalysisPlots.html#visualizing-the-trajectory-graph",
    "href": "25-PseudotimeAnalysisPlots.html#visualizing-the-trajectory-graph",
    "title": "\n28  Pseudotime analysis\n",
    "section": "\n28.2 Visualizing the trajectory graph",
    "text": "28.2 Visualizing the trajectory graph\n\n# Compute trajectory graph.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes)\n# Retrieve trajectory groups.\np1 <- out$trajectory_groups\n# Retrieve trajectory partitions.\np2 <- out$trajectory_partitions\n\np <- p1 | p2\np\n\n\n\n\nSCpubr do_PseudotimePlot trajectory graph output.\n\n\nWe can increase the trajectory graph width by using trajectory_graph_segment_size and the color with trajectory_graph_color parameters.\n\n# Change trajectory graph width.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 1)\np1 <- out$trajectory_partitions\n\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 2)\np2 <- out$trajectory_partitions\n\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 3)\np3 <- out$trajectory_partitions\n\n\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 3,\n                                 trajectory_graph_color = \"white\")\np4 <- out$trajectory_partitions\n\np <- (p1 | p2) / (p3 | p4)\np\n\n\n\n\nSCpubr do_PseudotimePlot trajectory graph with different widths and color.\n\n We can also add different elements to the graph, such as the roots, branches and leaves with\n\n# Add nodes, branches and leaves to the trajectory graph.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 2,\n                                 label_roots = TRUE)\np1 <- out$trajectory_partitions\n\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 2,\n                                 label_roots = TRUE,\n                                 label_branches = TRUE)\np2 <- out$trajectory_partitions\n\n\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 trajectory_graph_segment_size = 2,\n                                 label_roots = TRUE,\n                                 label_branches = TRUE,\n                                 label_leaves = TRUE)\np3 <- out$trajectory_partitions\n\np <- p1 / p2 / p3\np\n\n\n\n\nSCpubr do_PseudotimePlot trajectory graph with roots, branches and leaves.\n\n ## Visualizing the pseudotime\nWe can inspect the pseudotime by providing whether the root of the trajectory is the highest or lowest enrichment score, with is_max_score_the_start parameter.\n\n# Plot pseudotime with monocle partitions using highest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 is_max_score_the_start = TRUE)\np1 <- out$pseudotime\n\n# Plot pseudotime with monocle partitions using lowest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 is_max_score_the_start = FALSE)\np2 <- out$pseudotime\n\n\n# Plot pseudotime with monocle partitions using highest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = FALSE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 is_max_score_the_start = TRUE)\np3 <- out$pseudotime\n\n# Plot pseudotime with monocle partitions using lowest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = FALSE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 is_max_score_the_start = FALSE)\np4 <- out$pseudotime\n\np <- (p1 | p2) / (p3 | p4)\np\n\n\n\n\nSCpubr do_PseudotimePlot pseudotime output with different ordering.\n\n As can be observed, if we compute different partitions, the one used will be the one that contains the highest or lowest enrichment score, up to our choice. If not, the whole trajectory for the whole UMAP will be used, providing very different results. The key to this is the kind of sample/cds we provide as input (i.e, if we have a tumor bulk that we want to keep as a single partition or not or similar).\nWe can also visualize the enrichment scores as a feature plot alongside the pseudotime, either in a symmetrical scale or not with enforce_symmetry.\n\n# Plot pseudotime with monocle partitions using highest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 enforce_symmetry = FALSE,\n                                 is_max_score_the_start = TRUE)\np1 <- out$pseudotime\np3 <- out$enrichment\n# Plot pseudotime with monocle partitions using lowest score as root.\nout <- SCpubr::do_PseudotimePlot(sample = sample,\n                                 cds = cds,\n                                 compute_monocle_partitions = TRUE,\n                                 compute_monocle_clusters = FALSE,\n                                 pseudotime_genes = pseudotime_genes,\n                                 enforce_symmetry = TRUE,\n                                 is_max_score_the_start = FALSE)\np2 <- out$pseudotime\np4 <- out$enrichment\n\np <- (p1 | p2) / (p3 | p4)\np\n\n\n\n\nSCpubr do_PseudotimePlot pseudotime output with enrichment scores."
  },
  {
    "objectID": "93-ColorPalettes.html#generate-color-palettes",
    "href": "93-ColorPalettes.html#generate-color-palettes",
    "title": "Color palettes",
    "section": "Generate color palettes",
    "text": "Generate color palettes\nThe simplest way to generate a color palette with SCpubr::do_ColorPalette() is to provide a single color to colors.use parameter. It is important to remark that only one color has to be provided. The function iterates over the whole range of HUE values and generate equally spaced colors.\n\n# Generate a color palette.\nSCpubr::do_ColorPalette(colors.use = \"steelblue\")\n#>  [1] \"#4682B4\" \"#464BB4\" \"#7846B4\" \"#AF46B4\" \"#B44682\"\n#>  [6] \"#B4464B\" \"#B47846\" \"#B4AF46\" \"#82B446\" \"#4BB446\"\n#> [11] \"#46B478\" \"#46B4AF\"\n\nBy default, it returns 12 colors, but this can be changed by using n parameter.\n\n# Generate a color palette with a given number of colors.\nSCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                        n = 7)\n#> [1] \"#4682B4\" \"#6846B4\" \"#B446A1\" \"#B44946\" \"#B4A746\"\n#> [6] \"#63B446\" \"#46B488\"\n\nJust having the colors as a vector is great to use them right away in other plotting functions. However, one can visualize how the colors look like by using plot = TRUE.\n\n# Generate a color palette and plot it.\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             plot = TRUE)\n\np\n\n\n\nWheel colors"
  },
  {
    "objectID": "93-ColorPalettes.html#generate-combination-of-colors",
    "href": "93-ColorPalettes.html#generate-combination-of-colors",
    "title": "Color palettes",
    "section": "Generate combination of colors",
    "text": "Generate combination of colors\nOther times, one might just want a given combination of colors, following the color theory. For this different parameters can be used. Using them will force n to be 12, so do not use n parameter alongside them, as it will have no effect.\nOpposite colors\n\n# Generate opposite colors.\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             opposite = TRUE,\n                             plot = TRUE)\n\np\n\n\n\nOpposite colors\n\n\n\n\nAdjacent colors\n\n# Generate adjacent colors.\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             adjacent = TRUE,\n                             plot = TRUE)\n\np\n\n\n\nAdjacent colors.\n\n\n\n\nTriadic colors\n\n# Generate triadic colors.\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             triadic = TRUE,\n                             plot = TRUE)\n\np\n\n\n\nTriadic colors.\n\n\n\n\nSplit complementary colors.\n\n# Generate split complementary colors.\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             split_complementary = TRUE,\n                             plot = TRUE)\n\np\n\n\n\nSplit complemmentary colors.\n\n\n\n\nTetradic colors\n\n# Generate tetradic colors\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             tetradic = TRUE,\n                             plot = TRUE)\n\np\n\n\n\nTetradic colors.\n\n\n\n\nSquare colors\n\n# Generate square colors\np <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                             square = TRUE,\n                             plot = TRUE)\n\np\n\n\n\nSquare colors."
  },
  {
    "objectID": "93-ColorPalettes.html#generate-a-color-report",
    "href": "93-ColorPalettes.html#generate-a-color-report",
    "title": "Color palettes",
    "section": "Generate a color report",
    "text": "Generate a color report\nHowever, it might be the case that one wants all combinations at the same time, to then select the one that works best. To achieve this, set complete_output = TRUE.\n\n# Generate a color report.\nout <- SCpubr::do_ColorPalette(colors.use = \"steelblue\",\n                               complete_output = TRUE)\n\n# Retrieve the color vectors.\ncolor_vectors <- out$colors\n\n# Retrieve the individual plots.\nplots <- out$plots\n\n# Retrieve a joint plot.\np <- out$combined_plot\np\n\n\n\nGenerate a color report."
  },
  {
    "objectID": "94-CommonFeatures.html",
    "href": "94-CommonFeatures.html",
    "title": "Common features across plots",
    "section": "",
    "text": "This page aims to list common features present across the different functions in the package (not all functions have them).\n\nChanging the font size: Use font.size parameter and provide a number.\nChanging the font type: Use font.type parameter and provide either sans, mono or serif.\nAdd plot titles, subtitles and captions: Use plot.title, plot.subtitle and plot.caption parameters alongside a text to display.\nChanging between legend types in continuous variables: Use legend.type parameter and provide either normal, colorbar or colorsteps.\nRelocate the legend: Use legend.position parameter alongside top, bottom, left or right or none to remove it.\nChanging the font size: Use font.size parameter and provide a number.\nModify default colors: Use colors.use for categorical variables and viridis_color_map for continuous (exceptions apply, see the corresponding subsection) and provide valid color representations or a valid viridis color map. _ Modify the direction of continuous color scales: Used alongsize viridis_color_map, provide either 1 or -1 to viridis_direction to specify whether the viridis scale goes from dark to light or vice versa.\nPlot borders around cells: Use plot_cell_borders parameter alongside border.size and border.color to customize how it looks.\nToggle the grid on or off: Use plot.grid parameter alongside grid.type for the type of lines and grid.color for the grid color to customize it.\nToggle axes on or off: Use plot.axes parameter to remove the axes.\nSubset a continuous axis: Use min.cutoff and max.cutoff.\nRasterize figures: Use raster and raster.dpi parameters. It is important to play around with pt.size parameter in order to get the output figure right."
  },
  {
    "objectID": "95-SaveFigures.html",
    "href": "95-SaveFigures.html",
    "title": "Save the figures",
    "section": "",
    "text": "Please note:\n\n\n\nDue to CRAN policies, this function could not make it to the official release and is only available in the development release of SCpubr. Find how to install it here.\nOnce the package becomes available on CRAN/Bioconductor, the function will be integrated in the official release.\n\n\nCreating good plots is just half of the process. It is equally important to properly save them. This is the purpose of SCpubr::save_Plot. This function is a very handy tool to save your plots easily in different formats, such as .pdf, .png, .jpeg, .tiff and .svg. This can be achieved by providing the following to output_format parameter:\n\n\n\"all\": This will store the provided plot in all 5 formats.\n\n\"publication\": This will store the plot in .pdf, .png and .svg.\n\nIndividual format: Provide the desired format and it will only be saved on that one.\n\nWidth and Height are set by default to 8 inches each, so the plot is squared. However, it is really important that these parameters are modified to the user’s need. The name of the file can be provided with file_name parameter and the path to store the files can be specified in figure_path. If not provided, figure_path will default to the current working environment and file_name will default to a combination of the current date and time. Here are some examples.\n\n# Generate a plot.\np <- SCpubr::do_DimPlot(sample = sample)\n\n# Default parameters.\nSCpubr::save_Plot(plot = p)\n\n# Specifying the name and folder.\nSCpubr::save_Plot(plot = p,\n                 figure_path = \"/path/to/my/figures/\",\n                 file_name = \"my_figure\")\n\n# Specify to also create a new folder.\nSCpubr::save_Plot(plot = p,\n                 figure_path = \"/path/to/my/figures/\",\n                 file_name = \"my_figure\",\n                 create_path = TRUE)\n\n# Set dimensions for the figure.\nSCpubr::save_Plot(plot = p,\n                 figure_path = \"/path/to/my/figures/\",\n                 file_name = \"my_figure\",\n                 create_path = TRUE,\n                 width = 8,\n                 height = 8)\n\n# Set quality (dpi).\nSCpubr::save_Plot(plot = p,\n                 figure_path = \"/path/to/my/figures/\",\n                 file_name = \"my_figure\",\n                 create_path = TRUE,\n                 width = 8,\n                 height = 8,\n                 dpi = 300)"
  },
  {
    "objectID": "96-Citation.html",
    "href": "96-Citation.html",
    "title": "Citation",
    "section": "",
    "text": "To cite SCpubr in your publications, please use:\nBlanco-Carmona, E. Generating publication ready visualizations \nfor Single Cell transcriptomics using SCpubr. bioRxiv (2022) \ndoi:10.1101/2022.02.28.482303.\nYou can also use the following BibLaTeX entry:\n@article{blanco-carmona_generating_2022,\n    title = {Generating publication ready visualizations for Single Cell transcriptomics using {SCpubr}},\n    url = {https://www.biorxiv.org/content/early/2022/03/01/2022.02.28.482303},\n    doi = {10.1101/2022.02.28.482303},\n    abstract = {Single Cell transcriptomic analysis has become a widespread technology of choice when it comes to understanding the differences at a transcriptomic level in heterogeneous samples. As a consequence, a plethora of analysis tools have been published to tackle the different analysis steps from count matrix generation to downstream analysis. Many of them provide ways to generate visualizations of the data. While some design choices are made, it is a common practice to provide the user with visualizations as raw as possible so that they can be customized to the user needs. However, in many cases these final customization steps are either time consuming or demand a very specific set of skills. This problem is addressed by {SCpubr}, which sacrifices some of this initial freedom of choice in aesthetics to provide the user a more streamlined way of generating high quality Single Cell transcriptomic visualizations.Competing Interest {StatementThe} authors have declared no competing interest.},\n    journaltitle = {{bioRxiv}},\n    author = {Blanco-Carmona, Enrique},\n    date = {2022},\n    note = {Publisher: Cold Spring Harbor Laboratory\n\\_eprint: https://www.biorxiv.org/content/early/2022/03/01/2022.02.28.482303.full.pdf},\n}"
  },
  {
    "objectID": "97-NEWS.html#scpubr-v1.1.1.9000",
    "href": "97-NEWS.html#scpubr-v1.1.1.9000",
    "title": "News",
    "section": "SCpubr v1.1.1.9000",
    "text": "SCpubr v1.1.1.9000\nCurrent development release."
  },
  {
    "objectID": "97-NEWS.html#scpubr-v1.1.1",
    "href": "97-NEWS.html#scpubr-v1.1.1",
    "title": "News",
    "section": "SCpubr v1.1.1",
    "text": "SCpubr v1.1.1\nHotfixes in unit tests to comply with CRAN checks."
  },
  {
    "objectID": "97-NEWS.html#scpubr-v1.1.0",
    "href": "97-NEWS.html#scpubr-v1.1.0",
    "title": "News",
    "section": "SCpubr v1.1.0",
    "text": "SCpubr v1.1.0\n\nGeneral\n\nIncreased the cell size of all heatmap-based functions from 5 to 8.\nDecreased the thickness of frame and ticks of all ggplot2-based continuous legends to retrieve a similar behavior as in previous versions of ggplot2, as with the new update, the overall thickness of the frame and ticks increased, probably due to the changes related to element_line,\nAdded five new functions: do_AlluvialPlot(), do_AzimuthAnalysisPlot(), do_ExpressionHeatmap(), do_GroupedGOTermPlot() and do_FunctionalAnnotationPlot().\nAdded legend.ncol, legend.nrow, legend.title and legend.byrow to as many functions as possible to further customize legend appearance.\n\n\n\nSCpubr::do_BeeSwarmPlot()\n\nAdded min.cutoff and max.cutoff parameter.\nAdded ticks to the plot, that were missing.\nAdded missing axes titles.\nAdded viridis_direction parameter to control how the continuous color scale is formed.\nAdded return_object parameter to return the Seurat object with the enrichment scores computed.\nAdded BoxPlots, BeeSwarmPlots and ViolinPlots to the possible outputs the user can choose from.\nMake legend.position conditional of whether continuous_feature is set to TRUE. If it is false, legend is not displayed unless the user specifies otherwise.\n\n\n\nSCpubr::do_BarPlot()\n\nFixed a bug in which axes titles were not displaying correctly under certain combinations of flip and split.by.\nFixed a bug in which x_lab and y_lab would not rotate accordingly when using flip = TRUE.\n\n\n\nSCpubr::do_BoxPlot()\n\nSet assay to NULL and will default to the default assay in the seurat object.\n\n\n\nSCpubr::do_CellularStatesPlot()\n\nFixed a bug that prevented FeaturePlots to have symmetrical axes with respect to the main plot.\n\n\n\nSCpubr::do_CorrelationPlot()\n\nAdded viridis_direction parameter.\n\n\n\nSCpubr::do_DimPlot()\n\nFixed a bug in which the legend title will not show up in regular basic plots even though the parameter legend.title was used.\nCompletely reformatted the way split.by works, so that now only one legend is displayed for the whole group and cells have border.\nAdded label.size and label.box parameters for further customize the appearance of the plot when using label = TRUE.\nChanged repel to FALSE by default.\n\n\n\nSCpubr::do_EnrichmentHeatmap()\n\nFixed a bug in the code that prevented the feature plots and the geyser plots to be computed if the input gene list was not a named list of genes.\nAdded flavor = \"AUCell\", that lets the user compute AUCell scoring of the gene sets.\nAdded the option to query multiple group.by parameters at the same time.\nFixed a bug in the code that prevented multiple outputs with different values of group.by to be returned properly, leading to the last value of group.by replacing all the rest.\n\n\n\nSCpubr::do_FeaturePlot()\n\nAdded label, label.size and label.color parameter to reproduce the same behavior as in Seurat::FeaturePlot().\n\n\n\nSCpubr::do_GroupwiseDEPlot()\n\nSet assay to NULL and will default to the default assay in the seurat object.\n\n\n\nSCpubr::do_LigandReceptorPlot()\n\nAdded arrange_interactions_by to control how output interactions are arranged (either by aggregate_rank, specificity, magnitude or a combination of magnitude and specificity).\nAdded sort_interactions_alphabetically to control whether the output dotplot has the interactions ordered alphabetically or as they come in the original matrix (meaning, they follow the arrangement specified in arrange_interactions_by). ((liana’s issue #72))\n\n\n\ndo_PathwayActivityPlot()\n\nAdded a fix in which when enforce_symmetry is set to FALSE, then the color scale turns into a viridis-based one instead of a two-color gradient scale.\n\n\n\ndo_TFActivityPlot()\n\nAdded a fix in which when enforce_symmetry is set to FALSE, then the color scale turns into a viridis-based one instead of a two-color gradient scale.\n\n\n\nSCpubr::do_ViolinPlot()\n\nFixed a bug in the code in which no different colors could be passed to colors.use.\nReduced default line width from 1 to 0.5."
  },
  {
    "objectID": "97-NEWS.html#scpubr-v1.0.4",
    "href": "97-NEWS.html#scpubr-v1.0.4",
    "title": "News",
    "section": "SCpubr v1.0.4",
    "text": "SCpubr v1.0.4\n\nHotfix for v1.0.3 in which do_GeyserPlot with categorical variables had a bug that mapped the legend to the continuous axis."
  },
  {
    "objectID": "97-NEWS.html#scpubr-v1.0.3",
    "href": "97-NEWS.html#scpubr-v1.0.3",
    "title": "News",
    "section": "SCpubr v1.0.3",
    "text": "SCpubr v1.0.3\n\nGeneral changes\n\nAdded min.cutoff and max.cutoff parameter to effectively subset the color scale and remove the effect of extreme outliers in all ComplexHeatmap-based functions.\nAdded min.cutoff and max.cutoff parameter to effectively subset the color scale and remove the effect of extreme outliers in all ggplot2-based functions susceptible to be biased by outliers.\n\n\n\nSCpubr::do_DimPlot()\n\nImplemented a change in which when using split.by and group.by in combination, the cells colored on top of the UMAP also have a border.\nImplemented a bug-fix in which when using split.by and group.by in combination, the extra new layers would not raster if raster = TRUE.\nImplemented a bug-fix in which when using split.by and group.by in combination, no plots will appear if ncol is set.\nImplemented a new feature to add density line contours using plot_density_contour.\nImplemented the conditional use of raster.dpi to Seurat versions higher or equal to 4.1.0.\n\n\n\nSCpubr::do_EnrichmentHeatmap()\n\nImplemented a bug fix for internal checks in the function.\nAdded plot_FeaturePlots and plot_GeyserPlots to also report the enrichment scores in a gene set-based manner.\nAdded flavor parameter, that accepts Seurat and UCell to allow for different enrichment scoring methods. It requires R 4.2.0 to run.\nRenamed symmetrical_scale to enforce_symmetry to have a greater coherence accross functions.\n\n\n\nSCpubr::do_FeaturePlot()\n\nImplemented a new feature to add density line contours using plot_density_contour.\nImplemented the conditional use of raster.dpi to Seurat versions higher or equal to 4.1.0.\n\n\n\nSCpubr::do_GeyserPlot()\n\nFixed bug in which internal parameter names made it to the X axis title.\nRemoved color.by implementation due to it being very buggy. This will be re-implemented in a future patch.\n\n\n\nSCpubr::do_RidgePlot()\n\nImplemented a bug-fix in which using assay = \"RNA\" or, in fact, any other assay rather than SCT will result in an error.\n\n\n\nSCpubr::do_ViolinPlot()\n\nCorrected a bug in which legend title when using split.by was an actual line of code.\nAdded legend.title parameter to control the title of the legend.\n\nThis version can be obtained in the v1.0.3 release release or downloading it from CRAN using:\n\nSCpubr v.1.0.3-dev-stable\n\nSame as v1.0.3, but with all the functions that do not pass CRAN checks. These functions are: SCpubr::save_Plot() SCpubr::do_LigandReceptorPlot() and SCpubr::do_SankeyPlot().\n\nThis version can be obtained in the v1.0.3-dev-stable release release."
  },
  {
    "objectID": "97-NEWS.html#scpubr-v1.0.2",
    "href": "97-NEWS.html#scpubr-v1.0.2",
    "title": "News",
    "section": "SCpubr v1.0.2",
    "text": "SCpubr v1.0.2\n\nGeneral changes\n\nChange color palette when using enforce_symmetry = TRUE to have the middle color as grey95 instead of the previous one, which made middle values seem closer to the positive end of the scale.\nModified internal structure of all functions to abide with tidyselect v1.2.0 lifecycle modifications.\nModified rotate_x_axis_labels parameter in all functions that made use of it. Now, instead of accepting a logical, accepts a numeric: either 0, 45 or 90, corresponding to the degrees in which the X axis labels should be rotated. (#5)\n\n\n\nSCpubr::do_CopyNumberVariantPlot\n\nModified the code for SCpubr::do_CopyNumberVariantPlot to also report results for the whole chromosome as well as for each chromosome arm.\nInclude the verbose argument to SCpubr::do_CopyNumberVariantPlot to silence the messages when there are not enough genes in the chromosome to perform the analysis.\n\n\n\nSCpubr::do_DimPlot()\n\nFixed a typo that prevented labels to be bold in SCpubr::do_DimPlot() when cell borders are displayed.\nAdded group.by and split.by functionality to SCpubr::do_DimPlot(). (#4)\n\n\n\nSCpubr::do_DotPlot()\n\nAdded ticks to axes.\nModified default colors to convey a better aesthetic.\n\n\n\nSCpubr::do_FeaturePlot()\n\nFixed potential bugs in SCpubr::do_FeaturePlot when setting enforce_symmetry = TRUE.\nChanged default value of order in SCpubr::do_FeaturePlot() from TRUE to FALSE.\nAdded min.cutoff and max.cutoff parameters to SCpubr::do_FeaturePlot(). This allows to effectively subset the color scale to the values provided. Cells outside the range will be converted to the min or max values provided, respectively. (#2)\n\n\n\nSCpubr::do_GeyserPlot()\n\nAdded flip parameter.\n\n\n\nSCpubr::do_GroupwiseDEPlot()\n\nFixed bug in SCpubr::do_GroupwiseDEPlot in which the heatmap could not be computed. (#3)\nAdded extra checks to ensure proper input in SCpubr::do_GroupwiseDEPlot. (#3)\n\n\n\nSCpubr::do_LigandReceptorPlot() (development release)\n\nChanged parameter x_labels_angle to rotate_x_axis_labels to keep a consistent terminology.\n\n\n\nSCpubr::do_RidgePlot()\n\nFixed a typo that made the lines in panel.grid.minor to be displayed in SCpubr::do_Ridgeplot().\nAdded flip parameter.\n\n\n\nSCpubr::do_ViolinPlot()\n\nAdded split.by functionality to SCpubr::do_ViolinPlot(). (#4, #5)\nAdded flip parameter.\nNow multiple features can be queried ad the same time. (#5)\nChanged feature parameter to features, to better reflect the multiple feature behavior.\nRecreated Seurat’s share.y.lims behavior and set it to share.y.lims parameter. (#5)\n\n\n\nSCpubr v1.0.2-dev-stable\n\nSame as v1.0.2, but with all the functions that do not pass CRAN checks. These functions are: SCpubr::save_Plot() SCpubr::do_LigandReceptorPlot() and SCpubr::do_SankeyPlot().\n\nThis version can be obtained in the v1.0.2-dev-stable release release."
  },
  {
    "objectID": "97-NEWS.html#scpubr-v1.0.1",
    "href": "97-NEWS.html#scpubr-v1.0.1",
    "title": "News",
    "section": "SCpubr v1.0.1",
    "text": "SCpubr v1.0.1\n\nRework on unit tests and examples so that it can pass CRAN R CMD Check without packages in Suggests. This is, to make sure all Suggested packages are used conditionally.\n\n\nSCpubr v1.0.1-dev-stable\n\nSame as v1.0.1, but with all the functions that do not pass CRAN checks. These functions are: SCpubr::save_Plot() SCpubr::do_LigandReceptorPlot() and SCpubr::do_SankeyPlot().\n\nThis version can be obtained in the v1.0.1-dev-stable release release."
  },
  {
    "objectID": "97-NEWS.html#scpubr-v1.0.0",
    "href": "97-NEWS.html#scpubr-v1.0.0",
    "title": "News",
    "section": "SCpubr v1.0.0",
    "text": "SCpubr v1.0.0\n\nModified internal checks so that the functions that do not use Seurat do not require this to be installed. This is just for the very side case in which somebody downloads the package just for the SCpubr::do_ColorPalette() function.\nRemoved the option to use individual.titles, ’individual.subtitlesandindividual.captionsinSCpubr::do_NebulosaPlot()` as the benefit of such parameters did not surpass the problems the code was causing. The feature might come back in the future, once fully optimized.\nRemoved SCpubr::save_Plot() function to align with CRAN policies that the package should not write to the file system. The code is still available in the v0.0.0.0.9000 release in Github.\nRemoved SCpubr::do_LigandReceptorPlot(), SCpubr::do_SankeyPlot() and SCpubr::do_PseudotimePlot() to align with CRAN policies and make it possible to publish the package. These functions can still be accessed in the v0.0.0.0.9000 release in Github.\nRemoved SCpubr::do_PseudotimePlot() for the reason above and because the dependency Matrix.utils was removed from CRAN on 09-10-2022.\n\nThis version can be obtained in the v1.0.0 release release.\n\nSCpubr v1.0.0-dev-stable\n\nSame as v1.0.0, but with all the functions that do not pass CRAN checks. These functions are: SCpubr::save_Plot() SCpubr::do_LigandReceptorPlot() and SCpubr::do_SankeyPlot().\n\nThis version can be obtained in the v1.0.0-dev-stable release release."
  },
  {
    "objectID": "97-NEWS.html#scpubr-0.0.0.9000",
    "href": "97-NEWS.html#scpubr-0.0.0.9000",
    "title": "News",
    "section": "SCpubr 0.0.0.9000",
    "text": "SCpubr 0.0.0.9000\n\nAdded a NEWS.md file to track changes to the package.\nPrepare package for submission to CRAN."
  },
  {
    "objectID": "99-Acknowledgements.html",
    "href": "99-Acknowledgements.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "In this section I would like to give my thanks to all the people that have helped me developing this package:\n\nPD. Dr. med. Pascal Johann, Dr. Natalie Jäger, Dr. Marcel Kool and Prof. Dr. Matthias Schlesner for providing a fruitful working environment that made it possible for this project to take place.\nMy co-workers Christina Blume, Areeba Patel and Dina ElHarouni for bearing with me and providing their personal view on the endless tiny details that can be modified in the plots.\nThe artist Marta Palop Llacer, for creating the flaticon of the webpage."
  }
]